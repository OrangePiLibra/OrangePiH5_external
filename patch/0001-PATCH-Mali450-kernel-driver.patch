From dd6f548ebb1b7afc74297139c5e45ff8ba12df95 Mon Sep 17 00:00:00 2001
From: orangepi <buddy.d.zhang@gmail.com>
Date: Fri, 7 Apr 2017 16:58:23 +0800
Subject: [PATCH] [PATCH] Mali450 kernel driver

---
 .config                                           |   32 +-
 arch/arm64/configs/OrangePiH5_PC2_defconfig       |   32 +-
 drivers/gpu/drm/Kconfig                           |    2 +
 drivers/gpu/drm/Makefile                          |    1 +
 drivers/gpu/drm/sunxi/Kconfig                     |   12 +
 drivers/gpu/drm/sunxi/Makefile                    |   32 +
 drivers/gpu/drm/sunxi/README                      |    7 +
 drivers/gpu/drm/sunxi/build-sunxi.sh              |    5 +
 drivers/gpu/drm/sunxi/drm_de/drm_al.c             |  252 ++++
 drivers/gpu/drm/sunxi/drm_de/drm_al.h             |   82 ++
 drivers/gpu/drm/sunxi/subdev/sun50iw1_transform.c |  389 ++++++
 drivers/gpu/drm/sunxi/subdev/sunxi_common.c       |  403 ++++++
 drivers/gpu/drm/sunxi/subdev/sunxi_common.h       |   57 +
 drivers/gpu/drm/sunxi/subdev/sunxi_g2d.c          |    1 +
 drivers/gpu/drm/sunxi/subdev/sunxi_hdmi.c         |  813 ++++++++++++
 drivers/gpu/drm/sunxi/subdev/sunxi_hdmi.h         |   80 ++
 drivers/gpu/drm/sunxi/subdev/sunxi_lcd.c          | 1438 +++++++++++++++++++++
 drivers/gpu/drm/sunxi/subdev/sunxi_lcd.h          |   39 +
 drivers/gpu/drm/sunxi/subdev/sunxi_rotate.c       |  561 ++++++++
 drivers/gpu/drm/sunxi/subdev/sunxi_rotate.h       |   70 +
 drivers/gpu/drm/sunxi/subdev/sunxi_tv.c           |    1 +
 drivers/gpu/drm/sunxi/subdev/transform.h          |   67 +
 drivers/gpu/drm/sunxi/sunxi_drm_connector.c       |  561 ++++++++
 drivers/gpu/drm/sunxi/sunxi_drm_connector.h       |   52 +
 drivers/gpu/drm/sunxi/sunxi_drm_core.c            |  475 +++++++
 drivers/gpu/drm/sunxi/sunxi_drm_core.h            |   64 +
 drivers/gpu/drm/sunxi/sunxi_drm_crtc.c            | 1082 ++++++++++++++++
 drivers/gpu/drm/sunxi/sunxi_drm_crtc.h            |  102 ++
 drivers/gpu/drm/sunxi/sunxi_drm_dmabuf.c          |  313 +++++
 drivers/gpu/drm/sunxi/sunxi_drm_dmabuf.h          |   28 +
 drivers/gpu/drm/sunxi/sunxi_drm_drv.c             |  306 +++++
 drivers/gpu/drm/sunxi/sunxi_drm_drv.h             |   24 +
 drivers/gpu/drm/sunxi/sunxi_drm_encoder.c         |  722 +++++++++++
 drivers/gpu/drm/sunxi/sunxi_drm_encoder.h         |   53 +
 drivers/gpu/drm/sunxi/sunxi_drm_fb.c              |  223 ++++
 drivers/gpu/drm/sunxi/sunxi_drm_fb.h              |   46 +
 drivers/gpu/drm/sunxi/sunxi_drm_fbdev.c           |  598 +++++++++
 drivers/gpu/drm/sunxi/sunxi_drm_fbdev.h           |   29 +
 drivers/gpu/drm/sunxi/sunxi_drm_gem.c             |  594 +++++++++
 drivers/gpu/drm/sunxi/sunxi_drm_gem.h             |   63 +
 drivers/gpu/drm/sunxi/sunxi_drm_panel.c           |   57 +
 drivers/gpu/drm/sunxi/sunxi_drm_panel.h           |   58 +
 drivers/gpu/drm/sunxi/sunxi_drm_plane.c           |  953 ++++++++++++++
 drivers/gpu/drm/sunxi/sunxi_drm_plane.h           |   50 +
 drivers/video/sunxi/disp2/disp/dev_fb.c           |    6 +-
 include/drm/sunxi_drm.h                           |  111 ++
 modules/gpu/Makefile                              |    4 +
 47 files changed, 10929 insertions(+), 21 deletions(-)
 create mode 100755 drivers/gpu/drm/sunxi/Kconfig
 create mode 100755 drivers/gpu/drm/sunxi/Makefile
 create mode 100644 drivers/gpu/drm/sunxi/README
 create mode 100755 drivers/gpu/drm/sunxi/build-sunxi.sh
 create mode 100755 drivers/gpu/drm/sunxi/drm_de/drm_al.c
 create mode 100755 drivers/gpu/drm/sunxi/drm_de/drm_al.h
 create mode 100755 drivers/gpu/drm/sunxi/subdev/sun50iw1_transform.c
 create mode 100755 drivers/gpu/drm/sunxi/subdev/sunxi_common.c
 create mode 100755 drivers/gpu/drm/sunxi/subdev/sunxi_common.h
 create mode 100755 drivers/gpu/drm/sunxi/subdev/sunxi_g2d.c
 create mode 100755 drivers/gpu/drm/sunxi/subdev/sunxi_hdmi.c
 create mode 100755 drivers/gpu/drm/sunxi/subdev/sunxi_hdmi.h
 create mode 100755 drivers/gpu/drm/sunxi/subdev/sunxi_lcd.c
 create mode 100755 drivers/gpu/drm/sunxi/subdev/sunxi_lcd.h
 create mode 100755 drivers/gpu/drm/sunxi/subdev/sunxi_rotate.c
 create mode 100755 drivers/gpu/drm/sunxi/subdev/sunxi_rotate.h
 create mode 100755 drivers/gpu/drm/sunxi/subdev/sunxi_tv.c
 create mode 100755 drivers/gpu/drm/sunxi/subdev/transform.h
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_connector.c
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_connector.h
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_core.c
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_core.h
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_crtc.c
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_crtc.h
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_dmabuf.c
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_dmabuf.h
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_drv.c
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_drv.h
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_encoder.c
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_encoder.h
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_fb.c
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_fb.h
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_fbdev.c
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_fbdev.h
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_gem.c
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_gem.h
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_panel.c
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_panel.h
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_plane.c
 create mode 100755 drivers/gpu/drm/sunxi/sunxi_drm_plane.h
 create mode 100644 include/drm/sunxi_drm.h

diff --git a/.config b/.config
index ec6eb7c..485dd67 100644
--- a/.config
+++ b/.config
@@ -1484,6 +1484,7 @@ CONFIG_I2C_COMPAT=y
 # CONFIG_I2C_CHARDEV is not set
 # CONFIG_I2C_MUX is not set
 CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
 
 #
 # I2C Hardware Bus support
@@ -2087,9 +2088,24 @@ CONFIG_VIDEO_ENCODER_DECODER_SUNXI=y
 # GPU support for sunxi
 #
 CONFIG_SUNXI_GPU_TYPE="mali450"
-# CONFIG_DRM is not set
+CONFIG_DRM=y
+CONFIG_DRM_USB=y
+CONFIG_DRM_KMS_HELPER=y
+CONFIG_DRM_LOAD_EDID_FIRMWARE=y
+
+#
+# I2C encoder or helper chips
+#
+CONFIG_DRM_I2C_CH7006=y
+CONFIG_DRM_I2C_SIL164=y
+CONFIG_DRM_I2C_NXP_TDA998X=y
+CONFIG_DRM_UDL=y
+CONFIG_DRM_SUNXI=m
+CONFIG_DRM_SUNXI_ROTATER=y
+CONFIG_DRM_SUNXI_HDMI=y
 # CONFIG_VGASTATE is not set
 # CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_HDMI=y
 # CONFIG_VEXPRESS_DVI_CONTROL is not set
 CONFIG_FB=y
 # CONFIG_FIRMWARE_EDID is not set
@@ -2099,11 +2115,12 @@ CONFIG_FB=y
 # CONFIG_FB_CFB_COPYAREA is not set
 # CONFIG_FB_CFB_IMAGEBLIT is not set
 # CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
-# CONFIG_FB_SYS_FILLRECT is not set
-# CONFIG_FB_SYS_COPYAREA is not set
-# CONFIG_FB_SYS_IMAGEBLIT is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
 # CONFIG_FB_FOREIGN_ENDIAN is not set
 # CONFIG_FB_SYS_FOPS is not set
+CONFIG_FB_DEFERRED_IO=y
 # CONFIG_FB_SVGALIB is not set
 # CONFIG_FB_MACMODES is not set
 # CONFIG_FB_BACKLIGHT is not set
@@ -2118,12 +2135,7 @@ CONFIG_FB=y
 # Video support for sunxi
 #
 # CONFIG_FB_CONSOLE_SUNXI is not set
-CONFIG_DISP2_SUNXI=y
-CONFIG_HDMI_DISP2_SUNXI=y
-CONFIG_TV_DISP2_SUNXI=y
-# CONFIG_DISP2_TV_GM7121 is not set
-# CONFIG_DISP2_SUNXI_BOOT_COLORBAR is not set
-CONFIG_DISP2_SUNXI_DEBUG=y
+# CONFIG_DISP2_SUNXI is not set
 # CONFIG_FB_ARMCLCD is not set
 # CONFIG_FB_S1D13XXX is not set
 # CONFIG_FB_TMIO is not set
diff --git a/arch/arm64/configs/OrangePiH5_PC2_defconfig b/arch/arm64/configs/OrangePiH5_PC2_defconfig
index ec6eb7c..485dd67 100644
--- a/arch/arm64/configs/OrangePiH5_PC2_defconfig
+++ b/arch/arm64/configs/OrangePiH5_PC2_defconfig
@@ -1484,6 +1484,7 @@ CONFIG_I2C_COMPAT=y
 # CONFIG_I2C_CHARDEV is not set
 # CONFIG_I2C_MUX is not set
 CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
 
 #
 # I2C Hardware Bus support
@@ -2087,9 +2088,24 @@ CONFIG_VIDEO_ENCODER_DECODER_SUNXI=y
 # GPU support for sunxi
 #
 CONFIG_SUNXI_GPU_TYPE="mali450"
-# CONFIG_DRM is not set
+CONFIG_DRM=y
+CONFIG_DRM_USB=y
+CONFIG_DRM_KMS_HELPER=y
+CONFIG_DRM_LOAD_EDID_FIRMWARE=y
+
+#
+# I2C encoder or helper chips
+#
+CONFIG_DRM_I2C_CH7006=y
+CONFIG_DRM_I2C_SIL164=y
+CONFIG_DRM_I2C_NXP_TDA998X=y
+CONFIG_DRM_UDL=y
+CONFIG_DRM_SUNXI=m
+CONFIG_DRM_SUNXI_ROTATER=y
+CONFIG_DRM_SUNXI_HDMI=y
 # CONFIG_VGASTATE is not set
 # CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_HDMI=y
 # CONFIG_VEXPRESS_DVI_CONTROL is not set
 CONFIG_FB=y
 # CONFIG_FIRMWARE_EDID is not set
@@ -2099,11 +2115,12 @@ CONFIG_FB=y
 # CONFIG_FB_CFB_COPYAREA is not set
 # CONFIG_FB_CFB_IMAGEBLIT is not set
 # CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
-# CONFIG_FB_SYS_FILLRECT is not set
-# CONFIG_FB_SYS_COPYAREA is not set
-# CONFIG_FB_SYS_IMAGEBLIT is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
 # CONFIG_FB_FOREIGN_ENDIAN is not set
 # CONFIG_FB_SYS_FOPS is not set
+CONFIG_FB_DEFERRED_IO=y
 # CONFIG_FB_SVGALIB is not set
 # CONFIG_FB_MACMODES is not set
 # CONFIG_FB_BACKLIGHT is not set
@@ -2118,12 +2135,7 @@ CONFIG_FB=y
 # Video support for sunxi
 #
 # CONFIG_FB_CONSOLE_SUNXI is not set
-CONFIG_DISP2_SUNXI=y
-CONFIG_HDMI_DISP2_SUNXI=y
-CONFIG_TV_DISP2_SUNXI=y
-# CONFIG_DISP2_TV_GM7121 is not set
-# CONFIG_DISP2_SUNXI_BOOT_COLORBAR is not set
-CONFIG_DISP2_SUNXI_DEBUG=y
+# CONFIG_DISP2_SUNXI is not set
 # CONFIG_FB_ARMCLCD is not set
 # CONFIG_FB_S1D13XXX is not set
 # CONFIG_FB_TMIO is not set
diff --git a/drivers/gpu/drm/Kconfig b/drivers/gpu/drm/Kconfig
index b16c50e..68db3ca 100644
--- a/drivers/gpu/drm/Kconfig
+++ b/drivers/gpu/drm/Kconfig
@@ -220,3 +220,5 @@ source "drivers/gpu/drm/omapdrm/Kconfig"
 source "drivers/gpu/drm/tilcdc/Kconfig"
 
 source "drivers/gpu/drm/qxl/Kconfig"
+
+source "drivers/gpu/drm/sunxi/Kconfig"
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index 1c9f243..700b63a 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -53,3 +53,4 @@ obj-$(CONFIG_DRM_OMAP)	+= omapdrm/
 obj-$(CONFIG_DRM_TILCDC)	+= tilcdc/
 obj-$(CONFIG_DRM_QXL) += qxl/
 obj-y			+= i2c/
+obj-y			+= sunxi/
diff --git a/drivers/gpu/drm/sunxi/Kconfig b/drivers/gpu/drm/sunxi/Kconfig
new file mode 100755
index 0000000..6e7c2af
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/Kconfig
@@ -0,0 +1,12 @@
+menuconfig DRM_SUNXI
+    tristate "DRM Support for Allwinnertech SoC A and R Series"
+    depends on DRM && ARCH_SUNXI
+    select DRM_KMS_HELPER
+    help
+      Choose this for Allwintertech  A64 R18 and others.
+config DRM_SUNXI_ROTATER
+	bool "Support the sunxi rotate device"
+
+config DRM_SUNXI_HDMI
+	bool "Support the sunxi hdmi device"
+
diff --git a/drivers/gpu/drm/sunxi/Makefile b/drivers/gpu/drm/sunxi/Makefile
new file mode 100755
index 0000000..316ebe6
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/Makefile
@@ -0,0 +1,32 @@
+
+low_level_dir = drivers/video/sunxi/disp2/disp
+hdmi_dir = drivers/video/sunxi/disp2/hdmi
+sub_dir = lowlevel_v2x
+
+include $(low_level_dir)/de/Makefile
+include $(low_level_dir)/de/$(sub_dir)/Makefile
+
+ccflags-y := -Iinclude/drm -Idrivers/gpu/drm/sunxi -Idrivers/video/sunxi/disp2/disp -Idrivers/video/sunxi/disp2/disp/de/$(sub_dir)
+ccflags-y += -I$(low_level_dir)/$(sub_dir)
+ccflags-y += -I$(hdmi_dir)
+
+$(shell cp $(obj)/../../../../$(hdmi_dir)/libhdmi_sun50iw1 $(obj)/subdev/libhdmi_sunxi.a)
+
+
+sunxidrm-y := sunxi_drm_core.o sunxi_drm_crtc.o  sunxi_drm_connector.o sunxi_drm_dmabuf.o \
+			  sunxi_drm_encoder.o sunxi_drm_fbdev.o sunxi_drm_gem.o sunxi_drm_panel.o \
+			  sunxi_drm_drv.o sunxi_drm_fb.o sunxi_drm_plane.o
+
+sunxidrm-y += drm_de/drm_al.o
+sunxidrm-y += subdev/sunxi_lcd.o subdev/sunxi_common.o subdev/sunxi_hdmi.o subdev/sun50iw1_transform.o subdev/sunxi_rotate.o
+sunxidrm-y += subdev/libhdmi_sunxi.a
+
+filter_obj = $(filter-out $(mydir)/disp_al.o,$(obj_low))
+
+drm_low_obj = $(addprefix ../../../../$(low_level_dir)/,$(filter_obj))
+
+sunxidrm-y += $(drm_low_obj)
+
+#obj-$(CONFIG_DRM_SUNXI)        += sunxidrm.o
+obj-m        += sunxidrm.o
+
diff --git a/drivers/gpu/drm/sunxi/README b/drivers/gpu/drm/sunxi/README
new file mode 100644
index 0000000..1241e8f
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/README
@@ -0,0 +1,7 @@
+1. when you want to build sunxi for module, you need clone it to lichee/linux-3.10/drivers/gpu/drm/ and repace the original sunxi dir;
+
+2. Support lichee/build.sh;
+
+3. Use the 
+	./build-sunxi.sh
+	to build sunxi module, only after finish step 1;
diff --git a/drivers/gpu/drm/sunxi/build-sunxi.sh b/drivers/gpu/drm/sunxi/build-sunxi.sh
new file mode 100755
index 0000000..57b54f0
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/build-sunxi.sh
@@ -0,0 +1,5 @@
+ARCH=arm64
+echo $PWD
+CROSS_COMPILE=${PWD}/../../../../../out/sun50iw2p1/ubuntu/common/buildroot/external-toolchain/bin/aarch64-linux-gnu-
+KERNELDIR=${PWD}/../../../../
+make -C ${KERNELDIR} ARCH=${ARCH} CROSS_COMPILE=${CROSS_COMPILE}  M=${PWD} -j4
diff --git a/drivers/gpu/drm/sunxi/drm_de/drm_al.c b/drivers/gpu/drm/sunxi/drm_de/drm_al.c
new file mode 100755
index 0000000..0fb74af
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/drm_de/drm_al.c
@@ -0,0 +1,252 @@
+#include "de_feat.h"
+#include "drm_al.h"
+#include "sunxi_drm_core.h"
+#include "sunxi_drm_panel.h"
+#include "subdev/sunxi_common.h"
+#include "sunxi_drm_crtc.h"
+#include <drm/drmP.h>
+
+
+void sunxi_drm_crtc_clk_disable(int nr)
+{
+	de_clk_disable(DE_CLK_CORE0 + nr);
+}
+
+void sunxi_drm_crtc_clk_enable(int nr)
+{
+	de_clk_enable(DE_CLK_CORE0 + nr);
+}
+
+int sunxi_drm_get_max_crtc(void)
+{
+	/* return the DE count */
+	return de_feat_get_num_screens();
+}
+
+int sunxi_drm_get_max_connector(void)
+{
+	return de_feat_get_num_devices();
+}
+
+int sunxi_drm_get_max_encoder(void)
+{
+	/* return the tcon count*/
+	return de_feat_get_num_devices();
+}
+
+int sunxi_drm_get_vi_pipe_by_crtc(int crtc)
+{
+	return de_feat_get_num_vi_chns(crtc);
+}
+
+int sunxi_drm_get_num_chns_by_crtc(int nr)
+{
+	return de_feat_get_num_chns(nr);
+}
+
+int sunxi_drm_encoder_support(int encoder, unsigned int output_type)
+{
+	return de_feat_is_supported_output_types(encoder, output_type);
+}
+
+void sunxi_drm_crtc_updata_fps(int crtc, int fps)
+{
+	de_update_device_fps(crtc, fps);
+}
+
+int sunxi_drm_get_crtc_pipe_plane(int crtc, int channel)
+{
+	return de_feat_get_num_layers_by_chn(crtc, channel);
+}
+
+int sunxi_drm_get_plane_by_crtc(int crtc)
+{
+	return de_feat_get_num_layers(crtc);
+}
+
+int sunxi_drm_updata_reg(int crtc)
+{
+	return de_al_mgr_update_regs(crtc);
+}
+
+int sunxi_drm_sync_reg(int crtc)
+{
+	return de_rtmx_set_dbuff_rdy(crtc);
+}
+
+int sunxi_drm_apply_cache(int crtc, struct disp_manager_data *data)
+{
+	return de_al_mgr_apply(crtc, data);
+}
+
+void sunxi_drm_updata_crtc(struct sunxi_drm_crtc *sunxi_crtc,
+	struct sunxi_drm_connector *sunxi_connector)
+{
+#ifdef CONFIG_ARCH_SUN8IW11
+	sunxi_connector = sunxi_connector;
+	de_al_lyr_apply(sunxi_crtc->crtc_id, sunxi_crtc->plane_cfgs,
+		sunxi_crtc->plane_of_de, false);
+#endif
+#ifdef CONFIG_ARCH_SUN50IW1P1
+	de_al_lyr_apply(sunxi_crtc->crtc_id, sunxi_crtc->plane_cfgs,
+		sunxi_crtc->plane_of_de, sunxi_connector->disp_out_type);
+#endif
+#ifdef CONFIG_ARCH_SUN50IW2P1
+	sunxi_connector = sunxi_connector;
+	de_al_lyr_apply(sunxi_crtc->crtc_id, sunxi_crtc->plane_cfgs,
+		sunxi_crtc->plane_of_de, false);
+#endif
+}
+
+void sunxi_updata_crtc_freq(unsigned long rate)
+{
+#ifdef CONFIG_ARCH_SUN8IW11
+	de_update_clk_rate(rate);
+#endif
+#ifdef CONFIG_ARCH_SUN50IW1P1
+	de_update_de_frequency(rate);
+#endif
+#ifdef CONFIG_ARCH_SUN50IW2P1
+	de_update_clk_rate(rate);
+#endif
+}
+
+bool sunxi_drm_init_al(disp_bsp_init_para *para)
+{
+	int i;
+	de_feat_init(); // h5-sunxi50w2p1 need it to initialize de_cur_features
+	de_al_init(para);
+	de_enhance_init(para);
+	de_ccsc_init(para);
+	de_dcsc_init(para);
+#ifdef CONFIG_ARCH_SUN8IW11
+	wb_ebios_init(para);
+#endif
+#ifdef CONFIG_ARCH_SUN50IW1P1
+	WB_EBIOS_Init(para);
+#endif
+#ifdef CONFIG_ARCH_SUN50IW2P1
+	wb_ebios_init(para);
+#endif
+	de_clk_set_reg_base(para->reg_base[DISP_MOD_DE]);
+
+	for (i = 0; i < DEVICE_NUM; i++) {
+		tcon_set_reg_base(i, para->reg_base[DISP_MOD_LCD0 + i]);//calc lcd1 base
+		de_smbl_init(i, para->reg_base[DISP_MOD_DE]);
+	}
+#if defined(HAVE_DEVICE_COMMON_MODULE)
+	tcon_top_set_reg_base(0, para->reg_base[DISP_MOD_DEVICE]);
+#endif
+
+#ifdef SUPPORT_DSI
+	dsi_set_reg_base(0, para->reg_base[DISP_MOD_DSI0]);
+#endif
+
+	return true;
+}
+
+int bsp_disp_get_print_level(void)
+{
+	return 0;
+}
+
+int disp_delay_us(u32 us)
+{
+	udelay(us);
+	return 0;
+}
+
+s32 disp_delay_ms(u32 ms)
+{
+	sunxi_drm_delayed_ms(ms);
+	return 0;
+}
+
+int disp_sys_script_get_item(char *main_name, char *sub_name, int value[], int type)
+{
+	struct device_node *node;
+	char compat[32];
+	u32 len = 0;
+
+	len = sprintf(compat, "sunxi-%s", main_name);
+	node = sunxi_drm_get_name_node(compat);
+	if (!node) {
+		DRM_ERROR("get [%s] item err.\n", main_name);
+		return -EINVAL;
+	}
+	switch (type) {
+	case 1:
+		if(sunxi_drm_get_sys_item_int(node, sub_name, value))
+			return 0;
+		return type;
+	case 2:
+		if(sunxi_drm_get_sys_item_char(node, sub_name, (char *)value))
+			return 0;
+		return type;
+	case 3:
+		if(sunxi_drm_get_sys_item_gpio(node, sub_name, (disp_gpio_set_t *)value))
+			return 0;
+		return type;
+	default:
+		return 0;
+	}
+}
+
+int disp_checkout_straight(unsigned int disp, struct disp_layer_config_data *data)
+{
+	unsigned char i,chn,vi_chn,device_type;
+	struct disp_layer_config_data * pdata;
+	u32 num_layers = sunxi_drm_get_plane_by_crtc(disp);
+	u32 num_layers_video_by_chn[4] = {0};
+	u32 num_layers_video = 0;
+	u32 index = 0;
+	chn = sunxi_drm_get_num_chns_by_crtc(disp);
+
+	vi_chn = sunxi_drm_get_vi_pipe_by_crtc(disp);
+	for (i = 0; i < vi_chn; i++) {
+		num_layers_video_by_chn[i] = sunxi_drm_get_crtc_pipe_plane(disp, i);
+	}
+
+	for (i = 0; i < vi_chn; i++) {
+		num_layers_video += sunxi_drm_get_crtc_pipe_plane(disp, i);
+	}
+
+	pdata = data;
+
+	device_type = get_sunxi_crtc_out_type(disp);
+
+
+	if(device_type == DISP_OUTPUT_TYPE_TV)
+	{
+		int j;
+		for (j = 0; j < vi_chn; j++) {
+			for(i = 0; i < num_layers_video_by_chn[j]; i++) {
+				if(pdata->config.enable &&
+					pdata->config.info.fb.format >= DISP_FORMAT_YUV444_I_AYUV) {
+					pdata = data + num_layers_video_by_chn[j] + index;
+					index += num_layers_video_by_chn[j];
+					break;
+				}
+				pdata++;
+			}
+		}
+
+		if (index < num_layers_video) {
+			return -1;
+		}
+		for (i = index; i < num_layers; i++) {
+			if(pdata->config.enable) {
+				index++;
+				break;
+			}
+			pdata++;
+		}
+		if (index > num_layers_video) {
+			return -1;
+		}
+	}else
+		return -1;
+
+	return 0;
+}
+
diff --git a/drivers/gpu/drm/sunxi/drm_de/drm_al.h b/drivers/gpu/drm/sunxi/drm_de/drm_al.h
new file mode 100755
index 0000000..b00923b
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/drm_de/drm_al.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+/*de_al is the file contans the ops for the Display Engine hardware opration*/
+#ifndef _SUNXI_DE_AL_H_
+#define _SUNXI_DE_AL_H_
+#include "de/include.h"
+
+#if defined(CONFIG_ARCH_SUN50IW1P1)
+#include "de/lowlevel_sun50iw1/de_hal.h"
+#include "de/lowlevel_sun50iw1/de_clock.h"
+#include "de/lowlevel_sun50iw1/de_lcd.h"
+#include "de/lowlevel_sun50iw1/disp_al.h"
+#include "de/lowlevel_sun50iw1/de_dsi.h"
+#elif defined(CONFIG_ARCH_SUN8IW10)
+#include "de/lowlevel_sun8iw10/de_hal.h"
+#include "de/lowlevel_sun8iw10/de_clock.h"
+#include "de/lowlevel_sun8iw10/de_lcd.h"
+#include "de/lowlevel_sun8iw10/disp_al.h"
+#include "de/lowlevel_sun8iw10/de_dsi.h"
+#elif defined(CONFIG_ARCH_SUN8IW11)
+#include "de/lowlevel_v2x/de_hal.h"
+#include "de/lowlevel_v2x/de_clock.h"
+#include "de/lowlevel_v2x/de_lcd.h"
+#include "de/lowlevel_v2x/disp_al.h"
+#include "de/lowlevel_v2x/de_dsi.h"
+#elif defined(CONFIG_ARCH_SUN50IW2P1)
+#include "de/lowlevel_v2x/de_hal.h"
+#include "de/lowlevel_v2x/de_clock.h"
+#include "de/lowlevel_v2x/de_lcd.h"
+#include "de/lowlevel_v2x/disp_al.h"
+#include "de/lowlevel_v2x/de_dsi.h"
+#else
+#error "undefined platform!!!"
+#endif
+
+#include "sunxi_drm_crtc.h"
+#include "sunxi_drm_connector.h"
+
+void sunxi_drm_crtc_clk_disable(int nr);
+
+void sunxi_drm_crtc_clk_enable(int nr);
+
+int sunxi_drm_get_max_connector(void);
+
+int sunxi_drm_get_max_encoder(void);
+
+int sunxi_drm_get_num_chns_by_crtc(int nr);
+
+int sunxi_drm_get_max_crtc(void);
+
+void sunxi_drm_crtc_updata_fps(int crtc, int fps);
+
+int sunxi_drm_get_crtc_pipe_plane(int crtc, int channel);
+
+bool sunxi_drm_init_al(disp_bsp_init_para * para);
+
+int sunxi_drm_updata_reg(int crtc);
+
+int sunxi_drm_sync_reg(int crtc);
+
+int sunxi_drm_apply_cache(int crtc, struct disp_manager_data *data);
+
+int sunxi_drm_get_plane_by_crtc(int crtc);
+
+int sunxi_drm_get_vi_pipe_by_crtc(int crtc);
+
+int sunxi_drm_encoder_support(int encoder, unsigned int output_type);
+
+void sunxi_updata_crtc_freq(unsigned long rate);
+
+void sunxi_drm_updata_crtc(struct sunxi_drm_crtc *sunxi_crtc,
+	struct sunxi_drm_connector *connector);
+
+#endif
diff --git a/drivers/gpu/drm/sunxi/subdev/sun50iw1_transform.c b/drivers/gpu/drm/sunxi/subdev/sun50iw1_transform.c
new file mode 100755
index 0000000..6d963ea
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/subdev/sun50iw1_transform.c
@@ -0,0 +1,389 @@
+//*********************************************************************************************************************
+//  All Winner Tech, All Right Reserved. 2014-2015 Copyright (c)
+//
+//  File name   :	de_tr.c
+//
+//  Description :	display engine 2.0 transform processing base functions implement
+//
+//  History     :	2014/04/08  iptang  v0.1  Initial version
+//
+//*********************************************************************************************************************
+
+#include "transform.h"
+
+#define TR_OFFSET        0x00020000
+
+#define TR_CTL          (0x000)
+#define TR_IRQ          (0x004)
+
+#define TR_IN_FMT       (0x020)
+#define TR_IN_SIZE      (0x024)
+
+#define TR_IN_PITCH0    (0x030)
+#define TR_IN_PITCH1    (0x034)
+#define TR_IN_PITCH2    (0x038)
+
+#define TR_IN_LADDR0    (0x040)
+#define TR_IN_LADDR1    (0x048)
+#define TR_IN_LADDR2    (0x050)
+
+#define TR_IN_HADDR0    (0x044)
+#define TR_IN_HADDR1    (0x04c)
+#define TR_IN_HADDR2    (0x054)
+
+#define TR_OUT_FMT      (0x080)
+#define TR_OUT_SIZE     (0x084)
+
+#define TR_OUT_PITCH0   (0x090)
+#define TR_OUT_PITCH1   (0x094)
+#define TR_OUT_PITCH2   (0x098)
+
+#define TR_OUT_LADDR0   (0x0a0)
+#define TR_OUT_LADDR1   (0x0a8)
+#define TR_OUT_LADDR2   (0x0b0)
+
+#define TR_OUT_HADDR0   (0x0a4)
+#define TR_OUT_HADDR1   (0x0ac)
+#define TR_OUT_HADDR2   (0x0b4)
+
+static uintptr_t tr_base;
+
+#define tr_writel(val, addr) writel(val, (void __iomem *)(addr))
+#define tr_readl(addr) readl((void __iomem *)(addr))
+
+int de_tr_set_base(uintptr_t reg_base)
+{
+	tr_base = reg_base + TR_OFFSET;
+
+	return 0;
+}
+
+int de_tr_irq_enable(void)
+{
+	tr_writel(1<<16, tr_base + TR_IRQ);
+
+	return 0;
+}
+
+int de_tr_irq_disable(void)
+{
+	tr_writel(0, tr_base + TR_IRQ);
+
+	return 0;
+}
+
+/* */
+int de_tr_irq_query(void)
+{
+	unsigned int irq_flag;
+	unsigned reg_val = 0;
+
+	reg_val = tr_readl(tr_base + TR_IRQ);
+	irq_flag = reg_val&0x1;
+	if(0x1 == irq_flag) {
+		tr_writel(reg_val, tr_base + TR_IRQ);
+		return 0;
+	}
+
+	return -1;
+}
+
+static int de_tr_clk_enable(void)
+{
+	uintptr_t base = tr_base - TR_OFFSET;
+	unsigned int reg_val = 0;
+	unsigned int offset = 3;//bit 3
+
+	/* clk div */
+	reg_val = tr_readl(base + 0xc);
+	reg_val &= ~(0xf << 12);
+	reg_val |= (0x0 << 12);
+	tr_writel(reg_val, base + 0xc);
+
+	/* reset */
+	reg_val = tr_readl(base + 0x8);
+	reg_val |= (1<<offset);
+	tr_writel(reg_val, base + 0x8);
+
+	/* bus */
+	reg_val = tr_readl(base + 0x4);
+	reg_val |= (1<<offset);
+	tr_writel(reg_val, base + 0x4);
+
+	/* module */
+	reg_val = tr_readl(base + 0x0);
+	reg_val |= (1<<offset);
+	tr_writel(reg_val, base + 0x0);
+
+	return 0;
+}
+
+static int de_tr_clk_disable(void)
+{
+	uintptr_t base = tr_base - TR_OFFSET;
+	unsigned int reg_val = 0;
+	unsigned int offset = 3;//bit 3
+
+	/* module */
+	reg_val = tr_readl(base + 0x0);
+	reg_val &= ~(1<<offset);
+	tr_writel(reg_val, base + 0x0);
+
+	/* bus */
+	reg_val = tr_readl(base + 0x4);
+	reg_val &= ~(1<<offset);
+	tr_writel(reg_val, base + 0x4);
+
+	/* reset */
+	reg_val = tr_readl(base + 0x8);
+	reg_val &= ~(1<<offset);
+	tr_writel(reg_val, base + 0x8);
+
+	return 0;
+}
+
+static int de_tr_set_enable(void)
+{
+	unsigned int tmp;
+
+	tmp = tr_readl(tr_base + TR_CTL);
+	tr_writel((1<<31)|tmp,tr_base + TR_CTL);
+
+	return 0;
+}
+
+static int de_tr_set_disable(void)
+{
+	//when rst need read de top register
+	tr_readl(tr_base - TR_OFFSET);
+	de_tr_irq_disable();
+
+	return 0;
+}
+
+int de_tr_init(void)
+{
+	return de_tr_clk_enable();
+}
+
+int de_tr_exit(void)
+{
+	de_tr_set_disable();
+	de_tr_clk_disable();
+	return 0;
+}
+
+int de_tr_reset(void)
+{
+	uintptr_t base = tr_base - TR_OFFSET;
+	unsigned int reg_val = 0;
+	unsigned int offset = 3;//bit 3
+
+	tr_readl(tr_base - TR_OFFSET);
+
+	reg_val = tr_readl(tr_base + TR_CTL);
+	reg_val |= 0x1;//enable bit
+	tr_writel(reg_val,tr_base + TR_CTL);
+
+	/* assert */
+	reg_val = tr_readl(base + 0x8);
+	reg_val &= ~(1<<offset);
+	tr_writel(reg_val, base + 0x8);
+
+	udelay(10);//wait for reset finish
+
+	/* de-assert */
+	reg_val = tr_readl(base + 0x8);
+	reg_val |= (1<<offset);
+	tr_writel(reg_val, base + 0x8);
+
+	return 0;
+}
+
+int de_tr_exception(void)
+{
+	mdelay(100);//wait to finish
+
+	return 0;
+}
+
+int de_tr_set_cfg(tr_info *info)
+{
+	int x0,x1,y0,y1;
+	unsigned char haddr[3],degree,hflip_en,vflip_en,burst;
+	unsigned int w,h,fmt,ycnt = 4,ucnt = 0,tmp,pitch[3];
+	long long addr[3];
+
+	de_tr_reset();
+
+	//global
+	burst = 0x7;
+	degree = hflip_en = vflip_en = 0x0;
+	if (info->mode<=TR_ROT_270)
+	{
+		degree = info->mode;
+	}
+	else if ((info->mode == TR_HFLIP) || (info->mode == TR_HFLIP_ROT_90))
+	{
+		hflip_en = 0x1;
+	}
+	else if ((info->mode == TR_VFLIP) || (info->mode == TR_VFLIP_ROT_90))
+	{
+		vflip_en = 0x1;
+	}
+
+	if ((info->mode == TR_HFLIP_ROT_90) || (info->mode == TR_VFLIP_ROT_90))
+	{
+		degree = 0x1;
+	}
+	if((info->mode == TR_ROT_0) || (info->mode == TR_ROT_180) || (info->mode == TR_HFLIP) || (info->mode == TR_VFLIP))
+	{
+		burst = 0x3f;
+	}
+	tmp = (burst<<16)|(hflip_en<<7)|(vflip_en<<6)|(degree<<4)|(1<<0);
+	tr_writel(tmp,tr_base + TR_CTL);
+
+	x0 = x1 = info->src_rect.x;
+	y0 = y1 = info->src_rect.y;
+	w  = info->src_rect.w;
+	h  = info->src_rect.h;
+
+	fmt = info->src_frame.fmt;
+	if       (fmt<=TR_FORMAT_BGRX_8888)     {ycnt = 4;}
+	else if	 (fmt<=TR_FORMAT_BGR_888)       {ycnt = 3;}
+	else if	 (fmt<=TR_FORMAT_BGRA_5551)     {ycnt = 2;}
+	else if	 (fmt<=TR_FORMAT_YUV422_I_VYUY) {ycnt = 2;ucnt=0;}
+	else if	 (fmt==TR_FORMAT_YUV422_P)      {ycnt = 1;ucnt=1; x1=x0/2;y1=y0;}  //YUV422
+	else if	 (fmt==TR_FORMAT_YUV420_P)      {ycnt = 1;ucnt=1; x1=x0/2;y1=y0/2;}//YUV420
+	else if	 (fmt==TR_FORMAT_YUV411_P)      {ycnt = 1;ucnt=1; x1=x0/4;y1=y0;}  //YUV411
+	else if	 (fmt<=TR_FORMAT_YUV422_SP_VUVU){ycnt = 1;ucnt=2; x1=x0/2;y1=y0;}
+	else if	 (fmt<=TR_FORMAT_YUV420_SP_VUVU){ycnt = 1;ucnt=2; x1=x0/2;y1=y0/2;}
+	else if	 (fmt<=TR_FORMAT_YUV411_SP_VUVU){ycnt = 1;ucnt=2; x1=x0/4;y1=y0;}
+	else                                    {ycnt = 4;}
+
+	pitch[0] = info->src_frame.pitch[0] * ycnt;
+	pitch[1] = info->src_frame.pitch[1] * ucnt;
+	pitch[2] = info->src_frame.pitch[2] * ucnt;
+
+	if((0 != x0) ||(0 != y0)){
+		pr_warn("In buffer coordinate is not original point[%d,%d].\n",	x0, y0);
+		return -1;
+	}
+
+	if((pitch[0]&0xf) ||(pitch[1]&0xf)||(pitch[2]&0xf)){
+		pr_warn("In buffer pitch is not 16 byte align[%x,%x,%x].\n",
+		pitch[0],pitch[1],pitch[2]);
+		return -1;
+	}
+
+	addr[0] = info->src_frame.laddr[0]+pitch[0]*y0+x0*ycnt;//Y/ARGB
+	addr[1] = info->src_frame.laddr[1]+pitch[1]*y1+x1*ucnt;//UV/U
+	addr[2] = info->src_frame.laddr[2]+pitch[2]*y1+x1*ucnt;//V
+	haddr[0] = ((addr[0]>>32)&0xff) + info->src_frame.haddr[0];
+	haddr[1] = ((addr[1]>>32)&0xff) + info->src_frame.haddr[1];
+	haddr[2] = ((addr[2]>>32)&0xff) + info->src_frame.haddr[2];
+
+	if(fmt >= TR_FORMAT_YUV444_I_AYUV) {
+		if((addr[0]&0xf) ||(addr[1]&0xf)||(addr[2]&0xf)){
+			pr_warn("Input address is not 16 byte align.\n");
+			return -1;
+		}
+	}
+
+	w = w==0?0:w-1;
+	h = h==0?0:h-1;
+	tr_writel((h<<16)|w,tr_base + TR_IN_SIZE);
+
+	tr_writel(pitch[0],tr_base + TR_IN_PITCH0);
+	tr_writel(pitch[1],tr_base + TR_IN_PITCH1);
+	tr_writel(pitch[2],tr_base + TR_IN_PITCH2);
+
+	tr_writel(addr[0]&0xffffffff,tr_base + TR_IN_LADDR0);
+	tr_writel(addr[1]&0xffffffff,tr_base + TR_IN_LADDR1);
+	tr_writel(addr[2]&0xffffffff,tr_base + TR_IN_LADDR2);
+
+	tr_writel(haddr[0],tr_base + TR_IN_HADDR0);
+	tr_writel(haddr[1],tr_base + TR_IN_HADDR1);
+	tr_writel(haddr[2],tr_base + TR_IN_HADDR2);
+
+	//dst
+	x0 = info->dst_rect.x;
+	y0 = info->dst_rect.y;
+	w  = info->dst_rect.w;
+	h  = info->dst_rect.h;
+
+	//for ycbcr format output only support yv12
+	if(fmt >= TR_FORMAT_YUV444_I_AYUV) {
+		ycnt = 1;ucnt=1; x1=x0/2;y1=y0/2;
+	}
+
+	pitch[0] = info->dst_frame.pitch[0] * ycnt;
+	pitch[1] = info->dst_frame.pitch[1] * ucnt;
+	pitch[2] = info->dst_frame.pitch[2] * ucnt;
+
+	if(fmt >= TR_FORMAT_YUV444_I_AYUV) {
+		if((pitch[0]&0xf) ||(pitch[1]&0xf)||(pitch[2]&0xf)){
+			pr_warn("Out buffer pitch is not 16 byte align[%x,%x,%x].\n",
+			pitch[0],pitch[1],pitch[2]);
+			return -1;
+		}
+	}
+
+	if((0 != x0) ||(0 != y0)){
+		pr_warn("Out buffer coordinate is not original point[%d,%d].\n", x0, y0);
+		return -1;
+	}
+
+	addr[0] = info->dst_frame.laddr[0]+pitch[0]*y0+x0*ycnt;//Y/ARGB
+	addr[1] = info->dst_frame.laddr[1]+pitch[1]*y1+x1*ucnt;//UV/U
+	addr[2] = info->dst_frame.laddr[2]+pitch[2]*y1+x1*ucnt;//V
+	haddr[0] = ((addr[0]>>32)&0xff) + info->dst_frame.haddr[0];
+	haddr[1] = ((addr[1]>>32)&0xff) + info->dst_frame.haddr[1];
+	haddr[2] = ((addr[2]>>32)&0xff) + info->dst_frame.haddr[2];
+
+	if(fmt >= TR_FORMAT_YUV444_I_AYUV) {
+		if((addr[0]&0x1f) ||(addr[1]&0x1f)||(addr[2]&0x1f)){
+			pr_warn("Output address is not 32 byte align.\n");
+			return -1;
+		}
+	}
+
+	w = w==0?0:w-1;
+	h = h==0?0:h-1;
+	tr_writel((h<<16)|w,tr_base + TR_OUT_SIZE);
+
+	tr_writel(pitch[0],tr_base + TR_OUT_PITCH0);
+	tr_writel(pitch[1],tr_base + TR_OUT_PITCH1);
+	tr_writel(pitch[2],tr_base + TR_OUT_PITCH2);
+
+	tr_writel(addr[0]&0xffffffff,tr_base + TR_OUT_LADDR0);
+	tr_writel(addr[1]&0xffffffff,tr_base + TR_OUT_LADDR1);
+	tr_writel(addr[2]&0xffffffff,tr_base + TR_OUT_LADDR2);
+
+	tr_writel(haddr[0],tr_base + TR_OUT_HADDR0);
+	tr_writel(haddr[1],tr_base + TR_OUT_HADDR1);
+	tr_writel(haddr[2],tr_base + TR_OUT_HADDR2);
+
+	//src
+	if		(TR_FORMAT_YUV422_I_VYUY  == info->src_frame.fmt){fmt = 0x20;}
+	else if (TR_FORMAT_YUV422_I_YVYU  == info->src_frame.fmt){fmt = 0x21;}
+	else if (TR_FORMAT_YUV422_I_UYVY  == info->src_frame.fmt){fmt = 0x22;}
+	else if (TR_FORMAT_YUV422_I_YUYV  == info->src_frame.fmt){fmt = 0x23;}
+	else if (TR_FORMAT_YUV422_SP_UVUV == info->src_frame.fmt){fmt = 0x24;}
+	else if (TR_FORMAT_YUV422_SP_VUVU == info->src_frame.fmt){fmt = 0x25;}
+	else if (TR_FORMAT_YUV422_P       == info->src_frame.fmt){fmt = 0x26;}
+	else if (TR_FORMAT_YUV420_SP_UVUV == info->src_frame.fmt){fmt = 0x28;}
+	else if (TR_FORMAT_YUV420_SP_VUVU == info->src_frame.fmt){fmt = 0x29;}
+	else if (TR_FORMAT_YUV420_P       == info->src_frame.fmt){fmt = 0x2a;}
+	else if (TR_FORMAT_YUV411_SP_UVUV == info->src_frame.fmt){fmt = 0x2c;}
+	else if (TR_FORMAT_YUV411_SP_VUVU == info->src_frame.fmt){fmt = 0x2d;}
+	else if (TR_FORMAT_YUV411_P       == info->src_frame.fmt){fmt = 0x2e;}
+	else {fmt = info->src_frame.fmt;}
+//	else {fmt = 0x0;}
+	tr_writel(fmt,tr_base + TR_IN_FMT);
+
+	de_tr_irq_enable();
+	de_tr_set_enable();
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/sunxi/subdev/sunxi_common.c b/drivers/gpu/drm/sunxi/subdev/sunxi_common.c
new file mode 100755
index 0000000..43a2feb
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/subdev/sunxi_common.c
@@ -0,0 +1,403 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#include <drm/drmP.h>
+#include "asm/cacheflush.h"
+
+#include <linux/clk-private.h>
+#include <linux/clk/sunxi.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/pinctrl/pinconf-sunxi.h>
+#include <linux/sys_config.h>
+#include <linux/pwm.h>
+
+#include "../sunxi_drm_core.h"
+#include "sunxi_drm_panel.h"
+#include "sunxi_common.h"
+
+static char drm_irq[][10] = {
+	/*DISP_MOD_DE*/{"drm-de"},
+	/*DISP_MOD_DEVICE*/{"drm-tcon"},
+	/*DISP_MOD_LCD0*/{"drm-tcon0"},
+	/*DISP_MOD_LCD1*/{"drm-tcon1"},
+	/*DISP_MOD_LCD2*/{"drm-tcon2"},
+	/*DISP_MOD_LCD3*/"drm-tcon3",
+	/*DISP_MOD_DSI0*/"drm-dsi0",
+	/*DISP_MOD_DSI1*/"drm-dsi1",
+	/*DISP_MOD_DSI2*/"drm-dsi3",
+	/*DISP_MOD_HDMI*/"drm-hdmi",
+	/*DISP_MOD_LVDS*/"drm-lvds",
+	/*DISP_MOD_EINK*/"drm-elink",
+	/*DISP_MOD_EDMA*/"drm-edma",
+};
+
+int sunxi_clk_set(struct sunxi_hardware_res *hw_res)
+{
+	unsigned long clk_set;
+	if(hw_res && hw_res->parent_clk) {
+		clk_set_rate(hw_res->parent_clk, hw_res->parent_clk_rate);
+		clk_set = clk_get_rate(hw_res->parent_clk);
+		if (clk_set != hw_res->parent_clk_rate) {
+			DRM_INFO("set parent clk:%lu, but get:%lu.\n",hw_res->parent_clk_rate, clk_set); 
+			}
+	}
+	if (hw_res && hw_res->clk) {
+		clk_set_rate(hw_res->clk, hw_res->clk_rate);
+		clk_set = clk_get_rate(hw_res->clk);
+		if (clk_set != hw_res->clk_rate){
+			DRM_INFO("set clk:%lu, but get:%lu.\n",hw_res->clk_rate, clk_set);
+		}
+	}
+
+	return 0;
+}
+
+void sunxi_clk_enable(struct sunxi_hardware_res *hw_res)
+{
+	if (hw_res && !hw_res->clk_enable && hw_res->clk) {
+		clk_prepare_enable(hw_res->clk);
+		hw_res->clk_enable = 1;
+	}
+}
+
+void sunxi_clk_disable(struct sunxi_hardware_res *hw_res)
+{
+	if (hw_res && hw_res->clk_enable && hw_res->clk) {
+		clk_disable_unprepare(hw_res->clk);
+		hw_res->clk_enable = 0;
+	}
+}
+
+void sunxi_irq_enable(struct sunxi_hardware_res *hw_res)
+{
+	if (hw_res && hw_res->irq_uesd && !hw_res->irq_enable) {
+		enable_irq(hw_res->irq_no);
+		hw_res->irq_enable = 1;
+	}
+}
+
+void sunxi_irq_disable(struct sunxi_hardware_res *hw_res)
+{
+	if (hw_res && hw_res->irq_enable) {
+		disable_irq(hw_res->irq_no);
+		hw_res->irq_enable = 0;
+	}
+}
+
+int sunxi_irq_request(struct sunxi_hardware_res  *hw_res)
+{
+	unsigned int irq_no;
+	void *irq_arg;
+	irq_handler_t irq_handle;
+
+	irq_no = hw_res->irq_no;
+	irq_arg = hw_res->irq_arg;
+	irq_handle = hw_res->irq_handle;
+	if (hw_res && !hw_res->irq_uesd) {
+		request_irq(irq_no, (irq_handler_t)irq_handle,
+			IRQF_DISABLED, drm_irq[hw_res->res_id], irq_arg);
+		/* make sure that after request,the irq enbaled ? */
+		hw_res->irq_enable = 1;
+		hw_res->irq_uesd = 1;
+	}
+
+	return 0;
+}
+
+bool sunxi_irq_query(struct sunxi_hardware_res *hw_res,
+        void *irq_data, int need_irq)
+{
+	bool status = true;
+	if (hw_res && hw_res->ops && hw_res->ops->irq_query)
+		status = hw_res->ops->irq_query(irq_data,need_irq);
+	return status;
+}
+
+int sunxi_irq_free(struct sunxi_hardware_res *hw_res)
+{
+    
+	if (hw_res && hw_res->irq_uesd) {
+		free_irq(hw_res->irq_no, hw_res->irq_arg);
+		hw_res->irq_enable = 0;
+		hw_res->irq_uesd = 0;
+	}
+
+	return 0;
+}
+
+void sunxi_drm_delayed_ms(unsigned int ms)
+{
+	unsigned int timeout = msecs_to_jiffies(ms);
+
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(timeout);
+}
+
+int sunxi_drm_sys_power_enable(char *name)
+{
+	int ret = 0;
+#ifdef CONFIG_AW_AXP
+	struct regulator *regu= NULL;
+	regu= regulator_get(NULL, name);
+	if (IS_ERR(regu)) {
+		DRM_ERROR("fail to get regulator %s\n", name);
+		goto exit;
+	}
+
+	ret = regulator_enable(regu);
+	if (0 != ret) {
+		DRM_ERROR("fail to enable regulator %s!\n", name);
+		goto exit1;
+	} else {
+		DRM_INFO("suceess to enable regulator %s!\n", name);
+	}
+
+exit1:
+	regulator_put(regu);
+exit:
+#endif
+	return ret;
+}
+
+int sunxi_drm_sys_power_disable(char *name)
+{
+	int ret = 0;
+#ifdef CONFIG_AW_AXP
+	struct regulator *regu= NULL;
+
+	regu= regulator_get(NULL, name);
+	if (IS_ERR(regu)) {
+		DRM_ERROR("fail to get regulator %s\n", name);
+		goto exit;
+	}
+
+	ret = regulator_disable(regu);
+	if (0 != ret) {
+		DRM_ERROR("fail to disable regulator %s!\n", name);
+		goto exit1;
+	} else {
+		DRM_INFO("suceess to disable regulator %s!\n", name);
+	}
+
+exit1:
+	regulator_put(regu);
+exit:
+#endif
+	return ret;
+}
+
+int sunxi_drm_sys_gpio_request(disp_gpio_set_t *gpio_list)
+{
+	int ret = 0;
+	struct gpio_config pin_cfg;
+	char   pin_name[32];
+	u32 config;
+
+	if (gpio_list == NULL)
+		return 0;
+
+	pin_cfg.gpio = gpio_list->gpio;
+	pin_cfg.mul_sel = gpio_list->mul_sel;
+	pin_cfg.pull = gpio_list->pull;
+	pin_cfg.drv_level = gpio_list->drv_level;
+	pin_cfg.data = gpio_list->data;
+	ret = gpio_request(pin_cfg.gpio, NULL);
+	if (0 != ret) {
+		DRM_ERROR("failed, gpio_name=%s, gpio=%d, ret=%d\n",
+		gpio_list->gpio_name, gpio_list->gpio, ret);
+		return 0;
+	} else {
+		DRM_INFO("%s, gpio_name=%s, gpio=%d, <%d,%d,%d,%d>ret=%d\n", __func__,
+		gpio_list->gpio_name, gpio_list->gpio,
+		gpio_list->mul_sel, gpio_list->pull, gpio_list->drv_level, gpio_list->data, ret);
+	}
+	ret = pin_cfg.gpio;
+
+	if (!IS_AXP_PIN(pin_cfg.gpio)) {
+		/* valid pin of sunxi-pinctrl,
+		* config pin attributes individually.
+		*/
+		sunxi_gpio_to_name(pin_cfg.gpio, pin_name);
+		config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_FUNC, pin_cfg.mul_sel);
+		pin_config_set(SUNXI_PINCTRL, pin_name, config);
+		if (pin_cfg.pull != GPIO_PULL_DEFAULT) {
+			config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_PUD, pin_cfg.pull);
+			pin_config_set(SUNXI_PINCTRL, pin_name, config);
+		}
+		if (pin_cfg.drv_level != GPIO_DRVLVL_DEFAULT) {
+			config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_DRV, pin_cfg.drv_level);
+			pin_config_set(SUNXI_PINCTRL, pin_name, config);
+		}
+		if (pin_cfg.data != GPIO_DATA_DEFAULT) {
+			config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_DAT, pin_cfg.data);
+			pin_config_set(SUNXI_PINCTRL, pin_name, config);
+		}
+	} else if (IS_AXP_PIN(pin_cfg.gpio)) {
+		/* valid pin of axp-pinctrl,
+		* config pin attributes individually.
+		*/
+		sunxi_gpio_to_name(pin_cfg.gpio, pin_name);
+		if (pin_cfg.data != GPIO_DATA_DEFAULT) {
+			config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_DAT, pin_cfg.data);
+			pin_config_set(AXP_PINCTRL, pin_name, config);
+		}
+	} else {
+		DRM_ERROR("invalid pin [%d] from sys-config\n", pin_cfg.gpio);
+	}
+
+	return ret;
+}
+
+int sunxi_drm_sys_gpio_release(int p_handler)
+{
+	if (p_handler) {
+		gpio_free(p_handler);
+	} else {
+		DRM_INFO("OSAL_GPIO_Release, hdl is NULL\n");
+	}
+	return 0;
+}
+
+int sunxi_drm_sys_pin_set_state(char *dev_name, char *name)
+{
+	char compat[32];
+	u32 len = 0;
+	struct device_node *node;
+	struct platform_device *pdev;
+	struct pinctrl *pctl;
+	struct pinctrl_state *state;
+	int ret = -1;
+
+	len = sprintf(compat, "allwinner,sunxi-%s", dev_name);
+	if (len > 32)
+		DRM_ERROR("size of mian_name is out of range\n");
+
+	node = of_find_compatible_node(NULL, NULL, compat);
+	if (!node) {
+		DRM_ERROR("of_find_compatible_node %s fail\n", compat);
+		goto exit;
+	}
+
+	pdev = of_find_device_by_node(node);
+	if (!node) {
+		DRM_ERROR("of_find_device_by_node for %s fail\n", compat);
+		goto exit;
+	}
+
+	pctl = pinctrl_get(&pdev->dev);
+	if (IS_ERR(pctl)) {
+		DRM_ERROR("pinctrl_get for %s fail\n", compat);
+		ret = PTR_ERR(pctl);
+		goto exit;
+	}
+
+	state = pinctrl_lookup_state(pctl, name);
+	if (IS_ERR(state)) {
+		DRM_ERROR("pinctrl_lookup_state for %s fail\n", compat);
+		ret = PTR_ERR(state);
+		goto exit;
+	}
+
+	ret = pinctrl_select_state(pctl, state);
+	if (ret < 0) {
+		DRM_ERROR("pinctrl_select_state(%s) for %s fail\n", name, compat);
+		goto exit;
+	}
+	ret = 0;
+
+exit:
+	return ret;
+}
+
+int sunxi_drm_get_sys_item_int(struct device_node *node, char *sub_name, int *value)
+{
+
+	return of_property_read_u32_array(node, sub_name, value, 1);
+}
+
+int sunxi_drm_get_sys_item_char(struct device_node *node, char *sub_name, char *value)
+{
+	const char *str;
+	if (of_property_read_string(node, sub_name, &str)) {
+		DRM_INFO("failed to get [%s] string.\n", sub_name); 
+		return  -EINVAL;
+	}
+
+	memcpy((void*)value, str, strlen(str)+1);
+
+	return 0;
+}
+
+int sunxi_drm_get_sys_item_gpio(struct device_node *node, char *sub_name, disp_gpio_set_t *gpio_info)
+{
+	int gpio;
+	struct gpio_config config;
+
+	gpio = of_get_named_gpio_flags(node, sub_name, 0, (enum of_gpio_flags *)&config);
+	if (!gpio_is_valid(gpio)) {
+		DRM_INFO("failed to get gpio[%s].\n",sub_name); 
+		return -EINVAL;
+	}
+
+	gpio_info->gpio = config.gpio;
+	gpio_info->mul_sel = config.mul_sel;
+	gpio_info->pull = config.pull;
+	gpio_info->drv_level = config.drv_level;
+	gpio_info->data = config.data;
+	memcpy(gpio_info->gpio_name, sub_name, strlen(sub_name)+1);
+
+	return 0;
+}
+
+struct device_node *sunxi_drm_get_name_node(char *device_name)
+{
+	struct device_node *node = NULL;
+	char compat[32];
+	u32 len = 0;
+
+	len = sprintf(compat, "allwinner,%s", device_name);
+	if (len > 32)
+		DRM_INFO("size of mian_name is out of range\n");
+
+	node = of_find_compatible_node(NULL, NULL, compat);
+	if (!node) {
+		DRM_ERROR("of_find_compatible_node %s fail\n", compat);
+		return NULL;
+	}
+
+	return node;
+}
+
+int sunxi_drm_sys_pwm_enable(struct pwm_info_t *pwm_info)
+{
+	if (pwm_info->pwm_dev && !pwm_info->enabled) {
+		pwm_info->enabled = 1;
+		return pwm_enable(pwm_info->pwm_dev);
+	}
+	return 0;
+}
+
+int sunxi_drm_sys_pwm_disable(struct pwm_info_t *pwm_info)
+{
+	if (pwm_info->pwm_dev && pwm_info->enabled) {
+		pwm_info->enabled = 0;
+		pwm_disable(pwm_info->pwm_dev);
+	}
+	return 0;
+}
+
+int sunxi_drm_sys_pwm_config(struct pwm_device *pwm_dev, int duty_ns, int period_ns)
+{
+	if (NULL == pwm_dev || IS_ERR(pwm_dev)) {
+		DRM_ERROR("set pwm err.\n");
+		return -EINVAL;
+	}
+	return pwm_config(pwm_dev, duty_ns, period_ns);
+}
diff --git a/drivers/gpu/drm/sunxi/subdev/sunxi_common.h b/drivers/gpu/drm/sunxi/subdev/sunxi_common.h
new file mode 100755
index 0000000..de514ac
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/subdev/sunxi_common.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifndef _SUNXI_COMMON_H_
+#define _SUNXI_COMMON_H_
+
+int sunxi_clk_set(struct sunxi_hardware_res *hw_res);
+
+void sunxi_clk_enable(struct sunxi_hardware_res *hw_res);
+
+void sunxi_clk_disable(struct sunxi_hardware_res *hw_res);
+
+void sunxi_irq_enable(struct sunxi_hardware_res *hw_res);
+
+void sunxi_irq_disable(struct sunxi_hardware_res *hw_res);
+
+int sunxi_irq_free(struct sunxi_hardware_res  *hw_res);
+
+int sunxi_irq_request(struct sunxi_hardware_res  *hw_res);
+
+struct device_node *sunxi_drm_get_name_node(char *device_name);
+
+int sunxi_drm_get_sys_item_gpio(struct device_node *node, char *sub_name, disp_gpio_set_t *gpio_info);
+
+int sunxi_drm_get_sys_item_char(struct device_node *node, char *sub_name, char *value);
+
+int sunxi_drm_get_sys_item_int(struct device_node *node, char *sub_name, int *value);
+
+int sunxi_drm_sys_pin_set_state(char *dev_name, char *name);
+
+int sunxi_drm_sys_gpio_release(int p_handler);
+
+int sunxi_drm_sys_gpio_request(disp_gpio_set_t *gpio_list);
+
+int sunxi_drm_sys_power_disable(char *name);
+
+int sunxi_drm_sys_power_enable(char *name);
+
+void sunxi_drm_delayed_ms(unsigned int ms);
+
+int sunxi_drm_sys_pwm_enable(struct pwm_info_t *pwm_info);
+
+int sunxi_drm_sys_pwm_disable(struct pwm_info_t *pwm_info);
+
+int sunxi_drm_sys_pwm_config(struct pwm_device *pwm_dev, int duty_ns, int period_ns);
+
+bool sunxi_irq_query(struct sunxi_hardware_res *hw_res, void *irq_data, int need_irq);
+
+#endif
diff --git a/drivers/gpu/drm/sunxi/subdev/sunxi_g2d.c b/drivers/gpu/drm/sunxi/subdev/sunxi_g2d.c
new file mode 100755
index 0000000..d3f5a12
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/subdev/sunxi_g2d.c
@@ -0,0 +1 @@
+
diff --git a/drivers/gpu/drm/sunxi/subdev/sunxi_hdmi.c b/drivers/gpu/drm/sunxi/subdev/sunxi_hdmi.c
new file mode 100755
index 0000000..a023d2a
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/subdev/sunxi_hdmi.c
@@ -0,0 +1,813 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+/*HDMI panel ops*/
+#include <drm/drmP.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_edid.h>
+#include "../sunxi_drm_drv.h"
+#include "../sunxi_drm_core.h"
+#include "../sunxi_drm_crtc.h"
+#include "../sunxi_drm_encoder.h"
+#include "../sunxi_drm_connector.h"
+#include "../sunxi_drm_plane.h"
+#include "../drm_de/drm_al.h"
+#include "../subdev/sunxi_common.h"
+#include "../sunxi_drm_panel.h"
+#include "sunxi_hdmi.h"
+#include "hdmi_bsp.h"
+#include "de/include.h"
+#include <linux/clk-private.h>
+#if defined(CONFIG_ARCH_SUN50IW2P1)
+#define HDMI_USING_INNER_BIAS 1
+#endif
+
+/* vendor specific mode */
+static const struct drm_display_mode edid_vsp_modes[] = {
+	/* 0 */
+	{ DRM_MODE("1920x1080@3D", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2558,
+		2602, 2750, 0, 1080, 1084, 1089, 2160, 0,
+		DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+		.vrefresh = 24, },
+	/* 1 */
+	{ DRM_MODE("1280x720@3D", DRM_MODE_TYPE_DRIVER, 148500, 1280, 1720,
+		1760, 1980, 0, 1440, 1445, 1450, 1500, 0,
+		DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+		.vrefresh = 50, },
+	/* 2 */
+	{ DRM_MODE("1280x720@3D", DRM_MODE_TYPE_DRIVER, 148500, 1280, 1390,
+		1430, 1650, 0, 1440, 1445, 1450, 1500, 0,
+		DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+		.vrefresh = 60, },
+	/* 3 */
+	{ DRM_MODE("3840x2160@30", DRM_MODE_TYPE_DRIVER, 297000, 3840, 4010,
+		4098, 4400, 0, 2160, 2168, 2178, 2250, 0,
+		DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+		.vrefresh = 30, },
+	/* 4 */
+	{ DRM_MODE("3840x2160@25", DRM_MODE_TYPE_DRIVER, 297000, 3840, 4896,
+		4984, 5280, 0, 2160, 2168, 2178, 2250, 0,
+		DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+		.vrefresh = 25, },
+};
+
+static const struct disp_video_timings video_timing[] =
+{
+       //VIC	     tv_mode  PCLK    AVI_PR  X      Y     HT     HBP  HFP   HST   VT    VBP VFP VST h_pol v_pol int  vac  trd
+/* 0 */{HDMI1440_480I,      0,13500000,  1,  720,   480,   858,   57,   19,   62,  525,   15,  4,  3,  0,   0,    1,   0,   0},
+/* 1 */{HDMI1440_576I,      0,13500000,  1,  720,   576,   864,   69,   12,   63,  625,   19,  2,  3,  0,   0,    1,   0,   0},
+/* 2 */{HDMI480P,           0,27000000,  0,  720,   480,   858,   60,   16,   62,  525,   30,  9,  6,  0,   0,    0,   0,   0},
+/* 3 */{HDMI576P,           0,27000000,  0,  720,   576,   864,   68,   12,   64,  625,   39,  5,  5,  0,   0,    0,   0,   0},
+/* 4 */{HDMI720P_50,        0,74250000,  0,  1280,  720,   1980,  220,  440,  40,  750,   20,  5,  5,  1,   1,    0,   0,   0},
+/* 5 */{HDMI720P_60,        0,74250000,  0,  1280,  720,   1650,  220,  110,  40,  750,   20,  5,  5,  1,   1,    0,   0,   0},
+/* 6 */{HDMI1080I_50,       0,74250000,  0,  1920,  1080,  2640,  148,  528,  44,  1125,  15,  2,  5,  1,   1,    1,   0,   0},
+/* 7 */{HDMI1080I_60,       0,74250000,  0,  1920,  1080,  2200,  148,  88,   44,  1125,  15,  2,  5,  1,   1,    1,   0,   0},
+/* 8 */{HDMI1080P_50,       0,148500000, 0,  1920,  1080,  2640,  148,  528,  44,  1125,  36,  4,  5,  1,   1,    0,   0,   0},
+/* 9 */{HDMI1080P_60,       0,148500000, 0,  1920,  1080,  2200,  148,  88,   44,  1125,  36,  4,  5,  1,   1,    0,   0,   0},
+/* 10*/{HDMI1080P_24,       0,74250000,  0,  1920,  1080,  2750,  148,  638,  44,  1125,  36,  4,  5,  1,   1,    0,   0,   0},
+/* 11*/{HDMI1080P_25,       0,74250000,  0,  1920,  1080,  2640,  148,  528,  44,  1125,  36,  4,  5,  0,   0,    0,   0,   0},
+/* 12*/{HDMI1080P_30,       0,74250000,  0,  1920,  1080,  2200,  148,  88,   44,  1125,  36,  4,  5,  0,   0,    0,   0,   0},
+/* 13*/{HDMI1080P_24_3D_FP, 0,148500000, 0,  1920,  2160,  2750,  148,  638,  44,  1125,  36,  4,  5,  1,   1,    0,   45,  1},
+/* 14*/{HDMI720P_50_3D_FP,  0,148500000, 0,  1280,  1440,  1980,  220,  440,  40,  750,   20,  5,  5,  1,   1,    0,   30,  1},
+/* 15*/{HDMI720P_60_3D_FP,  0,148500000, 0,  1280,  1440,  1650,  220,  110,  40,  750,   20,  5,  5,  1,   1,    0,   30,  1},
+/* 16*/{HDMI3840_2160P_30,  0,297000000, 0,  3840,  2160,  4400,  296,  176,  88,  2250,  72,  8, 10,  1,   1,    0,    0,  0},
+/* 17*/{HDMI3840_2160P_25,  0,297000000, 0,  3840,  2160,  5280,  296, 1056,  88,  2250,  72,  8, 10,  1,   1,    0,    0,  0},
+};
+
+void hdmi_delay_us(unsigned long us)
+{
+	udelay(us);
+}
+
+void hdmi_delay_ms(unsigned long ms)
+{
+	sunxi_drm_delayed_ms(ms);
+}
+
+enum drm_mode_status sunxi_hdmi_check_mode(struct sunxi_panel *sunxi_panel,
+	struct drm_display_mode *mode)
+{
+	struct disp_video_timings hdmi_timing;
+	return sunxi_hdmi_mode_timmings(&hdmi_timing, mode);
+}
+
+bool default_hdmi_init(struct sunxi_panel *sunxi_panel)
+{
+	struct sunxi_hdmi_private *sunxi_hdmi_p;
+	struct video_para *glb_video_para;
+	struct audio_para * glb_audio_para;
+	struct disp_video_timings *hdmi_timing;
+	sunxi_hdmi_p = (struct sunxi_hdmi_private *)sunxi_panel->private;
+	glb_video_para = &sunxi_hdmi_p->video_para;
+	glb_audio_para = &sunxi_hdmi_p->audio_para;
+	hdmi_timing = sunxi_hdmi_p->timing;
+
+	memcpy(hdmi_timing, &video_timing[4], sizeof(struct disp_video_timings));
+
+	glb_video_para->vic = HDMI720P_50;
+	glb_video_para->csc = BT601;
+	glb_video_para->is_hdmi = 1;
+	glb_video_para->is_yuv = 0;
+	glb_video_para->is_hcts = 0;
+	glb_audio_para->type = 1;
+	glb_audio_para->sample_rate = 44100;
+	glb_audio_para->sample_bit = 16;
+	glb_audio_para->ch_num = 2;
+	glb_audio_para->ca = 0;
+	glb_audio_para->vic = HDMI720P_50;
+	return true;
+}
+
+static int hdmi_io_request(struct sunxi_hdmi_private *sunxi_hdmi_p)
+{
+	int i;
+
+	for (i = 0; i < HDMI_IO_NUM; i++) {
+		if (sunxi_hdmi_p->hdmi_io_used[i]) {
+			disp_gpio_set_t  gpio_info[1];
+			memcpy(gpio_info, &(sunxi_hdmi_p->hdmi_io[i]), sizeof(disp_gpio_set_t));
+			sunxi_hdmi_p->gpio_handle[i] = sunxi_drm_sys_gpio_request(gpio_info);
+		}
+	}
+
+	return 0;
+}
+
+static int hdmi_io_release(struct sunxi_hdmi_private *sunxi_hdmi_p)
+{
+	int i;
+
+	for (i = 0; i < HDMI_IO_NUM; i++) {
+		if (sunxi_hdmi_p->hdmi_io_used[i] && sunxi_hdmi_p->gpio_handle[i] != 0) {
+			disp_gpio_set_t  gpio_info[1];
+			memcpy(gpio_info, &(sunxi_hdmi_p->hdmi_io[i]), sizeof(disp_gpio_set_t));
+			sunxi_hdmi_p->gpio_handle[i] = sunxi_drm_sys_gpio_request(gpio_info);
+			gpio_info->mul_sel = 7;
+			sunxi_drm_sys_gpio_release(sunxi_hdmi_p->gpio_handle[i]);
+			sunxi_hdmi_p->gpio_handle[i] = 0;
+		}
+	}
+	return 0;
+}
+
+bool default_hdmi_open(struct sunxi_panel *sunxi_panel)
+{
+	struct sunxi_hdmi_private *sunxi_hdmi_p;
+	sunxi_hdmi_p = (struct sunxi_hdmi_private *)sunxi_panel->private;
+	hdmi_io_request(sunxi_hdmi_p);
+
+	bsp_hdmi_video(&sunxi_hdmi_p->video_para);
+	bsp_hdmi_audio(&sunxi_hdmi_p->audio_para);
+	bsp_hdmi_set_video_en(1);
+	return true;
+}
+
+bool default_hdmi_close(struct sunxi_panel *sunxi_panel)
+{
+	struct sunxi_hdmi_private *sunxi_hdmi_p;
+	sunxi_hdmi_p = (struct sunxi_hdmi_private *)sunxi_panel->private;
+	bsp_hdmi_set_video_en(0);
+	hdmi_io_release(sunxi_hdmi_p);
+	return true;
+}
+
+enum drm_mode_status sunxi_hdmi_mode_timmings(void *timing, struct drm_display_mode *mode)
+{
+	struct disp_video_timings *hdmi_timing = (struct disp_video_timings *)timing;
+	const struct disp_video_timings *fix_timing = NULL;
+	int vrefresh;
+	if (!hdmi_timing || !mode)
+		return MODE_BAD;
+	vrefresh = mode->vrefresh;
+	if (mode->vrefresh == 0) {
+		vrefresh = drm_mode_vrefresh(mode);
+		DRM_DEBUG_KMS("vrefresh:%d id:%d (%d x %d) flag:%x\n",
+		vrefresh,mode->base.id,mode->hdisplay,mode->vdisplay,mode->flags);
+	}
+
+	if (vrefresh == 60 || vrefresh == 59 || vrefresh == 61) {
+		if(mode->flags & DRM_MODE_FLAG_INTERLACE) {
+			if (mode->hdisplay == 1920 && mode->vdisplay == 1080) {
+				/* HDMI1080I_60 */
+				fix_timing = &video_timing[7];
+			}
+			if (mode->hdisplay == 720 && mode->vdisplay == 480) {
+				/* HDMI1440_480I */
+				fix_timing = &video_timing[0];
+			}
+		}else{
+			if (mode->vdisplay == 1080 && mode->hdisplay == 1920) {
+				/* HDMI1080P_60 */
+				fix_timing = &video_timing[9];
+			}
+			if (mode->vdisplay == 720 && mode->hdisplay == 1280) {
+				/* HDMI720P_60 */
+				fix_timing = &video_timing[5];
+			}
+			if (mode->vdisplay == 480 && mode->hdisplay == 720) {
+				/* HDMI480P */
+				fix_timing = &video_timing[2];
+			}
+			if (mode->vdisplay == 576 && mode->hdisplay == 720) {
+				/* HDMI576P */
+				fix_timing = &video_timing[3];
+			}
+			if (mode->vdisplay == 1440 && mode->hdisplay == 1280) {
+				/* HDMI720P_60_3D_FP */
+				fix_timing = &video_timing[15];
+			}
+		}
+	}else if (vrefresh == 50 || vrefresh == 49 || vrefresh == 51) {
+		if(mode->flags & DRM_MODE_FLAG_INTERLACE) {
+			if (mode->hdisplay == 1920 && mode->vdisplay == 1080) {
+				fix_timing = &video_timing[6];
+				/* HDMI1080I_50 */
+			}
+			if (mode->hdisplay == 720 && mode->vdisplay == 576) {
+				/* HDMI1440_576I */
+				fix_timing = &video_timing[1];
+			}
+		}else{
+			if (mode->vdisplay == 1080 && mode->hdisplay == 1920) {
+				/* HDMI1080P_50 */
+				fix_timing = &video_timing[8];
+			}
+			if (mode->vdisplay == 720 && mode->hdisplay == 1280) {
+				/* HDMI720P_50 */
+				fix_timing = &video_timing[4];
+			}
+			if (mode->vdisplay == 1440 && mode->hdisplay == 1280) {
+				/* HDMI720P_50_3D_FP */
+				fix_timing = &video_timing[14];
+			}
+		}
+	}else if (vrefresh == 30 || vrefresh == 29 || vrefresh == 31) {
+		if (mode->vdisplay == 1080 && mode->hdisplay == 1920) {
+			/* HDMI1080P_30 */
+			fix_timing = &video_timing[12];
+		}
+		if (mode->vdisplay == 2160 && mode->hdisplay == 3840) {
+			/* HDMI3840_2160P_30 */
+			fix_timing = &video_timing[16];
+		}
+	}else if (vrefresh == 23 || vrefresh == 24 ||
+		vrefresh == 25 || vrefresh == 26) {
+		if (mode->vdisplay == 2160 && mode->hdisplay == 1920) {
+			/* HDMI1080P_24_3D_FP */
+			fix_timing = &video_timing[13];
+		}
+		if (mode->vdisplay == 1080 && mode->hdisplay == 1920 &&
+			mode->htotal == 2640) {
+			/* HDMI1080P_25 */
+			fix_timing = &video_timing[11];
+		}
+		if (mode->vdisplay == 1080 && mode->hdisplay == 1920 &&
+			mode->htotal == 2750) {
+			/* HDMI1080P_24 */
+			fix_timing = &video_timing[10];
+		}
+		if (mode->vdisplay == 2160 && mode->hdisplay == 3840) {
+			/* HDMI3840_2160P_25 */
+			fix_timing = &video_timing[17];
+		}
+	}
+
+	if (fix_timing == NULL)
+		return MODE_ERROR;
+
+	memcpy(hdmi_timing, fix_timing, sizeof(struct disp_video_timings));
+	DRM_DEBUG_KMS("[%d] vrefresh:%d id:%d(%d x %d) flag:%x vic:%d  %d\n",__LINE__,
+		vrefresh,mode->base.id, mode->hdisplay,mode->vdisplay,
+		mode->flags, fix_timing->vic, hdmi_timing->vic);
+
+	return MODE_OK;
+}
+
+static void edid_read_data(u8 block, struct edid *buf)
+{
+	int ret;
+	u8 *pbuf = ((u8 *)(buf)) + 128*block;
+	u8 offset = (block&0x01)? 128:0;
+	ret = bsp_hdmi_ddc_read(Explicit_Offset_Address_E_DDC_Read, block>>1, offset, 128, pbuf);
+
+}
+/* drm does not add the vendor specific mode, so we add it */
+int sunxi_vendor_specific_mode(struct drm_connector *connector,
+            unsigned char *edid, int size)
+{
+	struct drm_display_mode *newmode;
+
+	u8 index = 8;
+	u8 vic_len = 0;
+	u8 i;
+	int cout = 0;
+
+	/* check if it's HDMI VSDB */
+	if (!((edid[0] ==0x03) &&	(edid[1] ==0x0c) &&	(edid[2] ==0x00))) {
+		return 0;
+	}
+
+	if (size <= 8)
+		return 0;
+
+
+	if ((edid[7]&0x20) == 0 )
+		return 0;
+	if ((edid[7]&0x40) == 0x40 )
+		index = index +2;
+	if ((edid[7]&0x80) == 0x80 )
+		index = index +2;
+
+	/* mandatary format support */
+	if (edid[index]&0x80) {
+		i = 3;
+		while (i--){
+			newmode = drm_mode_duplicate(connector->dev,
+					&edid_vsp_modes[i]);
+			if (newmode) {
+				cout++;
+				drm_mode_probed_add(connector, newmode);
+			}else {
+				DRM_ERROR("kmzalloc edid for sunxi failed.\n");
+			}
+		}
+	}
+	DRM_INFO("3D_multi_present   %d.\n",cout);
+	if ( ((edid[index]&0x60) ==1) || ((edid[index]&0x60) ==2) )
+		DRM_INFO("3D_multi_present.\n");
+
+	vic_len = edid[index+1]>>5;
+	for (i = 0; i < vic_len; i++) {
+		/* HDMI_VIC for extended resolution transmission */
+		if ((edid[index+1+1+i] + 0x100) == HDMI3840_2160P_30)
+			newmode = drm_mode_duplicate(connector->dev,
+					&edid_vsp_modes[3]);
+		if (newmode) {
+			cout++;
+			drm_mode_probed_add(connector, newmode);
+		}
+		if (HDMI3840_2160P_25 == (edid[index+1+1+i] + 0x100))
+			newmode = drm_mode_duplicate(connector->dev,
+						&edid_vsp_modes[4]);
+		if (newmode) {
+			cout++;
+			drm_mode_probed_add(connector, newmode);
+		}
+		DRM_INFO("edid_parse_vsdb: VIC %d support.\n", edid[index+1+1+i]);
+	}
+	DRM_INFO("4k  _multi_present   %d.\n",cout);
+
+	index += (edid[index+1]&0xe0) + 2;
+	if (index > (size+1) )
+		return cout;
+
+	DRM_INFO("3D_multi_present byte(%2.2x,%2.2x).\n",edid[index],edid[index+1]);
+
+	return cout;
+}
+
+static int sunxi_load_cea_db(struct drm_connector *connector, struct edid *pedid)
+{
+	unsigned int offset;
+	struct sunxi_hdmi_private *sunxi_hdmi_p;
+	struct sunxi_drm_connector *sunxi_connector =
+	to_sunxi_connector(connector);
+	unsigned char *edid;
+	int count = 0;
+	sunxi_hdmi_p = sunxi_connector->panel->private;
+	edid = (unsigned char *)pedid;
+	/* must cea */
+	if (edid[0]!= 2) {
+		DRM_INFO("edid not cea :%d.\n",edid[0]);
+
+		return 0;
+	}
+	if (edid[1] >= 1) {
+		sunxi_hdmi_p->can_YCbCr444 = !!(edid[3] & 0x20);
+		sunxi_hdmi_p->can_YCbCr422 = !!(edid[3] & 0x10);
+	}
+
+	offset = edid[2];
+	if (offset > 4) {
+		u8 bsum = 4;
+		while (bsum < offset) {
+			u8 tag = edid[bsum]>>5;
+			u8 len = edid[bsum]&0x1f;
+			if ( (len > 0) && ((bsum + len + 1) > offset) ) {
+				goto out;
+
+				if ( tag == 3) {
+					count +=
+					sunxi_vendor_specific_mode(connector, edid+bsum+1, len);
+				}
+			}
+			bsum += (len +1);
+		}
+	}
+
+out:
+	return count;
+}
+
+void swiotlb_sync_single_for_device(struct device *hwdev, dma_addr_t dev_addr,
+		size_t size, enum dma_data_direction dir);
+
+unsigned int sunxi_hdmi_get_edid(struct sunxi_panel *panel)
+{
+	struct drm_connector *connector = panel->drm_connector;
+	int i = 0, block = 0;
+	unsigned int count = 0;
+	struct edid *sunxi_deid;
+	struct sunxi_hdmi_private *sunxi_hdmi_p;
+
+	sunxi_hdmi_p = (struct sunxi_hdmi_private *)panel->private;
+	sunxi_deid = kzalloc(sizeof(struct edid), GFP_KERNEL);
+	if (!sunxi_deid) {
+		DRM_ERROR("kzalloc edid for sunxi failed.\n");
+		goto out;
+	}
+
+	edid_read_data(0, sunxi_deid);
+	block = sunxi_deid->extensions;
+	if (block > 0 && block < 8) {
+		kfree(sunxi_deid);
+		sunxi_deid = kzalloc(sizeof(struct edid) * (block+1), GFP_KERNEL);
+		if (!sunxi_deid) {
+			DRM_ERROR("kzalloc edid for sunxi failed.\n");
+			goto out;
+		}
+		for (i = 0; i < (block+1); i++) {
+			edid_read_data(i, sunxi_deid);
+			//swiotlb_sync_single_for_device(NULL, virt_to_phys((sunxi_deid+i)), 128, DMA_BIDIRECTIONAL);
+			if(i > 0)
+			count += sunxi_load_cea_db(connector, sunxi_deid+i);
+		}
+		sunxi_hdmi_p->nr_sad = drm_edid_to_sad(sunxi_deid, &sunxi_hdmi_p->hdmi_sads);
+		drm_edid_to_eld(connector, sunxi_deid);
+	}
+
+	count += drm_add_edid_modes(connector, sunxi_deid);
+	if (!count) {
+		DRM_ERROR("Add edid modes failed %d\n", count);
+		kfree(sunxi_deid);
+		goto out;
+	}
+
+	drm_mode_connector_update_edid_property(connector, sunxi_deid);
+	kfree(sunxi_deid);
+
+	DRM_INFO("%s:add %d cout modes.\n",__func__, count);
+
+out:
+	return count;
+}
+
+enum drm_connector_status sunxi_hdmi_detect(struct sunxi_panel *panel)
+{
+	enum drm_connector_status status = connector_status_disconnected; 
+	int on_sure = 0, off_sure = 0, time = 5;
+
+	DRM_DEBUG_KMS("%s:line:%d  status:  %d\n", __func__,__LINE__, bsp_hdmi_get_hpd());
+	panel = panel;
+
+	while (time--) {
+		if (bsp_hdmi_get_hpd()) {
+			on_sure++;
+			off_sure = 0;
+		} else {
+			off_sure++;
+			on_sure = 0;
+		}
+		if (off_sure == 3) {
+			status = connector_status_disconnected;
+			break;
+		}
+		if (on_sure == 3) {
+			status = connector_status_connected;
+			break;
+		}
+		hdmi_delay_us(100);
+	}
+	return status;
+}
+
+static struct panel_ops  default_panel = {
+	.init = default_hdmi_init,
+	.open = default_hdmi_open,
+	.close = default_hdmi_close,
+	.reset = NULL,
+	.bright_light = NULL,
+	.detect = sunxi_hdmi_detect,
+	.change_mode_to_timming = sunxi_hdmi_mode_timmings,
+	.check_valid_mode = sunxi_hdmi_check_mode,
+	.get_modes = sunxi_hdmi_get_edid
+
+};
+
+void sunxi_hdmi_get_sys_info(struct sunxi_panel *sunxi_panel)
+{
+	struct sunxi_hdmi_private *sunxi_hdmi_p;
+	struct device_node *node;
+	unsigned int value;
+	disp_gpio_set_t  *gpio_info;
+	int i;
+	char io_name[32];
+
+	sunxi_hdmi_p = (struct sunxi_hdmi_private *)sunxi_panel->private;
+	node = sunxi_drm_get_name_node("sunxi-hdmi");
+	if (!node) {
+		DRM_ERROR("get sunxi-hdmi node err.\n");
+		return ;
+	}
+
+	sunxi_drm_get_sys_item_char(node, "hdmi_power", sunxi_hdmi_p->hdmi_power);
+	if (0 == sunxi_drm_get_sys_item_int(node, "hdmi_cts_compatibility", &value)) {
+		sunxi_hdmi_p->cts_compat = !!value;
+	}
+	if (0 == sunxi_drm_get_sys_item_int(node, "hdmi_hdcp_enable", &value)) {
+		sunxi_hdmi_p->hdcp_enable = !!value;
+	}
+	if (0 == sunxi_drm_get_sys_item_int(node, "hdmi_cec_support", &value)) {
+		sunxi_hdmi_p->cec_support = !!value;
+	}
+
+	for (i = 0; i < HDMI_IO_NUM; i++) {
+		gpio_info = &(sunxi_hdmi_p->hdmi_io[i]);
+		sprintf(io_name, "hdmi_io_%d", i);
+		if (0 == sunxi_drm_get_sys_item_gpio(node, io_name, gpio_info))
+			sunxi_hdmi_p->hdmi_io_used[i]= 1;
+		else
+			sunxi_hdmi_p->hdmi_io_used[i] = 0;
+	}
+}
+
+int sunxi_hdmi_set_audio_mode(struct sunxi_panel *sunxi_panel)
+{
+	return 0;
+}
+
+unsigned char  sunxi_hdmi_yuv_output(struct sunxi_hdmi_private *sunxi_hdmi_p)
+{
+	if (!sunxi_hdmi_p->can_YCbCr444)
+		return 0;   
+	switch (sunxi_hdmi_p->timing->vic) {
+	case HDMI1080P_24:
+	case HDMI1080P_24_3D_FP:
+	case HDMI3840_2160P_24:
+	case HDMI3840_2160P_30:
+	case HDMI3840_2160P_25:
+		return 0;
+	}
+	/* 1 is can_YCbCr444 */
+	return 1;
+}
+
+int sunxi_hdmi_set_timing(void *data, struct drm_display_mode *mode)
+{
+	struct sunxi_drm_connector *sunxi_connector =
+				to_sunxi_connector(data);
+	struct sunxi_panel *sunxi_panel = sunxi_connector->panel;
+	struct sunxi_hdmi_private *sunxi_hdmi_p = (struct sunxi_hdmi_private *)sunxi_panel->private;
+	struct sunxi_hardware_res *hw_res = sunxi_connector->hw_res;
+	enum drm_mode_status status;
+
+	if (!mode)
+		return 0;
+
+	status = sunxi_panel->panel_ops->change_mode_to_timming(sunxi_hdmi_p->timing, mode);
+	if (status != MODE_OK) {
+		DRM_ERROR("sunxi hdmi set timmings err status:%d.\n",status);
+		return  -EINVAL;
+	}
+	DRM_DEBUG_KMS("[%d] con_id:%d  vic:%d, mode_id:%d\n", __LINE__,
+	sunxi_connector->connector_id,sunxi_hdmi_p->timing->vic, mode->base.id);
+
+	sunxi_hdmi_p->video_para.vic = sunxi_hdmi_p->timing->vic;
+	sunxi_hdmi_p->video_para.is_yuv = 0;//sunxi_hdmi_yuv_output(sunxi_hdmi_p);
+	sunxi_hdmi_p->video_para.is_hdmi = 1;
+	sunxi_hdmi_p->video_para.csc = BT601;
+	sunxi_hdmi_p->audio_para.vic = sunxi_hdmi_p->timing->vic;
+	hw_res->clk_rate = sunxi_hdmi_p->timing->pixel_clk;
+
+	return 0;
+}
+
+bool sunxi_hdmi_disable(void *data)
+{
+	struct sunxi_drm_connector *sunxi_connector =
+				to_sunxi_connector(data);
+	struct sunxi_hardware_res  *hw_res = sunxi_connector->hw_res;
+	struct sunxi_panel *sunxi_panel = sunxi_connector->panel;
+
+	sunxi_panel->panel_ops->close(sunxi_panel);
+	sunxi_irq_free(hw_res);
+	return true;
+}
+
+bool sunxi_hdmi_enable(void *data)
+{
+	struct sunxi_drm_connector *sunxi_connector =
+				to_sunxi_connector(data);
+	struct sunxi_panel *sunxi_panel = sunxi_connector->panel;
+	sunxi_panel->panel_ops->open(sunxi_panel);
+	return true;
+}
+
+bool sunxi_hdmi_reset(void *data)
+{
+	struct drm_connector *connector = (struct drm_connector *)data;
+	struct sunxi_drm_connector *sunxi_connector =
+					to_sunxi_connector(data);
+	struct sunxi_drm_encoder *sunxi_encoder;
+	struct sunxi_drm_crtc *sunxi_crtc;
+	if (!connector || !connector->encoder || !connector->encoder->crtc) {
+		return false;
+	}
+
+	sunxi_encoder = to_sunxi_encoder(connector->encoder);
+	sunxi_crtc = to_sunxi_crtc(connector->encoder->crtc);
+	sunxi_clk_set(sunxi_connector->hw_res);
+	sunxi_clk_enable(sunxi_connector->hw_res);
+	return true;
+}
+
+bool sunxi_hdmi_init(void *data)
+{
+	struct sunxi_drm_connector *sunxi_connector =
+			to_sunxi_connector(data);
+	struct sunxi_hdmi_private *sunxi_hdmi_p;
+	hdmi_bsp_func hdmi_func;
+	struct sunxi_panel *sunxi_panel;
+	sunxi_panel = sunxi_connector->panel;
+	sunxi_hdmi_p = (struct sunxi_hdmi_private *)sunxi_panel->private;
+
+	hdmi_func.delay_ms = hdmi_delay_ms;
+	hdmi_func.delay_us = hdmi_delay_us;
+	bsp_hdmi_set_func(&hdmi_func);
+	sunxi_hdmi_get_sys_info(sunxi_connector->panel);
+	/* hdmi must all open */
+	sunxi_connector->hw_res->clk_rate = 
+	sunxi_hdmi_p->timing->pixel_clk;
+	sunxi_drm_sys_power_enable(sunxi_hdmi_p->hdmi_power);
+
+	sunxi_clk_set(sunxi_connector->hw_res);
+	sunxi_clk_enable(sunxi_connector->hw_res);
+	clk_prepare_enable(sunxi_panel->clk);
+	msleep(200);
+	bsp_hdmi_set_version(0);
+#if defined(HDMI_USING_INNER_BIAS)
+	bsp_hdmi_set_bias_source(HDMI_USING_INNER_BIAS);
+#endif
+	bsp_hdmi_init();
+	bsp_hdmi_hrst();
+	bsp_hdmi_standby();
+	msleep(200);
+	return true;
+}
+
+void sunxi_hdmi_delayed_work(void *data)
+{
+	/* get cec msg */
+	unsigned char msg;
+	bsp_hdmi_cec_get_simple_msg(&msg);
+}
+
+static struct sunxi_hardware_ops hdmi_con_ops = {
+	.init = sunxi_hdmi_init,
+	.reset = sunxi_hdmi_reset,
+	.enable = sunxi_hdmi_enable,
+	.disable = sunxi_hdmi_disable,
+	.updata_reg = NULL,
+	.vsync_proc = NULL,
+	.irq_query = NULL,
+	/* whether check the cec ctl info in vysnc delayed work?
+	* or other place better?. 
+	*/
+	.vsync_delayed_do = sunxi_hdmi_delayed_work,
+	.set_timming = sunxi_hdmi_set_timing,
+
+};
+
+static int sunxi_hdmi_hwres_init(struct sunxi_hardware_res *hw_res,
+	struct sunxi_panel *sunxi_panel, struct device_node *hdmi_node)
+{
+	hw_res->reg_base = (uintptr_t __force)of_iomap(hdmi_node, 0);
+	if (0 ==  hw_res->reg_base) {
+		DRM_ERROR("unable to map hdmi registers\n");
+		return -EINVAL;
+	}
+	bsp_hdmi_set_addr(hw_res->reg_base);
+#if defined(CONFIG_COMMON_CLK)
+	/* get clk */
+	hw_res->clk = of_clk_get(hdmi_node, 0);
+	if (IS_ERR(hw_res->clk)) {
+		DRM_ERROR("fail to get clk for hdmi\n");
+		return -EINVAL;
+	}
+	/* here we use panel clk for ddc clock*/
+	sunxi_panel->clk = of_clk_get(hdmi_node, 1);
+	if (IS_ERR(sunxi_panel->clk)) {
+		DRM_ERROR("fail to get clk for hdmi ddc\n");
+		return -EINVAL;
+	}
+	hw_res->ops = &hdmi_con_ops;
+#endif
+	return 0;
+}
+
+static int sunxi_hdmi_private_init(struct sunxi_panel *sunxi_panel, int hdmi_id)
+{
+	struct sunxi_hdmi_private *sunxi_hdmi_p;
+	sunxi_hdmi_p = kzalloc(sizeof( struct sunxi_hdmi_private), GFP_KERNEL);
+	if (!sunxi_hdmi_p) {
+		DRM_ERROR("failed to allocate sunxi_hdmi_private.\n");
+		return -EINVAL;
+	}
+	sunxi_hdmi_p->timing = kzalloc(sizeof( struct disp_video_timings), GFP_KERNEL);
+	if (!sunxi_hdmi_p->timing) {
+		DRM_ERROR("failed to allocate disp_video_timings.\n");
+		kfree(sunxi_hdmi_p);
+		return -EINVAL;
+	}
+	sunxi_panel->private = sunxi_hdmi_p;
+	sunxi_hdmi_p->hdmi_id = hdmi_id;
+
+	return 0;
+}
+
+void sunxi_hdmi_private_destroy(struct sunxi_hdmi_private *sunxi_hdmi_p)
+{
+	kfree(sunxi_hdmi_p->timing);
+	kfree(sunxi_hdmi_p);
+}
+
+static int inline sunxi_hdmi_panel_ops_init(struct sunxi_panel *sunxi_panel)
+{
+	sunxi_panel->panel_ops = &default_panel;
+	if (sunxi_panel->panel_ops->init) {
+		if(!sunxi_panel->panel_ops->init(sunxi_panel))
+			return -EINVAL;
+	}
+	return 0;
+}
+
+struct sunxi_panel *sunxi_hdmi_pan_init(struct sunxi_hardware_res *hw_res, int pan_id, int hdmi_id)
+{
+	char primary_key[20];
+	int value,ret;
+	struct sunxi_panel *sunxi_panel = NULL;
+	struct device_node *node;
+
+	sprintf(primary_key, "sunxi-hdmi");
+	node = sunxi_drm_get_name_node(primary_key);
+	if (!node) {
+		DRM_ERROR("get device [%s] node fail.\n", primary_key);
+		return NULL;
+	}
+
+	sunxi_panel = sunxi_panel_creat(value, pan_id);
+	if (!sunxi_panel) {
+		DRM_ERROR("creat sunxi panel fail.\n");
+		goto err_false;
+	}
+
+	ret = sunxi_hdmi_hwres_init(hw_res, sunxi_panel, node);
+	if (ret) {
+		DRM_ERROR("creat hw_res fail.\n");
+		sunxi_panel_destroy(sunxi_panel);
+		goto err_false;
+	}
+
+	ret = sunxi_hdmi_private_init(sunxi_panel, hdmi_id);
+	if (ret) {
+		DRM_ERROR("creat hw_res fail.\n");
+		sunxi_panel_destroy(sunxi_panel);
+		goto err_false;
+	} 
+
+	ret = sunxi_hdmi_panel_ops_init(sunxi_panel);
+	if (ret) {
+		sunxi_panel_destroy(sunxi_panel);
+		DRM_ERROR("creat panel_ops fail.\n");
+		goto err_false;
+	}
+	return sunxi_panel;
+err_false:
+	return NULL;
+}
+
+void sunxi_hdmi_pan_destroy(struct sunxi_panel *sunxi_panel,
+            struct sunxi_hardware_res *hw_res)
+{
+	struct sunxi_hdmi_private *sunxi_hdmi_p;
+	sunxi_hdmi_p = (struct sunxi_hdmi_private *)sunxi_panel->private;
+	sunxi_hdmi_private_destroy(sunxi_hdmi_p);
+	sunxi_hwres_destroy(hw_res);
+}
diff --git a/drivers/gpu/drm/sunxi/subdev/sunxi_hdmi.h b/drivers/gpu/drm/sunxi/subdev/sunxi_hdmi.h
new file mode 100755
index 0000000..876adf5
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/subdev/sunxi_hdmi.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+/*HDMI panel ops*/
+#ifndef _SUNXI_HDMI_H_
+#define _SUNXI_HDMI_H_
+#include "hdmi_bsp.h"
+#define Abort_Current_Operation             0
+#define Special_Offset_Address_Read         1
+#define Explicit_Offset_Address_Write       2
+#define Implicit_Offset_Address_Write       3
+#define Explicit_Offset_Address_Read        4
+#define Implicit_Offset_Address_Read        5
+#define Explicit_Offset_Address_E_DDC_Read  6
+#define Implicit_Offset_Address_E_DDC_Read  7
+
+#define HDMI1440_480I		6
+#define HDMI1440_576I		21
+#define HDMI480P			2
+#define HDMI576P			17
+#define HDMI720P_50			19
+#define HDMI720P_60 		4
+#define HDMI1080I_50		20
+#define HDMI1080I_60		5
+#define HDMI1080P_50		31
+#define HDMI1080P_60 		16
+#define HDMI1080P_24 		32
+#define HDMI1080P_25 		33
+#define HDMI1080P_30 		34
+#define HDMI1080P_24_3D_FP  (HDMI1080P_24 +0x80)
+#define HDMI720P_50_3D_FP   (HDMI720P_50  +0x80)
+#define HDMI720P_60_3D_FP   (HDMI720P_60  +0x80)
+#define HDMI3840_2160P_30   (1+0x100)
+#define HDMI3840_2160P_25   (2+0x100)
+#define HDMI3840_2160P_24   (3+0x100)
+#define HDMI_EDID_LEN 1024
+
+#define HDMI_State_Idle 			 0x00
+#define HDMI_State_Wait_Hpd			 0x02
+#define HDMI_State_Rx_Sense			 0x03
+#define HDMI_State_EDID_Parse		 0x04
+#define HDMI_State_HPD_Done			 0x05
+
+#define HDMI_IO_NUM 5
+
+struct sunxi_hdmi_private {
+	int hdmi_id;
+	struct sunxi_panel *sunxi_panel;
+	struct disp_video_timings *timing;
+	bool    hdmi_io_used[HDMI_IO_NUM];
+	bool    power_on;
+	bool    can_YCbCr444;
+	bool    can_YCbCr422;
+	bool    cts_compat;
+	bool    hdcp_enable;
+	bool    cec_support;
+	bool    exp;
+	disp_gpio_set_t hdmi_io[HDMI_IO_NUM];
+	int             gpio_handle[HDMI_IO_NUM];
+	char    hdmi_power[25];
+	struct cea_sad    *hdmi_sads;
+	int   nr_sad;
+	struct video_para video_para;
+	struct audio_para audio_para;
+};
+
+struct sunxi_panel *sunxi_hdmi_pan_init(struct sunxi_hardware_res *hw_res, int pan_id, int hdmi_id);
+
+void sunxi_hdmi_pan_destroy(struct sunxi_panel *sunxi_panel,
+	struct sunxi_hardware_res *hw_res);
+enum drm_mode_status
+	sunxi_hdmi_mode_timmings(void *timing, struct drm_display_mode *mode);
+#endif
diff --git a/drivers/gpu/drm/sunxi/subdev/sunxi_lcd.c b/drivers/gpu/drm/sunxi/subdev/sunxi_lcd.c
new file mode 100755
index 0000000..26c3532
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/subdev/sunxi_lcd.c
@@ -0,0 +1,1438 @@
+ /*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+/*LCD panel ops*/
+
+
+#include <drm/drmP.h>
+
+#include "../sunxi_drm_drv.h"
+#include "../sunxi_drm_core.h"
+#include "../sunxi_drm_crtc.h"
+#include "../sunxi_drm_encoder.h"
+#include "../sunxi_drm_connector.h"
+#include "../sunxi_drm_plane.h"
+#include "../drm_de/drm_al.h"
+#include "../subdev/sunxi_common.h"
+#include "../sunxi_drm_panel.h"
+#include "sunxi_lcd.h"
+#include "de/disp_lcd.h"
+#include "de/include.h"
+
+#define DISP_PIN_STATE_ACTIVE "active"
+#define DISP_PIN_STATE_SLEEP "sleep"
+
+static struct lcd_clk_info clk_tbl[] = {
+	{LCD_IF_HV,     6, 1, 1, 0},
+	{LCD_IF_CPU,   12, 1, 1, 0},
+	{LCD_IF_LVDS,   7, 1, 1, 0},
+	{LCD_IF_DSI,    4, 1, 4, 148500000},
+};
+
+/* LCD panel control extern*/
+
+static int sunxi_lcd_extern_backlight_enable(struct sunxi_lcd_private *sunxi_lcd)
+{
+	disp_gpio_set_t  gpio_info[1];
+	disp_lcd_cfg  *lcd_cfg = sunxi_lcd->lcd_cfg;
+
+	if (lcd_cfg->lcd_bl_en_used && sunxi_lcd->bl_enalbe == 0) {
+
+		if (!((!strcmp(lcd_cfg->lcd_bl_en_power, "")) ||
+		(!strcmp(lcd_cfg->lcd_bl_en_power, "none")))) {
+			sunxi_drm_sys_power_enable(lcd_cfg->lcd_bl_en_power);
+		}
+		memcpy(gpio_info, &(lcd_cfg->lcd_bl_en), sizeof(disp_gpio_set_t));
+		DRM_DEBUG_KMS("[%d] %s", __LINE__, __func__);
+
+		//lcd_cfg->lcd_bl_gpio_hdl = sunxi_drm_sys_gpio_request(gpio_info);
+		sunxi_lcd->bl_enalbe = 1;
+	}
+
+	return 0;
+}
+
+static int sunxi_lcd_extern_backlight_disable(struct sunxi_lcd_private *sunxi_lcd)
+{
+	disp_gpio_set_t  gpio_info[1];
+	disp_lcd_cfg  *lcd_cfg = sunxi_lcd->lcd_cfg;
+
+	if (lcd_cfg->lcd_bl_en_used && sunxi_lcd->bl_enalbe == 1) {
+		memcpy(gpio_info, &(lcd_cfg->lcd_bl_en), sizeof(disp_gpio_set_t));
+		gpio_info->data = (gpio_info->data==0)?1:0;
+		gpio_info->mul_sel = 7;
+		//sunxi_drm_sys_gpio_release(lcd_cfg->lcd_bl_gpio_hdl);
+		DRM_DEBUG_KMS("[%d] %s", __LINE__, __func__);
+
+		if (!((!strcmp(lcd_cfg->lcd_bl_en_power, "")) ||
+		(!strcmp(lcd_cfg->lcd_bl_en_power, "none")))) {
+			sunxi_drm_sys_power_disable(lcd_cfg->lcd_bl_en_power);
+		}
+		sunxi_lcd->bl_enalbe = 0;
+	}
+
+	return 0;
+}
+
+void sunxi_lcd_extrn_power_on(struct sunxi_lcd_private *sunxi_lcd)
+{
+	int i;
+	disp_lcd_cfg *lcd_cfg = sunxi_lcd->lcd_cfg;
+
+	if(sunxi_lcd->ex_power_on)
+		return;
+
+	for (i = 0; i < LCD_POWER_NUM; i++) {
+		if (1 == lcd_cfg->lcd_power_used[i]) {
+			/* regulator type */
+			sunxi_drm_sys_power_enable(lcd_cfg->lcd_power[i]);
+		}
+	}
+	sunxi_lcd->ex_power_on = 1;
+}
+
+void sunxi_lcd_extrn_power_off(struct sunxi_lcd_private *sunxi_lcd)
+{
+	int i;
+	disp_lcd_cfg *lcd_cfg = sunxi_lcd->lcd_cfg;
+	if(sunxi_lcd->ex_power_on == 0)
+		return;
+
+	for (i = 0; i < LCD_POWER_NUM; i++) {
+		if (1 == lcd_cfg->lcd_power_used[i]) {
+			/* regulator type */
+			sunxi_drm_sys_power_disable(lcd_cfg->lcd_power[i]);
+		}
+	}
+	sunxi_lcd->ex_power_on = 0;
+}
+
+struct lcd_clk_info *sunxi_lcd_clk_info_init(disp_panel_para * panel)
+{
+	int tcon_div = 6;//tcon inner div
+	int lcd_div = 1;//lcd clk div
+	int dsi_div = 4;//dsi clk div
+	int dsi_rate = 0;
+	int i;
+	int find = 0;
+	struct lcd_clk_info *info;
+
+	if (NULL == panel) {
+		DRM_ERROR("give a err sunxi_panel.\n");
+		return NULL;
+	}
+
+	info = kzalloc(sizeof(struct lcd_clk_info), GFP_KERNEL);
+	if (!info) {
+		DRM_ERROR("failed to allocate disp_panel_para.\n");
+		return NULL;
+	}
+
+	for (i = 0; i < sizeof(clk_tbl) / sizeof(struct lcd_clk_info); i++) {
+		if (clk_tbl[i].lcd_if == panel->lcd_if) {
+			tcon_div = clk_tbl[i].tcon_div;
+			lcd_div = clk_tbl[i].lcd_div;
+			dsi_div = clk_tbl[i].dsi_div;
+			dsi_rate = clk_tbl[i].dsi_rate;
+			find = 1;
+			break;
+		}
+	}
+
+	if (panel->lcd_if == LCD_IF_DSI) {
+		u32 lane = panel->lcd_dsi_lane;
+		u32 bitwidth = 0;
+
+		switch (panel->lcd_dsi_format) {
+		case LCD_DSI_FORMAT_RGB888:
+			bitwidth = 24;
+			break;
+		case LCD_DSI_FORMAT_RGB666:
+			bitwidth = 24;
+			break;
+		case LCD_DSI_FORMAT_RGB565:
+			bitwidth = 16;
+			break;
+		case LCD_DSI_FORMAT_RGB666P:
+			bitwidth = 18;
+			break;
+		}
+
+		dsi_div = bitwidth / lane;
+	}
+
+	if (0 == find) {
+		DRM_ERROR("can not find the lcd_clk_info, use default.\n");
+	}
+
+	info->tcon_div = tcon_div;
+	info->lcd_div = lcd_div;
+	info->dsi_div = dsi_div;
+	info->dsi_rate = dsi_rate;
+
+	return info;
+}
+
+static bool default_panel_init(struct sunxi_panel *sunxi_panel)
+{
+	u32 i = 0, j = 0;
+	u32 items;
+
+	struct sunxi_lcd_private *sunxi_lcd = sunxi_panel->private;
+	disp_lcd_cfg *lcd_cfg = sunxi_lcd->lcd_cfg;
+	panel_extend_para *info = sunxi_lcd->extend_panel;
+	disp_panel_para *panel = sunxi_lcd->panel;
+	u32 lcd_bright_curve_tbl[101][2];
+	/*init gamma*/
+
+	u8 lcd_gamma_tbl[][2] = {
+		//{input value, corrected value}
+		{0, 0},
+		{15, 15},
+		{30, 30},
+		{45, 45},
+		{60, 60},
+		{75, 75},
+		{90, 90},
+		{105, 105},
+		{120, 120},
+		{135, 135},
+		{150, 150},
+		{165, 165},
+		{180, 180},
+		{195, 195},
+		{210, 210},
+		{225, 225},
+		{240, 240},
+		{255, 255},
+	};
+	u32 lcd_cmap_tbl[2][3][4] = {
+		{
+			{LCD_CMAP_G0,LCD_CMAP_B1,LCD_CMAP_G2,LCD_CMAP_B3},
+			{LCD_CMAP_B0,LCD_CMAP_R1,LCD_CMAP_B2,LCD_CMAP_R3},
+			{LCD_CMAP_R0,LCD_CMAP_G1,LCD_CMAP_R2,LCD_CMAP_G3},
+		},
+		{
+			{LCD_CMAP_B3,LCD_CMAP_G2,LCD_CMAP_B1,LCD_CMAP_G0},
+			{LCD_CMAP_R3,LCD_CMAP_B2,LCD_CMAP_R1,LCD_CMAP_B0},
+			{LCD_CMAP_G3,LCD_CMAP_R2,LCD_CMAP_G1,LCD_CMAP_R0},
+		},
+	};
+	lcd_cfg->backlight_dimming = 0;
+	items = sizeof(lcd_gamma_tbl) / 2;
+	for (i = 0; i < items-1; i++) {
+		u32 num = lcd_gamma_tbl[i+1][0] - lcd_gamma_tbl[i][0];
+
+		for (j = 0; j < num; j++) {
+			u32 value = 0;
+
+			value = lcd_gamma_tbl[i][1] + ((lcd_gamma_tbl[i+1][1] - lcd_gamma_tbl[i][1]) * j)/num;
+			info->lcd_gamma_tbl[lcd_gamma_tbl[i][0] + j] = (value<<16) + (value<<8) + value;
+		}
+	}
+
+	info->lcd_gamma_tbl[255] = (lcd_gamma_tbl[items-1][1]<<16) +
+				(lcd_gamma_tbl[items-1][1]<<8) + lcd_gamma_tbl[items-1][1];
+	/* init cmap */
+
+	memcpy(info->lcd_cmap_tbl, lcd_cmap_tbl, sizeof(lcd_cmap_tbl));
+
+	/*init the bright */
+	for (i = 0, items = 0; i < 101; i++) {
+		if (lcd_cfg->backlight_curve_adjust[i] == 0) {
+			if (i == 0) {
+				lcd_bright_curve_tbl[items][0] = 0;
+				lcd_bright_curve_tbl[items][1] = 0;
+				items++;
+			}
+		} else {
+			lcd_bright_curve_tbl[items][0] = 255 * i / 100;
+			lcd_bright_curve_tbl[items][1] = lcd_cfg->backlight_curve_adjust[i];
+			items++;
+		}
+	}
+
+	for (i = 0; i < items-1; i++) {
+		u32 num = lcd_bright_curve_tbl[i+1][0] - lcd_bright_curve_tbl[i][0];
+
+		for (j = 0; j < num; j++) {
+			u32 value = 0;
+
+			value = lcd_bright_curve_tbl[i][1] + ((lcd_bright_curve_tbl[i+1][1] -
+			lcd_bright_curve_tbl[i][1]) * j)/num;
+			info->lcd_bright_curve_tbl[lcd_bright_curve_tbl[i][0] + j] = value;
+		}
+	}
+
+	info->lcd_bright_curve_tbl[255] = lcd_bright_curve_tbl[items-1][1];
+
+	sunxi_lcd->clk_info = sunxi_lcd_clk_info_init(panel);
+	if (!sunxi_lcd->clk_info) {
+		DRM_ERROR("failed to init clk_info.\n");
+		return false;
+	}
+	sunxi_panel->clk_rate = panel->lcd_dclk_freq * 1000000;
+	return true;
+}
+
+bool default_panel_open(struct sunxi_panel *sunxi_panel)
+{
+	sunxi_lcd_extrn_power_on(sunxi_panel->private);
+	sunxi_drm_delayed_ms(80);
+	sunxi_chain_enable(sunxi_panel->drm_connector, CHAIN_BIT_ENCODER);
+	sunxi_drm_delayed_ms(100);
+	return true;
+}
+
+bool default_panel_close(struct sunxi_panel *panel)
+{
+	sunxi_chain_disable(panel->drm_connector, CHAIN_BIT_ENCODER);
+	sunxi_drm_delayed_ms(200);
+	sunxi_lcd_extrn_power_off(panel->private);
+	sunxi_drm_delayed_ms(500);
+	return true;
+}
+
+bool sunxi_lcd_default_set_bright(struct sunxi_panel *sunxi_panel, unsigned int bright)
+{
+	struct sunxi_lcd_private *sunxi_lcd = sunxi_panel->private;
+
+	if (bright > 0) {
+		sunxi_drm_sys_pwm_enable(sunxi_lcd->pwm_info);
+	} else {
+		sunxi_drm_sys_pwm_disable(sunxi_lcd->pwm_info);
+	}
+	sunxi_common_pwm_set_bl(sunxi_lcd, bright);
+	/* to add spec bright for spec lcd*/
+	if (bright > 0) {
+		sunxi_lcd_extern_backlight_enable(sunxi_lcd);
+	} else {
+		sunxi_lcd_extern_backlight_disable(sunxi_lcd);
+	}
+	return true;
+}
+
+bool cmp_panel_with_display_mode(struct drm_display_mode *mode,
+			disp_panel_para       *panel)
+{
+	if((mode->clock == panel->lcd_dclk_freq * 1000) &&
+			(mode->hdisplay == panel->lcd_x) &&
+		(mode->hsync_start == (panel->lcd_ht - panel->lcd_hbp)) &&
+		(mode->hsync_end == (panel->lcd_ht - panel->lcd_hbp + panel->lcd_hspw)) &&
+		(mode->htotal == panel->lcd_ht) &&
+		(mode->vdisplay == panel->lcd_y) &&
+		(mode->vsync_start == (panel->lcd_vt - panel->lcd_vbp)) &&
+		(mode->vsync_end == (panel->lcd_vt - panel->lcd_vbp + panel->lcd_vspw)) &&
+		(mode->vtotal == panel->lcd_vt) &&
+		(mode->vscan == 0) &&
+		(mode->flags == 0) &&
+		(mode->width_mm == panel->lcd_width) &&
+		(mode->height_mm == panel->lcd_height) &&
+		(mode->vrefresh == (mode->clock * 1000 / mode->vtotal / mode->htotal)))
+		return true;
+	return false;
+}
+
+enum drm_mode_status
+	sunxi_lcd_valid_mode(struct sunxi_panel *panel, struct drm_display_mode *mode)
+{
+	enum drm_mode_status status = MODE_BAD;
+	struct sunxi_lcd_private *sunxi_lcd_p = (struct sunxi_lcd_private *)panel->private;
+
+	if (cmp_panel_with_display_mode(mode, sunxi_lcd_p->panel))
+		status = MODE_OK;
+
+	return status;
+}
+
+static inline void convert_panel_to_display_mode(struct drm_display_mode *mode,
+			disp_panel_para  *panel)
+{
+	mode->clock       = panel->lcd_dclk_freq * 1000;
+
+	mode->hdisplay    = panel->lcd_x;
+	mode->hsync_start = panel->lcd_ht - panel->lcd_hbp;
+	mode->hsync_end   = panel->lcd_ht - panel->lcd_hbp + panel->lcd_hspw;
+	mode->htotal      = panel->lcd_ht;
+
+	mode->vdisplay    = panel->lcd_y;
+	mode->vsync_start = panel->lcd_vt - panel->lcd_vbp;
+	mode->vsync_end   = panel->lcd_vt - panel->lcd_vbp + panel->lcd_vspw;
+	mode->vtotal      = panel->lcd_vt;
+	mode->vscan       = 0;
+	mode->flags       = 0;
+	mode->width_mm    = panel->lcd_width;
+	mode->height_mm   = panel->lcd_height;
+	mode->vrefresh    = mode->clock * 1000 / mode->vtotal / mode->htotal;
+	DRM_DEBUG_KMS("Modeline %d: %d %d %d %d %d %d %d %d %d %d "
+		"0x%x 0x%x\n",
+		mode->base.id, mode->vrefresh, mode->clock,
+		mode->hdisplay, mode->hsync_start,
+		mode->hsync_end, mode->htotal,
+		mode->vdisplay, mode->vsync_start,
+		mode->vsync_end, mode->vtotal, mode->type, mode->flags);
+	DRM_DEBUG_KMS("panel: clk[%d] [x %d, ht %d, hbp %d, hspw %d] [y%d, vt%d, bp %d, pw %d,] "
+		"%d x %d\n",
+		panel->lcd_dclk_freq * 1000,
+		panel->lcd_x, panel->lcd_ht,
+		panel->lcd_hbp,panel->lcd_hspw,
+		panel->lcd_y, panel->lcd_vt,
+		panel->lcd_vbp, panel->lcd_vspw,panel->lcd_width, panel->lcd_height);
+}
+
+unsigned int sunxi_lcd_get_modes(struct sunxi_panel *sunxi_panel)
+{
+	disp_panel_para   *panel;
+	struct drm_display_mode *mode;
+	struct sunxi_lcd_private *sunxi_lcd_p = (struct sunxi_lcd_private *)sunxi_panel->private;
+	struct drm_connector *connector = sunxi_panel->drm_connector;
+	panel = sunxi_lcd_p->panel;;
+
+	mode = drm_mode_create(connector->dev);
+	if (!mode) {
+		DRM_ERROR("failed to create a new display mode.\n");
+		return 0;
+	}
+
+	convert_panel_to_display_mode(mode, panel);
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	drm_mode_set_name(mode);
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+enum drm_connector_status
+	sunxi_common_detect(struct sunxi_panel *panel)
+{
+	return connector_status_connected;
+}
+
+static struct  panel_ops  default_panel = {
+	.init = default_panel_init,
+	.open = default_panel_open,
+	.close = default_panel_close,
+	.reset = NULL,
+	.bright_light = sunxi_lcd_default_set_bright,
+	.detect  = sunxi_common_detect,
+	.change_mode_to_timming = NULL,
+	.check_valid_mode = sunxi_lcd_valid_mode,
+	.get_modes = sunxi_lcd_get_modes,
+};
+
+int sunxi_get_lcd_sys_info(struct sunxi_lcd_private *sunxi_lcd)
+{
+	disp_gpio_set_t  *gpio_info;
+	char primary_key[20], sub_name[25];
+	int i = 0, ret = -EINVAL, value = 1;
+	disp_lcd_cfg  *lcd_cfg = sunxi_lcd->lcd_cfg;
+	disp_panel_para  *info = sunxi_lcd->panel;
+	char compat[32];
+	struct device_node *node;
+
+	sprintf(primary_key, "sunxi-lcd%d", sunxi_lcd->lcd_id);
+	node = sunxi_drm_get_name_node(primary_key);
+	if (!node) {
+		DRM_ERROR("of_find_compatible_node %s fail\n", compat);
+		return -EINVAL;
+	}
+	/* lcd_used */
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_used", &value);
+	if (ret == 0) {
+		lcd_cfg->lcd_used = value;
+	}
+
+	if (lcd_cfg->lcd_used == 0) {
+		return -EINVAL;
+	}
+
+	/* lcd_bl_en */
+	lcd_cfg->lcd_bl_en_used = 0;
+	gpio_info = &(lcd_cfg->lcd_bl_en);
+	ret = sunxi_drm_get_sys_item_gpio(node, "lcd_bl_en", gpio_info);
+	if (ret == 0) {
+		lcd_cfg->lcd_bl_en_used = 1;
+	}
+
+	sprintf(sub_name, "lcd_bl_en_power");
+	ret = sunxi_drm_get_sys_item_char(node, sub_name, lcd_cfg->lcd_bl_en_power);
+
+	/* lcd fix power */
+	for (i = 0; i < LCD_POWER_NUM; i++) {
+		if (i == 0) {
+			sprintf(sub_name, "lcd_fix_power");
+		}else {
+			sprintf(sub_name, "lcd_fix_power%d", i);
+		}
+
+		lcd_cfg->lcd_power_used[i] = 0;
+		ret = sunxi_drm_get_sys_item_char(node, sub_name, lcd_cfg->lcd_fix_power[i]);
+		if (ret == 0) {
+			lcd_cfg->lcd_fix_power_used[i] = 1;
+		}
+	}
+
+	/* lcd_power */
+	for (i = 0; i < LCD_POWER_NUM; i++) {
+		if (i == 0) {
+			sprintf(sub_name, "lcd_power");
+		} else {
+			sprintf(sub_name, "lcd_power%d", i);
+		}
+		lcd_cfg->lcd_power_used[i] = 0;
+		ret = sunxi_drm_get_sys_item_char(node, sub_name,lcd_cfg->lcd_power[i]);
+		if (ret == 0) {
+			lcd_cfg->lcd_power_used[i] = 1;
+		}
+	}
+
+	/* lcd_gpio */
+	for (i = 0; i < LCD_GPIO_NUM; i++) {
+		sprintf(sub_name, "lcd_gpio_%d", i);
+		gpio_info = &(lcd_cfg->lcd_gpio[i]);
+		ret = sunxi_drm_get_sys_item_gpio(node, sub_name, gpio_info);
+		if (ret == 0) {
+			lcd_cfg->lcd_gpio_used[i] = 1;
+		}
+	}
+
+	/*lcd_gpio_scl,lcd_gpio_sda*/
+	gpio_info = &(lcd_cfg->lcd_gpio[LCD_GPIO_SCL]);
+	ret = sunxi_drm_get_sys_item_gpio(node, "lcd_gpio_scl", gpio_info);
+	if (ret == 0) {
+		lcd_cfg->lcd_gpio_used[LCD_GPIO_SCL] = 1;
+	}
+
+	gpio_info = &(lcd_cfg->lcd_gpio[LCD_GPIO_SDA]);
+	ret = sunxi_drm_get_sys_item_gpio(node, "lcd_gpio_sda", gpio_info);
+	if (ret == 0) {
+		lcd_cfg->lcd_gpio_used[LCD_GPIO_SDA] = 1;
+	}
+
+	for (i = 0; i < LCD_GPIO_REGU_NUM; i++) {
+		sprintf(sub_name, "lcd_gpio_power%d", i);
+		ret = sunxi_drm_get_sys_item_char(node, sub_name, lcd_cfg->lcd_gpio_power[i]);
+	}
+
+	for (i = 0; i < LCD_GPIO_REGU_NUM; i++) {
+		if (0 == i) {
+			sprintf(sub_name, "lcd_pin_power");
+		} else {
+			sprintf(sub_name, "lcd_pin_power%d", i);
+		}
+		ret = sunxi_drm_get_sys_item_char(node, sub_name, lcd_cfg->lcd_pin_power[i]);
+	}
+
+	/* backlight adjust */
+	for (i = 0; i < 101; i++) {
+		sprintf(sub_name, "lcd_bl_%d_percent", i);
+		lcd_cfg->backlight_curve_adjust[i] = 0;
+
+		if (i == 100) {
+			lcd_cfg->backlight_curve_adjust[i] = 255;
+		}
+
+		ret = sunxi_drm_get_sys_item_int(node, sub_name, &value);
+		if (ret == 0) {
+			value = (value > 100)? 100:value;
+			value = value * 255 / 100;
+			lcd_cfg->backlight_curve_adjust[i] = value;
+		}
+	}
+
+	sprintf(sub_name, "lcd_backlight");
+	ret = sunxi_drm_get_sys_item_int(node, sub_name, &value);
+	if (ret == 0) {
+		value = (value > 256)? 256:value;
+		lcd_cfg->backlight_bright = value;
+	} else {
+		lcd_cfg->backlight_bright = 197;
+	}
+	lcd_cfg->lcd_bright = lcd_cfg->backlight_bright;
+	/* display mode */
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_x", &value);
+	if (ret == 0) {
+		info->lcd_x = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_y", &value);
+	if (ret == 0) {
+		info->lcd_y = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_width", &value);
+	if (ret == 0) {
+		info->lcd_width = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_height", &value);
+	if (ret == 0) {
+		info->lcd_height = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_dclk_freq", &value);
+	if (ret == 0) {
+		info->lcd_dclk_freq = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_pwm_used", &value);
+	if (ret == 0) {
+		info->lcd_pwm_used = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_pwm_ch", &value);
+	if (ret == 0) {
+		info->lcd_pwm_ch = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_pwm_freq", &value);
+	if (ret == 0) {
+		info->lcd_pwm_freq = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_pwm_pol", &value);
+	if (ret == 0) {
+		info->lcd_pwm_pol = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_if", &value);
+	if (ret == 0) {
+	info->lcd_if = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_hbp", &value);
+	if (ret == 0) {
+		info->lcd_hbp = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_ht", &value);
+	if (ret == 0) {
+		info->lcd_ht = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_vbp", &value);
+	if (ret == 0) {
+		info->lcd_vbp = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_vt", &value);
+	if (ret == 0) {
+		info->lcd_vt = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_hv_if", &value);
+	if (ret == 0) {
+		info->lcd_hv_if = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_vspw", &value);
+	if (ret == 0) {
+		info->lcd_vspw = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_hspw", &value);
+	if (ret == 0) {
+		info->lcd_hspw = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_lvds_if", &value);
+	if (ret == 0) {
+		info->lcd_lvds_if = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_lvds_mode", &value);
+	if (ret == 0) {
+		info->lcd_lvds_mode = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_lvds_colordepth", &value);
+	if (ret == 0) {
+		info->lcd_lvds_colordepth= value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_lvds_io_polarity", &value);
+	if (ret == 0) {
+		info->lcd_lvds_io_polarity = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_cpu_if", &value);
+	if (ret == 0) {
+		info->lcd_cpu_if = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_cpu_te", &value);
+	if (ret == 0) {
+		info->lcd_cpu_te = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_frm", &value);
+	if (ret == 0) {
+		info->lcd_frm = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_dsi_if", &value);
+	if (ret == 0) {
+		info->lcd_dsi_if = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_dsi_lane", &value);
+	if (ret == 0) {
+		info->lcd_dsi_lane = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_dsi_format", &value);
+	if (ret == 0) {
+		info->lcd_dsi_format = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_dsi_eotp", &value);
+	if (ret == 0) {
+		info->lcd_dsi_eotp = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_dsi_te", &value);
+	if (ret == 0) {
+		info->lcd_dsi_te = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_edp_rate", &value);
+	if (ret == 0) {
+		info->lcd_edp_rate = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_edp_lane", &value);
+	if (ret == 0) {
+		info->lcd_edp_lane= value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_edp_colordepth", &value);
+	if (ret == 0) {
+		info->lcd_edp_colordepth = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_edp_fps", &value);
+	if (ret == 0) {
+		info->lcd_edp_fps = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_hv_clk_phase", &value);
+	if (ret == 0) {
+		info->lcd_hv_clk_phase = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_hv_sync_polarity", &value);
+	if (ret == 0) {
+		info->lcd_hv_sync_polarity = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_hv_srgb_seq", &value);
+	if (ret == 0) {
+		info->lcd_hv_srgb_seq = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_rb_swap", &value);
+	if (ret == 0) {
+		info->lcd_rb_swap = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_hv_syuv_seq", &value);
+	if (ret == 0) {
+		info->lcd_hv_syuv_seq = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_hv_syuv_fdly", &value);
+	if (ret == 0) {
+		info->lcd_hv_syuv_fdly = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_gamma_en", &value);
+	if (ret == 0) {
+		info->lcd_gamma_en = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_cmap_en", &value);
+	if (ret == 0) {
+		info->lcd_cmap_en = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_xtal_freq", &value);
+	if (ret == 0) {
+		info->lcd_xtal_freq = value;
+	}
+
+	ret = sunxi_drm_get_sys_item_char(node, "lcd_size", (void*)info->lcd_size);
+	ret = sunxi_drm_get_sys_item_char(node, "lcd_model_name", (void*)info->lcd_model_name);
+
+	return 0;
+}
+
+int sunxi_lcd_gpio_init(disp_lcd_cfg *lcd_cfg)
+{
+	int i;
+	/* for use the gpio ctl the lcd panel,
+	* don't contain the lcd IO pin. 
+	*/
+	for (i = 0; i < LCD_GPIO_REGU_NUM; i++) {
+		if (!((!strcmp(lcd_cfg->lcd_gpio_power[i], "")) ||
+		(!strcmp(lcd_cfg->lcd_gpio_power[i], "none")))) {
+
+			sunxi_drm_sys_power_enable(lcd_cfg->lcd_gpio_power[i]);
+		}
+	}
+
+	for (i = 0; i < LCD_GPIO_NUM; i++) {
+		lcd_cfg->gpio_hdl[i] = 0;
+
+		if (lcd_cfg->lcd_gpio_used[i]) {
+			disp_gpio_set_t  gpio_info[1];
+
+			memcpy(gpio_info, &(lcd_cfg->lcd_gpio[i]), sizeof(disp_gpio_set_t));
+			lcd_cfg->gpio_hdl[i] = sunxi_drm_sys_gpio_request(gpio_info);
+		}
+	}
+
+	return 0;
+}
+
+static int sunxi_lcd_pin_enalbe(struct sunxi_lcd_private *sunxi_lcd)
+{
+	int  i;
+	char dev_name[25];
+	disp_lcd_cfg  *lcd_cfg = sunxi_lcd->lcd_cfg;
+	for (i = 0; i < LCD_GPIO_REGU_NUM; i++) {
+		if (!((!strcmp(lcd_cfg->lcd_pin_power[i], "")) ||
+		(!strcmp(lcd_cfg->lcd_pin_power[i], "none")))) {
+			sunxi_drm_sys_power_enable(lcd_cfg->lcd_pin_power[i]);
+		}
+	}
+
+	sprintf(dev_name, "lcd%d", sunxi_lcd->lcd_id);
+	sunxi_drm_sys_pin_set_state(dev_name, DISP_PIN_STATE_ACTIVE);
+
+	return 0;
+}
+
+static int sunxi_lcd_pin_disable(struct sunxi_lcd_private *sunxi_lcd)
+{
+	int  i;
+	char dev_name[25];
+	disp_lcd_cfg  *lcd_cfg = sunxi_lcd->lcd_cfg;
+
+	sprintf(dev_name, "lcd%d", sunxi_lcd->lcd_id);
+	sunxi_drm_sys_pin_set_state(dev_name, DISP_PIN_STATE_SLEEP);
+
+	if (LCD_IF_DSI ==  sunxi_lcd->panel->lcd_if) {
+#ifdef SUPPORT_DSI
+		dsi_io_close(sunxi_lcd->lcd_id);
+#endif
+	}
+
+	for (i = LCD_GPIO_REGU_NUM-1; i >= 0; i--) {
+		if (!((!strcmp(lcd_cfg->lcd_pin_power[i], "")) ||
+			(!strcmp(lcd_cfg->lcd_pin_power[i], "none")))){
+
+			sunxi_drm_sys_power_disable(lcd_cfg->lcd_pin_power[i]);
+		}
+	}
+
+	return 0;
+}
+
+int sunxi_pwm_dev_init(struct sunxi_lcd_private *sunxi_lcd)
+{
+	__u64 backlight_bright;
+	__u64 period_ns, duty_ns;
+	disp_panel_para  *panel_info = sunxi_lcd->panel;
+	struct pwm_info_t  *pwm_info;
+
+	if (panel_info->lcd_pwm_used) {
+		pwm_info = kzalloc(sizeof(struct pwm_info_t), GFP_KERNEL);
+		if (!pwm_info) {
+			DRM_ERROR("failed to alloc pwm_info.\n");
+			return -ENOMEM;
+		}
+
+		pwm_info->channel = panel_info->lcd_pwm_ch;
+		pwm_info->polarity = panel_info->lcd_pwm_pol;
+		pwm_info->pwm_dev = pwm_request(panel_info->lcd_pwm_ch, "lcd");
+
+		if (!pwm_info->pwm_dev) {
+			DRM_ERROR("failed to pwm_request pwm_dev.\n");
+			kfree(pwm_info);
+			return -ENOMEM;
+		}
+
+		if (panel_info->lcd_pwm_freq != 0) {
+			period_ns = 1000*1000*1000 / panel_info->lcd_pwm_freq;
+		} else {
+			DRM_INFO("lcd pwm use default Hz.\n");
+			period_ns = 1000*1000*1000 / 1000;  //default 1khz
+		}
+
+		backlight_bright = sunxi_lcd->lcd_cfg->backlight_bright;
+
+		duty_ns = (backlight_bright * period_ns) / 256;
+		pwm_set_polarity(pwm_info->pwm_dev, pwm_info->polarity);
+		pwm_info->duty_ns = duty_ns;
+		pwm_info->period_ns = period_ns;
+		sunxi_lcd->pwm_info = pwm_info;
+		DRM_DEBUG_KMS("[%d] %s %d", __LINE__, __func__,pwm_info->polarity);
+		DRM_DEBUG_KMS("duty_ns:%lld period_ns:%lld\n", duty_ns, period_ns);
+	}
+
+	return 0;
+}
+
+void sunxi_pwm_dev_destroy(struct pwm_info_t  *pwm_info)
+{
+	if (pwm_info) {
+		if (pwm_info->pwm_dev)
+			pwm_free(pwm_info->pwm_dev);
+		kfree(pwm_info);
+	}
+}
+
+int sunxi_common_pwm_set_bl(struct sunxi_lcd_private *sunxi_lcd, unsigned int bright)
+{
+	u32 duty_ns;
+	__u64 backlight_bright = bright;
+	__u64 backlight_dimming;
+	__u64 period_ns;
+	panel_extend_para *extend_panel;
+	disp_lcd_cfg  *lcd_cfg = sunxi_lcd->lcd_cfg;
+
+	extend_panel = sunxi_lcd->extend_panel;
+
+	if (sunxi_lcd->pwm_info->pwm_dev && extend_panel != NULL) {
+		if (backlight_bright != 0) {
+			backlight_bright += 1;
+		}
+		DRM_DEBUG_KMS("[%d] %s light:%d", __LINE__, __func__, bright);
+		bright = (bright > 255)? 255:bright;
+		backlight_bright = extend_panel->lcd_bright_curve_tbl[bright];
+
+		sunxi_lcd->lcd_cfg->backlight_dimming =
+			(0 == sunxi_lcd->lcd_cfg->backlight_dimming)? 256:sunxi_lcd->lcd_cfg->backlight_dimming;
+		backlight_dimming = sunxi_lcd->lcd_cfg->backlight_dimming;
+		period_ns = sunxi_lcd->pwm_info->period_ns;
+		duty_ns = (backlight_bright * backlight_dimming *  period_ns/256 + 128) / 256;
+		sunxi_lcd->pwm_info->duty_ns = duty_ns;
+		lcd_cfg->backlight_bright = bright;
+		DRM_DEBUG_KMS("bright:%d duty_ns:%d period_ns:%llu\n", bright, duty_ns, period_ns);
+
+		sunxi_drm_sys_pwm_config(sunxi_lcd->pwm_info->pwm_dev, duty_ns, period_ns);
+	}
+	return 0;
+}
+
+int sunxi_lcd_panel_ops_init(struct sunxi_panel *sunxi_panel)
+{
+	char primary_key[20];
+	int  ret;
+	char drv_name[20];
+	struct device_node *node;
+	struct sunxi_lcd_private *sunxi_lcd = sunxi_panel->private;
+
+	sprintf(primary_key, "sunxi-lcd%d", sunxi_lcd->lcd_id);
+	node = sunxi_drm_get_name_node(primary_key);
+
+	ret = sunxi_drm_get_sys_item_char(node, "lcd_driver_name", drv_name);
+	if (!strcmp(drv_name, "default_lcd")) {
+		sunxi_panel->panel_ops = &default_panel;
+		sunxi_panel->panel_ops->init(sunxi_panel);
+		return 0;
+	}
+
+	DRM_ERROR("failed to init sunxi_panel.\n");
+	return -EINVAL;
+}
+
+void sunxi_lcd_panel_ops_destroy(struct panel_ops  *panel_ops)
+{
+	return;
+}
+
+bool sunxi_fix_power_enable(disp_lcd_cfg  *lcd_cfg)
+{
+	int i;
+	for (i = 0; i < LCD_POWER_NUM; i++) {
+		if (1 == lcd_cfg->lcd_fix_power_used[i]) {
+			sunxi_drm_sys_power_enable(lcd_cfg->lcd_fix_power[i]);
+		}
+	}
+	return true;
+}
+
+bool sunxi_fix_power_disable(disp_lcd_cfg  *lcd_cfg)
+{
+	int i;
+	for (i = 0; i < LCD_POWER_NUM; i++) {
+		if (1 == lcd_cfg->lcd_fix_power_used[i]) {
+			sunxi_drm_sys_power_disable(lcd_cfg->lcd_fix_power[i]);
+		}
+	}
+	return true;
+}
+static int sunxi_gpio_request(disp_lcd_cfg  *lcd_cfg)
+{
+	int i;
+	disp_gpio_set_t  gpio_info[1];
+	for (i = 0; i < LCD_GPIO_REGU_NUM; i++) {
+		if (!((!strcmp(lcd_cfg->lcd_gpio_power[i], "")) ||
+			(!strcmp(lcd_cfg->lcd_gpio_power[i], "none")))) {
+			sunxi_drm_sys_power_enable(lcd_cfg->lcd_gpio_power[i]);
+		}
+	}
+
+	for (i = 0; i < LCD_GPIO_NUM; i++) {
+		lcd_cfg->gpio_hdl[i] = 0;
+
+		if (lcd_cfg->lcd_gpio_used[i]) {
+			memcpy(gpio_info, &(lcd_cfg->lcd_gpio[i]), sizeof(disp_gpio_set_t));
+			lcd_cfg->gpio_hdl[i] = sunxi_drm_sys_gpio_request(gpio_info);
+		}
+	}
+
+	return 0;
+}
+
+static int sunxi_gpio_release(disp_lcd_cfg  *lcd_cfg)
+{
+	int i;
+	for (i = 0; i < LCD_GPIO_NUM; i++) {
+		if (lcd_cfg->gpio_hdl[i]) {
+			disp_gpio_set_t  gpio_info[1];
+
+			sunxi_drm_sys_gpio_release(lcd_cfg->gpio_hdl[i]);
+
+			memcpy(gpio_info, &(lcd_cfg->lcd_gpio[i]), sizeof(disp_gpio_set_t));
+			gpio_info->mul_sel = 7;
+			lcd_cfg->gpio_hdl[i] = sunxi_drm_sys_gpio_request(gpio_info);
+			sunxi_drm_sys_gpio_release(lcd_cfg->gpio_hdl[i]);
+			lcd_cfg->gpio_hdl[i] = 0;
+		}
+	}
+
+	for (i = LCD_GPIO_REGU_NUM-1; i >= 0; i--) {
+		if (!((!strcmp(lcd_cfg->lcd_gpio_power[i], "")) ||
+			(!strcmp(lcd_cfg->lcd_gpio_power[i], "none")))) {
+			sunxi_drm_sys_power_disable(lcd_cfg->lcd_gpio_power[i]);
+		}
+	}
+
+	return 0;
+}
+
+bool sunxi_common_enable(void *data)
+{
+	struct sunxi_drm_connector *sunxi_connector;
+	struct sunxi_hardware_res *hw_res;
+	struct sunxi_panel *sunxi_panel;
+	struct panel_ops *panel_ops;
+	disp_lcd_cfg   *lcd_cfg;
+	struct sunxi_lcd_private *sunxi_lcd;
+
+	sunxi_connector = to_sunxi_connector(data);
+	hw_res = sunxi_connector->hw_res;
+	sunxi_panel = sunxi_connector->panel;
+	sunxi_lcd = sunxi_panel->private;
+	panel_ops = sunxi_panel->panel_ops;
+	lcd_cfg = sunxi_lcd->lcd_cfg;
+
+	sunxi_fix_power_enable(lcd_cfg);
+	sunxi_gpio_request(lcd_cfg);
+	sunxi_lcd_pin_enalbe(sunxi_lcd);
+	panel_ops->open(sunxi_panel);
+
+	panel_ops->bright_light(sunxi_panel, lcd_cfg->lcd_bright);
+	return true;
+}
+
+bool sunxi_common_disable(void *data)
+{
+	struct sunxi_drm_connector *sunxi_connector;
+	struct sunxi_hardware_res *hw_res;
+	struct sunxi_panel *sunxi_panel;
+	struct panel_ops *panel_ops;
+	disp_lcd_cfg      *lcd_cfg;
+	struct sunxi_lcd_private *sunxi_lcd;
+
+	sunxi_connector = to_sunxi_connector(data);
+	hw_res = sunxi_connector->hw_res;
+	sunxi_panel = sunxi_connector->panel;
+	sunxi_lcd = sunxi_panel->private;
+	panel_ops = sunxi_panel->panel_ops;
+	lcd_cfg = sunxi_lcd->lcd_cfg;
+
+	sunxi_irq_free(hw_res);
+
+	sunxi_lcd_extern_backlight_disable(sunxi_lcd);
+	sunxi_drm_sys_pwm_disable(sunxi_lcd->pwm_info);
+	panel_ops->close(sunxi_panel);
+	sunxi_lcd_pin_disable(sunxi_lcd);
+	sunxi_clk_disable(hw_res);
+	sunxi_gpio_release(lcd_cfg);
+	sunxi_fix_power_disable(lcd_cfg);
+	return true;
+}
+
+#ifdef SUPPORT_DSI
+bool sunxi_dsi_irq_query(void *data, int need_irq)
+{
+#ifdef CONFIG_ARCH_SUN8IW11
+	enum __dsi_irq_id_t id;
+#endif
+#ifdef CONFIG_ARCH_SUN50IW1P1
+	__dsi_irq_id_t id;
+#endif
+
+	switch (need_irq) {
+	case QUERY_VSYNC_IRQ:
+		id = DSI_IRQ_VIDEO_VBLK;
+		break;
+	default:
+		return false;
+	}
+	/* bug for sunxi_connector->connector_id */
+	if(dsi_irq_query(0, id))
+		return true;
+
+	return false;
+}
+
+bool sunxi_dsi_init(void *data)
+{
+	struct sunxi_panel *sunxi_panel;
+	struct sunxi_lcd_private *sunxi_lcd;
+	struct sunxi_drm_connector *sunxi_connector =
+	to_sunxi_connector(data);
+
+	sunxi_panel = sunxi_connector->panel;
+	sunxi_lcd = (struct sunxi_lcd_private *)sunxi_panel->private;
+	sunxi_connector->hw_res->clk_rate = sunxi_panel->clk_rate 
+				* sunxi_lcd->clk_info->lcd_div;
+
+	return true;
+}
+
+#endif
+
+bool sunxi_lvds_init(void *data)
+{
+	return true;
+}
+
+bool sunxi_lvds_reset(void *data)
+{
+	struct drm_connector *connector = (struct drm_connector *)data;
+	struct sunxi_drm_connector *sunxi_connector =
+			to_sunxi_connector(data);
+	struct sunxi_drm_encoder *sunxi_encoder;
+	struct sunxi_drm_crtc *sunxi_crtc;
+	if (!connector || !connector->encoder ||
+		!connector->encoder->crtc) {
+		return false;
+	}
+	sunxi_encoder = to_sunxi_encoder(connector->encoder);
+	sunxi_crtc = to_sunxi_crtc(connector->encoder->crtc);
+	sunxi_clk_enable(sunxi_connector->hw_res);
+
+	return true;
+}
+
+
+#ifdef SUPPORT_DSI
+bool sunxi_dsi_reset(void *data)
+{
+	struct drm_connector *connector = (struct drm_connector *)data;
+	struct sunxi_drm_connector *sunxi_connector =
+	to_sunxi_connector(data);
+	struct sunxi_drm_encoder *sunxi_encoder;
+	struct sunxi_drm_crtc *sunxi_crtc;
+	struct sunxi_lcd_private *sunxi_lcd;
+
+	if (!connector || !connector->encoder ||
+		!connector->encoder->crtc) {
+		return false;
+	}
+	sunxi_lcd = (struct sunxi_lcd_private *)sunxi_connector->panel->private;
+	sunxi_encoder = to_sunxi_encoder(connector->encoder);
+	sunxi_crtc = to_sunxi_crtc(connector->encoder->crtc);
+	sunxi_clk_set(sunxi_connector->hw_res);
+	sunxi_irq_free(sunxi_crtc->hw_res);
+	sunxi_irq_free(sunxi_encoder->hw_res);
+	sunxi_irq_request(sunxi_connector->hw_res);
+	/* after enable the tcon ,THK ok?*/
+	sunxi_clk_enable(sunxi_connector->hw_res);
+	dsi_cfg(sunxi_lcd->lcd_id, sunxi_lcd->panel);
+	return true;
+}
+
+static struct sunxi_hardware_ops dsi_con_ops = {
+	.init = sunxi_dsi_init,
+	.reset = sunxi_dsi_reset,
+	.enable = sunxi_common_enable,
+	.disable = sunxi_common_disable,
+	.updata_reg = NULL,
+	.vsync_proc = NULL,
+	.irq_query = sunxi_dsi_irq_query,
+	.vsync_delayed_do = NULL,
+	.set_timming = NULL,
+};
+#endif
+
+static struct sunxi_hardware_ops edp_con_ops = {
+	.reset = NULL,
+	.enable = NULL,
+	.disable = NULL,
+	.updata_reg = NULL,
+	.vsync_proc = NULL,
+	.vsync_delayed_do = NULL,
+};
+
+static struct sunxi_hardware_ops lvds_con_ops = {
+	.init = sunxi_lvds_init,
+	.reset = sunxi_lvds_reset,
+	.enable = sunxi_common_enable,
+	.disable = sunxi_common_disable,
+	.updata_reg = NULL,
+	.vsync_proc = NULL,
+	.irq_query = NULL, 
+	.vsync_delayed_do = NULL,
+};
+
+static struct sunxi_hardware_ops hv_con_ops = {
+	.reset = NULL,
+	.enable = NULL,
+	.disable = NULL,
+	.updata_reg = NULL,
+	.vsync_proc = NULL,
+	.vsync_delayed_do = NULL,
+};
+
+static struct sunxi_hardware_ops cpu_con_ops = {
+	.reset = NULL,
+	.enable = NULL,
+	.disable = NULL,
+	.updata_reg = NULL,
+	.vsync_proc = NULL,
+	.vsync_delayed_do = NULL,
+};
+
+static struct sunxi_hardware_ops edsi_con_ops = {
+	.reset = NULL,
+	.enable = NULL,
+	.disable = NULL,
+	.updata_reg = NULL,
+	.vsync_proc = NULL,
+	.vsync_delayed_do = NULL,
+};
+
+static int sunxi_lcd_hwres_ops_init(struct sunxi_hardware_res *hw_res, int type)
+{
+	switch (type) {
+	case LCD_IF_HV:
+		hw_res->ops = &hv_con_ops;
+		break;
+	case LCD_IF_CPU:
+		hw_res->ops = &cpu_con_ops;
+		break;
+	case LCD_IF_LVDS:
+		hw_res->ops = &lvds_con_ops;
+		break;
+#ifdef SUPPORT_DSI
+	case LCD_IF_DSI:
+		hw_res->ops = &dsi_con_ops;
+		break;
+#endif
+	case LCD_IF_EDP:
+		hw_res->ops = &edp_con_ops;
+		break;
+	case LCD_IF_EXT_DSI:
+		hw_res->ops = &edsi_con_ops;
+		break;
+	default:
+		DRM_ERROR("give us an err hw_res.\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void sunxi_lcd_hwres_ops_destroy(struct sunxi_hardware_res *hw_res)
+{
+	hw_res->ops = NULL;
+}
+
+bool sunxi_cmp_panel_type(disp_mod_id res_id, int type)
+{
+	/* TODO for  DISP_MOD_EINK HDMI */
+	/* 0:hv(sync+de); 1:8080; 2:ttl; 3:lvds; 4:dsi; 5:edp */
+	switch ((int)(res_id)) {
+	case DISP_MOD_DSI0:
+		if (type == 4)
+			return true;
+		break;
+	case DISP_MOD_DSI1:
+		if (type == 4)
+			return true;
+		break;
+		/* for :0:hv(sync+de); 1:8080; 2:ttl; */
+	case DISP_MOD_DSI2:
+		if (type < 3)
+			return true;
+		break;
+	case DISP_MOD_HDMI:
+		if (type == 7)
+			return true;
+		break;
+	case DISP_MOD_LVDS:
+		if (type == 3)
+			return true;
+		break;
+
+	default:
+		DRM_ERROR("[%s][%s]get a err lcd type.\n", __FILE__,__func__);
+	}
+
+	return false;
+}
+
+int sunxi_lcd_private_init(struct sunxi_panel *sunxi_panel, int lcd_id)
+{
+	struct sunxi_lcd_private *sunxi_lcd_p;
+	sunxi_lcd_p = kzalloc(sizeof( struct sunxi_lcd_private), GFP_KERNEL);
+	if (!sunxi_lcd_p) {
+		DRM_ERROR("failed to allocate sunxi_lcd_p.\n");
+		return -EINVAL;
+	}
+	sunxi_panel->private = sunxi_lcd_p;
+
+	sunxi_lcd_p->lcd_cfg = kzalloc(sizeof(disp_lcd_cfg), GFP_KERNEL);
+	if(!sunxi_lcd_p->lcd_cfg) {
+		DRM_ERROR("failed to allocate lcd_cfg.\n"); 
+		goto lcd_err;
+	}
+
+	sunxi_lcd_p->extend_panel = kzalloc(sizeof(panel_extend_para), GFP_KERNEL);
+	if (!sunxi_lcd_p->extend_panel) {
+		DRM_ERROR("failed to allocate extend_panel.\n"); 
+		goto lcd_err;
+	}
+
+	sunxi_lcd_p->panel = kzalloc(sizeof(disp_panel_para), GFP_KERNEL);
+	if (!sunxi_lcd_p->panel) {
+		DRM_ERROR("failed to allocate panel.\n"); 
+		goto lcd_err;
+	}
+
+	sunxi_lcd_p->lcd_id = lcd_id;
+	sunxi_get_lcd_sys_info(sunxi_lcd_p);
+	if(sunxi_pwm_dev_init(sunxi_lcd_p))
+		goto lcd_err;
+
+	return 0;
+
+lcd_err:
+	if (sunxi_lcd_p->panel)
+		kfree(sunxi_lcd_p->panel);
+	if (sunxi_lcd_p->extend_panel)
+		kfree(sunxi_lcd_p->extend_panel);
+	if (sunxi_lcd_p->lcd_cfg)
+		kfree(sunxi_lcd_p->lcd_cfg);
+	return -EINVAL;
+}
+
+void sunxi_lcd_private_destroy(struct sunxi_lcd_private *sunxi_lcd_p)
+{
+	if (sunxi_lcd_p->panel)
+		kfree(sunxi_lcd_p->panel);
+	if (sunxi_lcd_p->extend_panel);
+		kfree(sunxi_lcd_p->extend_panel);
+	if (sunxi_lcd_p->lcd_cfg)
+		kfree(sunxi_lcd_p->lcd_cfg);
+	sunxi_pwm_dev_destroy(sunxi_lcd_p->pwm_info);
+	kfree(sunxi_lcd_p);
+}
+
+struct sunxi_panel *sunxi_lcd_init(struct sunxi_hardware_res *hw_res, int panel_id, int lcd_id)
+{
+	char primary_key[20];
+	int value,ret;
+	struct sunxi_panel *sunxi_panel = NULL;
+	struct device_node *node;
+
+	sprintf(primary_key, "sunxi-lcd%d", lcd_id);
+	node = sunxi_drm_get_name_node(primary_key);
+	if (!node) {
+		DRM_ERROR("get device [%s] node fail.\n", primary_key);
+		return NULL;
+	}
+
+	ret = sunxi_drm_get_sys_item_int(node, "lcd_used", &value);
+	if (ret == 0) {
+		if (value == 1) {
+			ret = sunxi_drm_get_sys_item_int(node, "lcd_if", &value);
+			if (ret == 0) {
+				if (!sunxi_cmp_panel_type(hw_res->res_id, value)) {
+					goto err_false;
+				}
+
+				sunxi_panel = sunxi_panel_creat(DISP_OUTPUT_TYPE_LCD, panel_id);
+				if (!sunxi_panel) {
+					DRM_ERROR("creat sunxi panel fail.\n");
+					goto err_false;
+				}
+
+				ret = sunxi_lcd_private_init(sunxi_panel, lcd_id);
+				if (ret) {
+					DRM_ERROR("creat lcd_private fail.\n");
+					goto err_panel;
+				}
+
+				ret = sunxi_lcd_hwres_ops_init(hw_res, value);
+				if (ret) {
+					DRM_ERROR("creat hwres_ops fail.\n");
+					goto err_pravate;
+				} 
+
+				ret = sunxi_lcd_panel_ops_init(sunxi_panel);
+				if (ret) {
+					DRM_ERROR("creat panel_ops fail.\n");
+					goto err_ops;
+				}
+			}
+		}
+	}
+
+	return sunxi_panel;
+
+err_ops:
+	sunxi_lcd_hwres_ops_destroy(hw_res);
+err_pravate:
+	sunxi_lcd_private_destroy(sunxi_panel->private);
+err_panel:
+	if(sunxi_panel)
+	sunxi_panel_destroy(sunxi_panel);
+err_false:
+	return NULL;
+}
+
+void sunxi_lcd_destroy(struct sunxi_panel *sunxi_panel,
+	struct sunxi_hardware_res *hw_res)
+{
+	if(sunxi_panel) {
+		sunxi_lcd_hwres_ops_destroy(hw_res);
+		sunxi_lcd_private_destroy(sunxi_panel->private);
+	}
+	return ;
+}
diff --git a/drivers/gpu/drm/sunxi/subdev/sunxi_lcd.h b/drivers/gpu/drm/sunxi/subdev/sunxi_lcd.h
new file mode 100755
index 0000000..c8b0d6d
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/subdev/sunxi_lcd.h
@@ -0,0 +1,39 @@
+ /*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+/*LCD panel ops*/
+#ifndef _SUNXI_LCD_H_
+#define _SUNXI_LCD_H_
+
+#include "sunxi_drm_panel.h"
+#include "sunxi_drm_core.h"
+
+struct sunxi_lcd_private {
+	int   lcd_id;
+	struct sunxi_panel *sunxi_panel;
+	disp_panel_para  *panel;
+	panel_extend_para  *extend_panel;
+	struct lcd_clk_info  *clk_info;
+	struct pwm_info_t *pwm_info;
+	disp_lcd_cfg  *lcd_cfg;
+	bool      bl_enalbe;
+	bool      ex_power_on;
+};
+
+int sunxi_get_lcd_sys_info(struct sunxi_lcd_private *sunxi_lcd);
+
+int sunxi_pwm_dev_init(struct sunxi_lcd_private *sunxi_lcd);
+
+void sunxi_lcd_destroy(struct sunxi_panel *sunxi_panel,
+	struct sunxi_hardware_res *hw_res);
+
+int sunxi_common_pwm_set_bl(struct sunxi_lcd_private *sunxi_lcd, unsigned int bright);
+
+#endif
diff --git a/drivers/gpu/drm/sunxi/subdev/sunxi_rotate.c b/drivers/gpu/drm/sunxi/subdev/sunxi_rotate.c
new file mode 100755
index 0000000..a90af57
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/subdev/sunxi_rotate.c
@@ -0,0 +1,561 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/kref.h>
+#include "../sunxi_drm_core.h"
+#include "../sunxi_drm_gem.h"
+#include "../drm_de/drm_al.h"
+#include "sunxi_common.h"
+#include "transform.h"
+#include "sunxi_rotate.h"
+#include "drm/sunxi_drm.h"
+#include "sunxi_drm_drv.h"
+
+static irqreturn_t sunxi_rotate_interrupt(int irq, void *dev_id);
+void sunxi_rotate_daemon(struct work_struct *work);
+void sunxi_schedule_process(struct sunxi_rotate_private *rotate_private);
+
+int sunxi_drm_rotate_init(void *dev_private)
+{
+	int ret;
+	void __iomem *io_base;
+	int irq;
+	struct device_node *node;
+	struct sunxi_drm_private *private;
+	struct sunxi_rotate_private *rotate_private;
+
+return 0;
+	node = sunxi_drm_get_name_node("sun50i-tr");
+	if(node == NULL) {
+		DRM_ERROR("rotate get device node error.\n");
+		return -EINVAL;
+	}
+
+	io_base = of_iomap(node, 0);
+	if(io_base == NULL) {
+		DRM_ERROR("rotate get addr error.\n");
+		return -EINVAL;
+	}
+
+	irq = irq_of_parse_and_map(node, 0);
+	if(irq == 0) {
+		DRM_ERROR("rotate get irq error.\n");
+		return -EINVAL;
+	}
+
+	private = (struct sunxi_drm_private *)dev_private;
+	rotate_private = kzalloc(sizeof(struct sunxi_rotate_private), GFP_KERNEL);
+	if(!rotate_private) {
+		DRM_ERROR("rotate kzalloc private data error.\n");
+		return -EINVAL;
+	}
+	rotate_private->clk = of_clk_get(node, 0);
+	if (IS_ERR(rotate_private->clk)) {
+		DRM_ERROR("rotate get clk error.\n");
+		return -EINVAL;
+	}
+	rotate_private->irq = irq;
+	INIT_LIST_HEAD(&rotate_private->rotate_work);
+	INIT_LIST_HEAD(&rotate_private->qurey_head);
+	mutex_init(&rotate_private->qurey_mlock);
+	mutex_init(&rotate_private->user_mlock);
+	spin_lock_init(&rotate_private->head_lock);
+	spin_lock_init(&rotate_private->process_lock);
+	init_waitqueue_head(&rotate_private->task_wq);
+	rotate_private->used_cnt = 0;
+	idr_init(&rotate_private->user_idr);
+	rotate_private->current_task = NULL;
+
+	de_tr_set_base((uintptr_t)io_base);
+	ret = request_irq(irq, sunxi_rotate_interrupt, IRQF_SHARED,
+	"drm_rotate", rotate_private);
+	//tasklet_init(&rotate_private->rotate, sunxi_drm_soft_irq_handle, (unsigned long)(rotate_private));
+	INIT_DELAYED_WORK(&rotate_private->daemon_work, sunxi_rotate_daemon);
+	rotate_private->active =  ROTATE_IN_IDLE;
+	private->rotate_private = rotate_private;
+
+	return 0;
+}
+
+int sunxi_drm_rotate_destroy(struct sunxi_rotate_private *rotate_private)
+{
+	mutex_lock(&rotate_private->user_mlock);
+	if(rotate_private->irq != 0)
+		free_irq(rotate_private->irq, sunxi_rotate_interrupt);
+	if(rotate_private->clk)
+		clk_disable(rotate_private->clk);
+	mutex_unlock(&rotate_private->qurey_mlock);
+	kfree(rotate_private);
+	return 0;
+}
+
+void rotate_task_free(struct kref *kref)
+{
+	struct sunxi_rotate_task *task;
+	task = container_of(kref, struct sunxi_rotate_task, refcount);
+	if(task)
+		kfree(task);
+}
+
+void sunxi_rotate_daemon(struct work_struct *work)
+{
+	struct delayed_work *delay_work;
+	struct sunxi_rotate_private *rotate_private;
+
+	delay_work = to_delayed_work(work);
+	rotate_private = to_sunxi_rotate_priv(delay_work);
+	if (!rotate_private->current_task
+	|| rotate_private->used_cnt == 0)
+	return;
+
+	spin_lock(&rotate_private->process_lock);
+	if (rotate_private->active == ROTAE_IN_BAD) {
+		de_tr_reset();
+		/* becareful for  */
+		rotate_private->active = ROTATE_IN_IDLE;
+		if (rotate_private->current_task)
+			rotate_private->current_task->status = ROTATE_ERROR;
+		spin_unlock(&rotate_private->process_lock);
+		sunxi_schedule_process(rotate_private);
+		return;
+	}
+
+	if (rotate_private->active == ROTATE_IN_WORK) {
+		rotate_private->active = ROTAE_IN_BAD;
+		spin_unlock(&rotate_private->process_lock);
+
+		schedule_delayed_work(delay_work, ROTATE_DAEMON_HZ);
+		return;
+	}
+	spin_unlock(&rotate_private->process_lock);
+
+}
+
+void sunxi_schedule_process(struct sunxi_rotate_private *rotate_private)
+{
+	struct sunxi_rotate_task *task_work = NULL;
+
+	spin_lock(&rotate_private->process_lock);
+	if (rotate_private->active > ROTATE_IN_IDLE) {
+		spin_unlock(&rotate_private->process_lock);
+		return;
+	}
+	rotate_private->active = ROTATE_IN_WORK;
+	spin_unlock(&rotate_private->process_lock);
+
+	cancel_delayed_work(&rotate_private->daemon_work);
+	spin_lock(&rotate_private->head_lock);
+	if (rotate_private->rotate_work.next != &rotate_private->rotate_work) {
+		task_work = to_sunxi_rotate_w(rotate_private->rotate_work.next);
+		list_del(&task_work->w_head);
+		kref_get(&task_work->refcount);
+		rotate_private->current_task = task_work;
+	}
+	spin_unlock(&rotate_private->head_lock);
+
+	if(task_work) {
+		task_work->status = ROTATE_BUSY;
+		de_tr_set_cfg(&task_work->info);
+	}else{
+		rotate_private->active = ROTATE_IN_IDLE;
+	}
+}
+
+static irqreturn_t sunxi_rotate_interrupt(int irq, void *dev_id)
+{
+	int ret = 0;
+	struct sunxi_rotate_private *rotate_private;
+	rotate_private = (struct sunxi_rotate_private *)dev_id;
+
+	ret = de_tr_irq_query();
+	if(0 == ret) {
+		rotate_private->active = ROTATE_IN_FINISH;
+		if (rotate_private->current_task) {
+			rotate_private->current_task->status = ROTATE_OK;
+			DRM_DEBUG_KMS("int rotate irq  %p\n", rotate_private->current_task);
+			if(rotate_private->current_task->sleep_mode) {
+				wake_up_all(&rotate_private->task_wq);
+			}
+			kref_put(&rotate_private->current_task->refcount, rotate_task_free);
+			rotate_private->current_task = NULL;
+		}
+		rotate_private->active = ROTATE_IN_IDLE;
+		sunxi_schedule_process(rotate_private);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static inline int sunxi_check_access(struct sunxi_rotate_private *rotate_private,
+        struct sunxi_rotate_cmd *rotate_cmd, struct drm_file *file_priv)
+{
+	void *handle;
+	mutex_lock(&rotate_private->user_mlock);
+	handle = idr_find(&rotate_private->user_idr, rotate_cmd->handle);
+	mutex_unlock(&rotate_private->user_mlock);
+	if(handle != (void*)file_priv) {
+		DRM_ERROR("Gived id is not your's or not a rotate id\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static bool sunxi_check_rotate_info_ok(struct drm_device *dev,
+	struct sunxi_rotate_info  *rotate_info, 
+	struct sunxi_rotate_task *task_work, struct drm_file *file_priv)
+{
+	struct sunxi_drm_gem_buf *gem_buf;
+	struct drm_gem_object *sunxi_gem;
+	tr_info *tr_info;
+	tr_info = &task_work->info;
+
+	sunxi_gem = drm_gem_object_lookup(dev, file_priv, rotate_info->dst_gem_handle);
+	if (!sunxi_gem) {
+		return false;
+	}
+
+	drm_gem_object_unreference(sunxi_gem);
+
+	if (!sunxi_check_gem_memory_type(sunxi_gem, SUNXI_BO_CONTIG)) {
+		DRM_ERROR("not a contig  mem 1\n");
+		return false;
+	}
+
+	gem_buf = (struct sunxi_drm_gem_buf *)sunxi_gem->driver_private;
+	tr_info->dst_frame.laddr[0] = gem_buf->dma_addr;
+	tr_info->dst_frame.haddr[0] = (gem_buf->dma_addr>>32);
+	sunxi_sync_buf(gem_buf);
+
+	sunxi_gem = drm_gem_object_lookup(dev, file_priv, rotate_info->src_gem_handle);
+	if (!sunxi_gem) {
+		return false;
+	}
+
+	drm_gem_object_unreference(sunxi_gem);
+
+	if (!sunxi_check_gem_memory_type(sunxi_gem, SUNXI_BO_CONTIG)) {
+		DRM_ERROR("not a contig  mem 2\n");
+		return false;
+	}
+
+	gem_buf = (struct sunxi_drm_gem_buf *)sunxi_gem->driver_private;
+	sunxi_sync_buf(gem_buf);
+	tr_info->src_frame.laddr[0] = gem_buf->dma_addr;
+	tr_info->src_frame.haddr[0] = (gem_buf->dma_addr>>32);
+	DRM_DEBUG_KMS("from addr:  %02x%08x  size%lu\n", tr_info->src_frame.haddr[0], tr_info->src_frame.laddr[0], gem_buf->size);
+	DRM_DEBUG_KMS("to   addr:  %02x%08x\n", tr_info->dst_frame.haddr[0], tr_info->dst_frame.laddr[0]);
+
+	if((rotate_info->pitch * 8)/rotate_info->bpp%16) {
+		DRM_ERROR("1 pitch: %d bpp:%d\n", rotate_info->pitch, rotate_info->bpp);
+		return false;
+	}
+	if((rotate_info->pitch * 8)%rotate_info->bpp) {
+		DRM_ERROR("2 pitch: %d bpp:%d\n", rotate_info->pitch, rotate_info->bpp);
+		return false;
+	}
+
+	return true;
+}
+
+int sunxi_rotate_transform(struct drm_device *dev, struct sunxi_rotate_info *rotate_info,
+	struct sunxi_rotate_task *task_work, struct drm_file *file_priv)
+{
+	tr_info *tr_info;
+
+	if (!sunxi_check_rotate_info_ok(dev, rotate_info, task_work, file_priv))
+		goto out; 
+
+	tr_info = &task_work->info;
+	switch(rotate_info->depth) {
+	case 32:
+		tr_info->dst_frame.fmt = TR_FORMAT_ARGB_8888;
+		tr_info->src_frame.fmt = TR_FORMAT_ARGB_8888;
+		break;
+	case 15:
+		if (rotate_info->bpp == 16) {
+			tr_info->dst_frame.fmt = TR_FORMAT_ABGR_1555;
+			tr_info->src_frame.fmt = TR_FORMAT_ABGR_1555; 
+		}else{
+			goto out;
+		}
+		break;
+	case 24:
+		if (rotate_info->bpp == 32) {
+			tr_info->dst_frame.fmt = TR_FORMAT_XRGB_8888;
+			tr_info->src_frame.fmt = TR_FORMAT_XRGB_8888; 
+		}else{
+			goto out;
+		}
+		break;
+	case 16:
+		tr_info->dst_frame.fmt = TR_FORMAT_RGB_565;
+		tr_info->src_frame.fmt = TR_FORMAT_RGB_565; 
+		break;
+	default:
+		goto out;
+
+	}
+	/* tmp just support memory copy for drm,
+	* hardware not support crop
+	*/
+	tr_info->mode = rotate_info->mode;
+	tr_info->src_frame.pitch[0] = rotate_info->pitch/rotate_info->bpp*8;
+	tr_info->dst_frame.pitch[0] = rotate_info->pitch/rotate_info->bpp*8;
+	tr_info->src_frame.height[0] = rotate_info->height;
+	tr_info->dst_frame.height[0] = rotate_info->height;
+	tr_info->src_rect.x = 0;
+	tr_info->src_rect.y = 0;
+	tr_info->src_rect.w = rotate_info->width;
+	tr_info->src_rect.h = rotate_info->height;
+	tr_info->dst_rect.x = 0;
+	tr_info->dst_rect.y = 0;
+	tr_info->dst_rect.w = rotate_info->width;
+	tr_info->dst_rect.h = rotate_info->height;
+	DRM_DEBUG_KMS("3 wh: %dx%d  format:%d  mode:%d\n", rotate_info->width,
+			rotate_info->height,tr_info->dst_frame.fmt,tr_info->mode);
+
+	task_work->sleep_mode = rotate_info->sleep_mode;
+	task_work->timeout = rotate_info->set_time;
+	return 0;
+out:
+
+	return -EINVAL;   
+}
+
+void sunxi_add_process_head(struct sunxi_rotate_private *rotate_private,
+	struct sunxi_rotate_task *work)
+{
+	struct sunxi_rotate_task *del_work;
+
+	work->status = ROTAE_NO_START;
+	kref_init(&work->refcount);
+	spin_lock(&rotate_private->head_lock);
+	list_add_tail(&work->w_head, &rotate_private->rotate_work);
+	spin_unlock(&rotate_private->head_lock);
+
+	if (!work->sleep_mode) {
+		work->timeout += jiffies;
+		mutex_lock(&rotate_private->qurey_mlock);
+		list_add_tail(&work->q_head, &rotate_private->qurey_head);
+		rotate_private->query_cnt++;
+		while(rotate_private->query_cnt-- > 10) {
+			list_del(rotate_private->qurey_head.prev);
+			del_work = to_sunxi_rotate_q(rotate_private->qurey_head.next);
+			DRM_INFO("query head has upflow. del the old work id:%lu\n", (unsigned long)del_work);
+
+			spin_lock(&rotate_private->head_lock);
+			if (del_work->w_head.next != LIST_POISON1)
+			list_del(&del_work->w_head);
+			spin_unlock(&rotate_private->head_lock);
+			kref_put(&del_work->refcount, rotate_task_free);
+		}
+		mutex_unlock(&rotate_private->qurey_mlock);
+	}
+	sunxi_schedule_process(rotate_private);
+}
+
+int sunxi_rotate_commit(struct drm_device *dev, struct sunxi_rotate_private *rotate_private,
+	struct sunxi_rotate_cmd *rotate_cmd, struct drm_file *file_priv)
+{
+	int ret;
+	struct sunxi_rotate_task *task_work;
+	struct sunxi_rotate_info rotate_info;
+
+	if (sunxi_check_access(rotate_private, rotate_cmd, file_priv)) {
+		goto out;
+	}
+
+	if (copy_from_user(&rotate_info, (void __user *)rotate_cmd->private,
+	sizeof(struct sunxi_rotate_info)) != 0) {
+		DRM_ERROR("copy_from_user rotate_info error.\n");
+		goto out;
+	}
+
+	task_work = kzalloc(sizeof(struct sunxi_rotate_task), GFP_KERNEL);
+	if (!task_work) {
+		DRM_ERROR("kzalloc rotate task_work error.\n");
+		goto out;
+	}
+	ret = sunxi_rotate_transform(dev, &rotate_info, task_work, file_priv);
+	if(ret) {
+		DRM_ERROR("transform rotate data error.\n");
+		goto out;
+	}
+	sunxi_add_process_head(rotate_private, task_work);
+	if (task_work->sleep_mode) {
+		wait_event_interruptible_timeout(rotate_private->task_wq,
+		task_work->status == ROTATE_OK, msecs_to_jiffies(task_work->timeout));
+
+		DRM_DEBUG_KMS("staus:%d  %p  %p\n", task_work->status, task_work, rotate_private->current_task);
+		put_user(task_work->status, (int *)rotate_cmd->private);
+
+		spin_lock(&rotate_private->head_lock);
+		if (task_work->w_head.next != LIST_POISON1)
+			list_del(&task_work->w_head);
+		spin_unlock(&rotate_private->head_lock);
+		kref_put(&task_work->refcount, rotate_task_free);
+
+	}
+	return 0;
+out:
+	if(task_work)
+		kfree(task_work);
+	return -EINVAL; 
+}
+
+struct sunxi_rotate_task *sunxi_rotate_find_id(struct sunxi_rotate_private *rotate_private,
+        struct sunxi_rotate_task *need_id)
+{
+	struct list_head *pos;
+	struct list_head *n;
+	struct sunxi_rotate_task *find = NULL;
+
+	list_for_each_safe(pos, n, &rotate_private->qurey_head) {
+		find = to_sunxi_rotate_q(pos);
+		if(find == need_id)
+			break;
+			find = NULL;
+	}
+
+	if (find == NULL) {
+		DRM_ERROR("no-query type work or a bad work or has queryed\n");
+	}
+	return find;
+}
+
+int sunxi_rotate_query(struct sunxi_rotate_private *rotate_private,
+    struct sunxi_rotate_cmd *rotate_cmd, struct drm_file *file_priv)
+{
+	int ret = -1;
+	struct sunxi_rotate_task *query_hanle = NULL;
+
+	if (sunxi_check_access(rotate_private, rotate_cmd, file_priv)) {
+		goto out;
+	}
+	mutex_lock(&rotate_private->qurey_mlock);
+
+	query_hanle = sunxi_rotate_find_id(rotate_private, rotate_cmd->private);
+	if (query_hanle) {
+		ret = query_hanle->status;
+
+		if (time_after_eq(jiffies, query_hanle->timeout)) {
+			spin_lock(&rotate_private->head_lock);
+			if(query_hanle->w_head.next != LIST_POISON1){
+				list_del(&query_hanle->w_head);
+			}
+			spin_unlock(&rotate_private->head_lock);
+
+			list_del(&query_hanle->q_head);
+			kref_put(&query_hanle->refcount, rotate_task_free);
+		}
+	}
+
+	mutex_unlock(&rotate_private->qurey_mlock);
+
+	put_user(ret, (int *)rotate_cmd->private);
+
+	return 0;
+out:
+	return -EINVAL;
+}
+
+int sunxi_rotate_aquire(struct sunxi_rotate_private *rotate_private,
+        struct sunxi_rotate_cmd *rotate_cmd, struct drm_file *file_priv)
+{
+	int ret;
+
+	mutex_lock(&rotate_private->user_mlock);
+	ret = idr_alloc(&rotate_private->user_idr, file_priv, 1, 0, GFP_KERNEL);
+	rotate_private->used_cnt++;
+	if(ret < 0) {
+		DRM_ERROR("rotate aquire error %d.\n", ret);
+		return -EINVAL;
+	}
+
+	if (rotate_private->used_cnt == 1) {
+		if (rotate_private->clk)
+			clk_prepare_enable(rotate_private->clk);
+		de_tr_init();
+	}
+
+	mutex_unlock(&rotate_private->user_mlock);
+	put_user(ret, (int *)rotate_cmd->private);
+
+	return 0;
+}
+
+int sunxi_rotate_release(struct sunxi_rotate_private *rotate_private,
+        int id, struct drm_file *file_priv)
+{
+	int ret = 0;
+	void *handle;
+
+	mutex_lock(&rotate_private->user_mlock);
+	handle = idr_find(&rotate_private->user_idr, id);
+	if (handle != (void*)file_priv) {
+		DRM_ERROR("you release the handle is not your's\n");
+		ret = -EINVAL;
+		goto out;
+	}
+	rotate_private->used_cnt--;
+	idr_remove(&rotate_private->user_idr, id);
+out:
+	if (rotate_private->used_cnt == 0) {
+		de_tr_exit();
+		if (rotate_private->clk)
+			clk_disable(rotate_private->clk);
+	}
+	mutex_unlock(&rotate_private->user_mlock);
+
+	return ret;
+}
+
+int sunxi_drm_rotate_ioctl(struct drm_device *dev, void *data,
+				struct drm_file *file_priv)
+{
+	int ret = -EINVAL;
+	struct sunxi_rotate_cmd *rotate_cmd;
+	struct sunxi_drm_private *drm_private;
+	struct sunxi_rotate_private *rotate_private;
+
+	rotate_cmd = (struct sunxi_rotate_cmd *)data;
+	drm_private = (struct sunxi_drm_private *)dev->dev_private;
+	rotate_private = drm_private->rotate_private;
+	if (!rotate_cmd || !rotate_private) {
+		DRM_ERROR("you must give us rotate date\n");
+		goto out;
+	}
+
+	switch(rotate_cmd->cmd) {
+	case TR_CMD_AQUIRE:
+		ret = sunxi_rotate_aquire(rotate_private, rotate_cmd, file_priv);
+		break;
+	case TR_CMD_COMMIT:
+		ret = sunxi_rotate_commit(dev, rotate_private, rotate_cmd, file_priv);
+		break;
+	case TR_CMD_QUERY:
+		ret = sunxi_rotate_query(rotate_private, rotate_cmd, file_priv);
+		break;
+	case TR_CMD_RELEASE:
+		ret = sunxi_rotate_release(rotate_private, rotate_cmd->handle, file_priv);
+		break;
+	default:
+		DRM_ERROR("rotate give us a error cmd.\n");
+		return -EINVAL;
+	}
+out:
+	return ret;
+}
+
diff --git a/drivers/gpu/drm/sunxi/subdev/sunxi_rotate.h b/drivers/gpu/drm/sunxi/subdev/sunxi_rotate.h
new file mode 100755
index 0000000..264b7b3
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/subdev/sunxi_rotate.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#ifndef _DRM_SUNXI_ROTATE_H_
+#define _DRM_SUNXI_ROTATE_H_
+
+#include <linux/sunxi_tr.h>
+
+enum rotate_process{
+	ROTATE_IN_IDLE = 0,
+	ROTATE_IN_WORK,
+	ROTATE_IN_FINISH,
+	ROTAE_IN_BAD,
+};
+
+enum {
+	ROTATE_ERROR = -1,
+	ROTATE_OK = 0,
+	ROTATE_BUSY,
+	ROTAE_NO_START,
+};
+
+#define ROTATE_DAEMON_HZ  100
+
+struct sunxi_rotate_private {
+	struct list_head rotate_work;
+	spinlock_t head_lock;
+	struct list_head qurey_head;
+	struct mutex qurey_mlock;
+	int query_cnt;
+	struct sunxi_rotate_task *current_task;
+
+	spinlock_t process_lock;
+	enum rotate_process active;
+	wait_queue_head_t task_wq;
+	struct delayed_work daemon_work;
+	struct clk *clk;
+	int irq;
+	struct mutex user_mlock;
+	struct idr user_idr;
+	int used_cnt;
+};
+
+struct sunxi_rotate_task {
+	struct kref refcount;
+	struct list_head w_head;
+	struct list_head q_head;
+	tr_info info;
+	unsigned long timeout;
+	int status;//0 ok, -1 error, 1 busy, 2 not start
+	bool sleep_mode;
+};
+
+#define to_sunxi_rotate_q(x)	container_of(x, struct sunxi_rotate_task, q_head)
+#define to_sunxi_rotate_w(x)	container_of(x, struct sunxi_rotate_task, w_head)
+#define to_sunxi_rotate_priv(x)	container_of(x, struct sunxi_rotate_private, daemon_work)
+
+int sunxi_drm_rotate_init(void *dev_private);
+
+int sunxi_drm_rotate_ioctl(struct drm_device *dev, void *data,
+				struct drm_file *file_priv);
+int sunxi_drm_rotate_destroy(struct sunxi_rotate_private *rotate_private);
+#endif
diff --git a/drivers/gpu/drm/sunxi/subdev/sunxi_tv.c b/drivers/gpu/drm/sunxi/subdev/sunxi_tv.c
new file mode 100755
index 0000000..d3f5a12
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/subdev/sunxi_tv.c
@@ -0,0 +1 @@
+
diff --git a/drivers/gpu/drm/sunxi/subdev/transform.h b/drivers/gpu/drm/sunxi/subdev/transform.h
new file mode 100755
index 0000000..ed8fd0d
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/subdev/transform.h
@@ -0,0 +1,67 @@
+//*********************************************************************************************************************
+//  All Winner Tech, All Right Reserved. 2014-2015 Copyright (c)
+//
+//  File name   :	de_tr.h
+//
+//  Description :	display engine 2.0 rotation processing base functions implement
+//
+//  History     :	2014/04/08  iptang  v0.1  Initial version
+//
+//*********************************************************************************************************************
+
+#ifndef __DE_TR_H__
+#define __DE_TR_H__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <asm/uaccess.h>
+#include <asm/memory.h>
+#include <asm/unistd.h>
+#include <linux/semaphore.h>
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/dma-mapping.h>
+#include <linux/fb.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include "asm-generic/int-ll64.h"
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/types.h>
+#include <linux/timer.h>
+#include <asm/div64.h>
+#include <linux/debugfs.h>
+#include <linux/sunxi_tr.h>
+#include <linux/cdev.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/of_iommu.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+
+int de_tr_set_base(uintptr_t reg_base);
+int de_tr_irq_enable(void);
+int de_tr_irq_query(void);
+int de_tr_init(void);
+int de_tr_exit(void);
+int de_tr_set_cfg(tr_info *info);
+int de_tr_reset(void);
+int de_tr_exception(void);
+
+unsigned long sunxi_tr_request(void);
+int sunxi_tr_release(unsigned long hdl);
+int sunxi_tr_commit(unsigned long hdl, tr_info *info);
+int sunxi_tr_query(unsigned long hdl);
+int sunxi_tr_set_timeout(unsigned long hdl, unsigned long timeout /* ms */);
+
+#endif
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_connector.c b/drivers/gpu/drm/sunxi/sunxi_drm_connector.c
new file mode 100755
index 0000000..aa32dae
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_connector.c
@@ -0,0 +1,561 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui <cuiyuntao@allwinnter.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+ 
+#include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
+
+#include <drm/sunxi_drm.h>
+#include "sunxi_drm_core.h"
+#include "sunxi_drm_crtc.h"
+#include "sunxi_drm_encoder.h"
+#include "sunxi_drm_connector.h"
+#include "sunxi_drm_panel.h"
+#include "subdev/sunxi_lcd.h"
+#include "subdev/sunxi_common.h"
+#include "drm_de/drm_al.h"
+
+
+struct sunxi_drm_connector* 
+    get_sunxi_conct(struct drm_device *dev, unsigned int nr)
+{
+	struct drm_connector *conct;
+
+	list_for_each_entry(conct, &dev->mode_config.connector_list, head) {
+		if (to_sunxi_connector(conct)->connector_id == nr) {
+			return to_sunxi_connector(conct);
+		}
+	}
+	return NULL;
+}
+
+int sunxi_drm_deal_hotplug(struct drm_device *dev)
+{
+	return 0;
+}
+
+static int sunxi_drm_connector_get_modes(struct drm_connector *connector)
+{
+	struct sunxi_drm_connector *sunxi_connector =
+			to_sunxi_connector(connector);
+	unsigned int count = 0;
+	struct sunxi_panel *sunxi_panel = sunxi_connector->panel;
+	struct panel_ops   *panel_ops = sunxi_panel->panel_ops;
+
+
+	if(panel_ops && panel_ops->get_modes)
+		count =  panel_ops->get_modes(sunxi_panel);
+	DRM_DEBUG_KMS("[%d] id:%d count:%d\n", __LINE__, connector->base.id, count);
+
+	return count;
+}
+
+static int sunxi_drm_connector_mode_valid(struct drm_connector *connector,
+					    struct drm_display_mode *mode)
+{
+	struct sunxi_drm_connector *sunxi_connector =
+				to_sunxi_connector(connector);
+	struct sunxi_panel *sunxi_panel = sunxi_connector->panel;
+	struct panel_ops   *panel_ops = sunxi_panel->panel_ops;
+
+	int ret = MODE_BAD;
+
+	if(panel_ops && panel_ops->check_valid_mode)
+		ret =  panel_ops->check_valid_mode(sunxi_panel, mode);
+	DRM_DEBUG_KMS("[%d] valid:%d\n", __LINE__, ret);
+	return ret;
+}
+
+struct drm_encoder *sunxi_drm_best_encoder(struct drm_connector *connector)
+{
+	struct drm_device *dev = connector->dev;
+	struct drm_mode_object *obj;
+	struct drm_encoder *encoder = NULL, *best_encoder = NULL;
+	int i;
+
+
+	for (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {
+		if (connector->encoder_ids[i] != 0) {
+			obj = drm_mode_object_find(dev, connector->encoder_ids[i],
+							DRM_MODE_OBJECT_ENCODER);
+			if (!obj) {
+				DRM_DEBUG_KMS("Unknown ENCODER ID %d\n",
+				connector->encoder_ids[i]);
+				continue;
+			}
+
+			encoder = obj_to_encoder(obj);
+			if (best_encoder == NULL)
+				best_encoder = encoder;
+
+			if (connector->encoder == encoder) {
+				best_encoder = encoder;
+				break;
+			}else{
+				if(!drm_helper_encoder_in_use(encoder)) {
+					best_encoder = encoder;
+					break;
+				}
+			}
+		}
+	}
+	DRM_DEBUG_KMS("[%d] id:%d.\n", __LINE__, best_encoder->base.id);
+	return best_encoder;
+}
+
+static struct drm_connector_helper_funcs sunxi_connector_helper_funcs = {
+	.get_modes	= sunxi_drm_connector_get_modes,
+	.mode_valid	= sunxi_drm_connector_mode_valid,
+	.best_encoder	= sunxi_drm_best_encoder,
+};
+
+void sunxi_drm_connector_enable(struct drm_connector *connector)
+{
+	struct sunxi_drm_connector *sunxi_connector;
+	struct sunxi_hardware_res  *hw_res;
+
+	DRM_DEBUG_KMS("[%d]\n", __LINE__);
+
+	sunxi_connector = to_sunxi_connector(connector);
+	hw_res = sunxi_connector->hw_res;
+	if (hw_res != NULL &&
+		hw_res->ops != NULL &&
+		hw_res->ops->enable != NULL) {
+		hw_res->ops->enable(connector);
+	}
+}
+
+void sunxi_drm_connector_disable(struct drm_connector *connector)
+{
+	struct sunxi_drm_connector *sunxi_connector;
+	struct sunxi_hardware_res  *hw_res;
+
+	sunxi_connector = to_sunxi_connector(connector);
+	hw_res = sunxi_connector->hw_res;
+	if (hw_res != NULL &&
+		hw_res->ops != NULL &&
+		hw_res->ops->disable != NULL) {
+		hw_res->ops->disable(connector);
+	}
+}
+
+void sunxi_drm_connector_set_timming(struct drm_connector *connector)
+{
+	struct sunxi_drm_connector *sunxi_connector;
+	struct drm_display_mode *mode = NULL;
+	struct sunxi_hardware_res *hw_res;
+
+	sunxi_connector = to_sunxi_connector(connector);
+	hw_res = sunxi_connector->hw_res;
+	if (connector->encoder != NULL &&
+		connector->encoder->crtc != NULL) {
+		mode =  &connector->encoder->crtc->mode;
+	}
+	DRM_DEBUG_KMS("[%d] id:%d mode_id:%d\n", __LINE__,
+		connector->base.id, mode->base.id);
+
+	if (hw_res->ops->set_timming) {
+		hw_res->ops->set_timming(connector, mode);
+	}
+}
+
+void sunxi_drm_display_power(struct drm_connector *connector, int mode)
+{
+	struct sunxi_drm_connector *sunxi_connector;
+	sunxi_connector = to_sunxi_connector(connector);
+
+	DRM_DEBUG_KMS("[%d]id:%d  mode:%d pre:(%d)\n", __LINE__,
+	    connector->base.id, mode, sunxi_connector->dmps);
+	switch (mode) {
+	case DRM_MODE_DPMS_ON:
+		if (sunxi_connector->dmps > DRM_MODE_DPMS_ON && connector->encoder) {
+			sunxi_drm_connector_set_timming(connector);
+			sunxi_drm_connector_reset(connector);
+			sunxi_drm_connector_enable(connector);
+		}
+		if (!connector->encoder)
+		    return;
+		break;
+	case DRM_MODE_DPMS_STANDBY:
+		/* TODO */
+		break;
+	case DRM_MODE_DPMS_SUSPEND:
+		/* TODO */
+		break;
+	case DRM_MODE_DPMS_OFF:
+		if (sunxi_connector->dmps == DRM_MODE_DPMS_ON)
+			sunxi_drm_connector_disable(connector);
+		break;
+	default:
+		return;
+	}
+	sunxi_connector->dmps = mode;
+}
+
+static void sunxi_drm_connector_dpms(struct drm_connector *connector,
+					int mode)
+{
+	struct sunxi_drm_connector *sunxi_connector;
+	sunxi_connector = to_sunxi_connector(connector);
+
+	DRM_DEBUG_KMS("[%d] id:%d  power:%d  pre :%d\n", __LINE__,
+		sunxi_connector->connector_id, mode, sunxi_connector->dmps);
+
+	/* drm_helper_connector_dpms:connector->dpms = mode */
+	/* fix for the lcd power up flow */
+	if (mode >= sunxi_connector->dmps)
+		sunxi_drm_display_power(connector, mode);
+
+	drm_helper_connector_dpms(connector, mode);
+
+	if (mode < sunxi_connector->dmps)
+		sunxi_drm_display_power(connector, mode);
+
+}
+
+/* get detection status of display device. */
+static enum drm_connector_status
+sunxi_drm_connector_detect(struct drm_connector *connector, bool force)
+{
+	struct sunxi_drm_connector *sunxi_connector =
+		to_sunxi_connector(connector);
+	enum drm_connector_status status = connector_status_disconnected;
+
+	if (sunxi_connector->panel->panel_ops->detect)
+		status = sunxi_connector->panel->panel_ops->detect(sunxi_connector->panel);
+
+//	DRM_INFO("[%d]  status:%d\n", __LINE__, status);
+
+	//if (status == connector_status_disconnected)
+	//sunxi_drm_connector_dpms(connector, DRM_MODE_DPMS_OFF);
+	//if (status == connector_status_connected)
+	//sunxi_drm_connector_dpms(connector, DRM_MODE_DPMS_ON);
+	return status;
+}
+
+void sunxi_chain_enable(struct drm_connector *connector,
+        enum chain_bit_mask id)
+{
+
+	struct drm_encoder *encoder;
+	struct sunxi_drm_encoder *sunxi_enc;
+	struct sunxi_hardware_res *hw_res;
+	struct sunxi_drm_crtc *sunxi_crtc;
+	struct sunxi_drm_connector *sunxi_con;
+	encoder = connector->encoder;
+	/* if there the order, will add future */
+
+	if (id & CHAIN_BIT_CONNECTER) {
+		sunxi_con = to_sunxi_connector(connector);
+		hw_res = sunxi_con->hw_res;
+		if (hw_res && hw_res->ops &&
+			hw_res->ops->enable && hw_res->en_ctl_by) {
+
+			hw_res->ops->enable(encoder);
+		} 
+	}
+
+	if (id & CHAIN_BIT_ENCODER) {
+		sunxi_enc = to_sunxi_encoder(encoder);
+		hw_res = sunxi_enc->hw_res;
+		if (hw_res && hw_res->ops &&
+			hw_res->ops->enable && hw_res->en_ctl_by) {
+
+			hw_res->ops->enable(encoder);
+		} 
+	}
+
+	if (id & CHAIN_BIT_CRTC) {
+		if (encoder && encoder->crtc) {
+			sunxi_crtc = to_sunxi_crtc(encoder->crtc);
+			hw_res = sunxi_crtc->hw_res;
+			if (hw_res && hw_res->ops &&
+				hw_res->ops->enable && hw_res->en_ctl_by) {
+
+				hw_res->ops->enable(encoder);
+			}
+		}
+	}
+}
+
+void sunxi_chain_disable(struct drm_connector *connector,
+        enum chain_bit_mask id)
+{
+
+	struct drm_encoder *encoder;
+	struct sunxi_drm_encoder *sunxi_enc;
+	struct sunxi_drm_crtc *sunxi_crtc;
+	struct sunxi_drm_connector *sunxi_con;
+	struct sunxi_hardware_res *hw_res;
+
+	encoder = connector->encoder;
+	/* if there the order, will add future */
+	if (id & CHAIN_BIT_CONNECTER) {
+		sunxi_con = to_sunxi_connector(connector);
+		hw_res = sunxi_con->hw_res;
+		if (hw_res && hw_res->ops &&
+			hw_res->ops->disable && hw_res->en_ctl_by) {
+
+			hw_res->ops->disable(encoder);
+		} 
+	}
+
+	if (id & CHAIN_BIT_ENCODER) {
+		sunxi_enc = to_sunxi_encoder(encoder);
+		hw_res = sunxi_enc->hw_res;
+		if (hw_res && hw_res->ops &&
+			hw_res->ops->disable && hw_res->en_ctl_by) {
+
+			hw_res->ops->disable(encoder);
+		} 
+	}
+
+	if (id & CHAIN_BIT_CRTC) {
+		if (encoder && encoder->crtc) {
+			sunxi_crtc = to_sunxi_crtc(encoder->crtc);
+			hw_res = sunxi_crtc->hw_res;
+			if (hw_res && hw_res->ops &&
+				hw_res->ops->disable && hw_res->en_ctl_by)
+
+				hw_res->ops->disable(encoder);
+		}
+	}
+}
+
+void sunxi_drm_connector_reset(struct drm_connector *connector)
+{
+	/*commit the mode to the connector*/
+	struct sunxi_drm_connector *sunxi_connector =
+		to_sunxi_connector(connector);
+
+	DRM_DEBUG_KMS("id:%d\n", connector->base.id);
+	/*modify the irq chain, and register it*/
+	if (!connector->encoder ||
+		!connector->encoder->crtc) {
+		sunxi_irq_free(sunxi_connector->hw_res);
+		sunxi_connector->hw_res->ops->disable(connector);
+		return;
+	}
+	sunxi_connector->hw_res->ops->reset(connector);
+}
+
+static void sunxi_drm_connector_destroy(struct drm_connector *connector)
+{
+	struct sunxi_drm_connector *sunxi_connector =
+		to_sunxi_connector(connector);
+	struct sunxi_hardware_res *hw_res;
+
+	DRM_DEBUG_KMS("id:%d\n",connector->base.id);
+
+	hw_res = sunxi_connector->hw_res;
+	drm_sysfs_connector_remove(connector);
+	drm_connector_cleanup(connector);
+	if (sunxi_connector->panel) {
+		sunxi_panel_destroy(sunxi_connector->panel);
+	}
+	if (hw_res) {
+		/* no need to free hw_res twice, the first time is in sunxi_panel_destroy */
+		//sunxi_hwres_destroy(hw_res);
+	}
+	kfree(sunxi_connector);
+}
+
+irqreturn_t sunxi_connector_vsync_handle(int irq, void *data)
+{
+	struct drm_encoder *encoder;
+	struct sunxi_drm_crtc *sunxi_crtc;
+	struct sunxi_drm_encoder *sunxi_encoder;
+	struct sunxi_drm_connector *sunxi_con;
+	struct drm_connector *conct = (struct drm_connector *)(data);
+
+	sunxi_con = to_sunxi_connector(conct);
+	encoder = conct->encoder;
+	sunxi_encoder = to_sunxi_encoder(encoder);
+	sunxi_crtc = to_sunxi_crtc(encoder->crtc);
+	if (!encoder || !sunxi_crtc) {
+		return IRQ_HANDLED;
+	}
+
+	if (!sunxi_irq_query(sunxi_con->hw_res, conct, QUERY_VSYNC_IRQ))
+		return IRQ_HANDLED;
+
+	if (sunxi_con->hw_res != NULL &&
+		sunxi_con->hw_res->ops != NULL &&
+		sunxi_con->hw_res->ops->vsync_proc != NULL) {
+
+		sunxi_con->hw_res->ops->vsync_proc(sunxi_crtc);
+	}
+
+	if (sunxi_crtc->hw_res != NULL &&
+		sunxi_crtc->hw_res->ops != NULL &&
+		sunxi_crtc->hw_res->ops->vsync_proc != NULL) {
+
+		sunxi_crtc->hw_res->ops->vsync_proc(sunxi_crtc);
+	}
+
+	if (sunxi_encoder->hw_res != NULL &&
+		sunxi_encoder->hw_res->ops != NULL &&
+		sunxi_encoder->hw_res->ops->vsync_proc != NULL) {
+
+		sunxi_encoder->hw_res->ops->vsync_proc(sunxi_encoder);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int sunxi_drm_connector_set_pro(struct drm_connector *connector,
+        struct drm_property *property, uint64_t val)
+{
+	struct sunxi_drm_connector *sunxi_connector =
+		to_sunxi_connector(connector);
+	DRM_DEBUG_KMS("[%d] id:%d\n",__LINE__, connector->base.id);
+
+	sunxi_connector = sunxi_connector;
+	return 0;
+}
+
+static struct drm_connector_funcs sunxi_connector_funcs = {
+	.dpms		= sunxi_drm_connector_dpms,
+	.fill_modes	= drm_helper_probe_single_connector_modes,
+	.detect		= sunxi_drm_connector_detect,
+	.destroy	= sunxi_drm_connector_destroy,
+	.set_property = sunxi_drm_connector_set_pro,
+	.reset        = sunxi_drm_connector_reset,
+};
+
+int sunxi_drm_connector_create(struct drm_device *dev, int possible_enc, int fix_enc, int id,
+     struct sunxi_panel *panel, enum disp_output_type disp_out_type, struct sunxi_hardware_res *hw_res)
+{
+	struct sunxi_drm_connector *sunxi_connector;
+	struct drm_connector *connector;
+	struct drm_encoder	 *encoder;
+	struct sunxi_lcd_private  *sunxi_lcd_p = NULL;
+	int type;
+	int err;
+
+	DRM_DEBUG_KMS("[%d]\n", __LINE__);
+
+	sunxi_connector = kzalloc(sizeof(*sunxi_connector), GFP_KERNEL);
+	if (!sunxi_connector) {
+		DRM_ERROR("failed to allocate connector\n");
+		return -EINVAL;
+	}
+
+	connector = &sunxi_connector->drm_connector;
+	switch (disp_out_type) {
+	case DISP_OUTPUT_TYPE_LCD:
+		connector->interlace_allowed = false;
+		connector->polled = 0;
+		sunxi_connector->disp_out_type = DISP_OUTPUT_TYPE_LCD;
+		sunxi_lcd_p = (struct sunxi_lcd_private *)panel->private;
+
+		switch (sunxi_lcd_p->panel->lcd_if) {
+		case LCD_IF_HV:
+			type = DRM_MODE_CONNECTOR_Unknown;
+			break;
+		case LCD_IF_CPU:
+			type = DRM_MODE_CONNECTOR_Unknown;
+			break;
+		case LCD_IF_LVDS:
+				type = DRM_MODE_CONNECTOR_LVDS;
+			if (sunxi_encoder_assign_ops(dev, fix_enc, ENCODER_OPS_LVDS, panel->private))
+				goto out;
+			break;
+		case LCD_IF_DSI:
+			type = DRM_MODE_CONNECTOR_Unknown;
+			if (sunxi_encoder_assign_ops(dev, fix_enc, ENCODER_OPS_DSI, panel->private))
+				goto out;
+			break;
+		case LCD_IF_EDP:
+			type = DRM_MODE_CONNECTOR_eDP;
+			break;
+		case LCD_IF_EXT_DSI:
+			type = DRM_MODE_CONNECTOR_Unknown;
+			break;
+		default:
+			DRM_ERROR("give us a err lcd panel type.\n");
+			goto out;
+		}
+		break;
+	case DISP_OUTPUT_TYPE_HDMI:
+		type = DRM_MODE_CONNECTOR_HDMIA;
+		connector->polled = DRM_CONNECTOR_POLL_CONNECT | DRM_CONNECTOR_POLL_DISCONNECT;
+		sunxi_connector->disp_out_type = DISP_OUTPUT_TYPE_HDMI;
+		connector->interlace_allowed = 1;
+		err = sunxi_encoder_assign_ops(dev, fix_enc, ENCODER_OPS_HDMI, panel->private);
+		if (err && fix_enc != -1)
+			goto out;
+		break;
+	case DISP_OUTPUT_TYPE_TV:
+		type = DRM_MODE_CONNECTOR_TV;
+		connector->polled = 0;
+		sunxi_connector->disp_out_type = DISP_OUTPUT_TYPE_TV;
+		err = sunxi_encoder_assign_ops(dev, fix_enc, ENCODER_OPS_TV, panel->private);
+		if (err && fix_enc != -1)
+			goto out;
+		break;
+	case DISP_OUTPUT_TYPE_VGA:
+		type = DRM_MODE_CONNECTOR_VGA;
+		connector->polled = 0;
+		sunxi_connector->disp_out_type = DISP_OUTPUT_TYPE_VGA;
+		err = sunxi_encoder_assign_ops(dev, fix_enc, ENCODER_OPS_VGA, panel->private);
+		if (err && fix_enc != -1)
+			goto out;
+		break;
+
+	default:
+		type = DRM_MODE_CONNECTOR_Unknown;
+		DRM_ERROR("give us a err type disp_out_type.\n");
+		goto out;
+	}
+
+	connector->dpms = DRM_MODE_DPMS_OFF;
+	sunxi_connector->dmps = DRM_MODE_DPMS_OFF;
+	sunxi_connector->panel = panel;
+	sunxi_connector->connector_id = id;
+	panel->drm_connector = &sunxi_connector->drm_connector;
+	panel->type = sunxi_connector->disp_out_type; // when call sunxi_panel_destroy, it will not find any device, so add it;
+
+	sunxi_connector->hw_res = hw_res;
+	if (hw_res != NULL) {
+		hw_res->irq_arg = (void *)sunxi_connector;
+		hw_res->irq_handle = sunxi_connector_vsync_handle;
+		if (hw_res->ops && hw_res->ops->init)
+			hw_res->ops->init(sunxi_connector);
+	}
+
+	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
+		if (possible_enc & 1) {
+			err = drm_mode_connector_attach_encoder(connector, encoder);
+			if (err) {
+				DRM_ERROR("failed to attach a connector to a encoder\n");
+			}
+		}
+		possible_enc >>= 1; 
+	}
+
+	drm_connector_init(dev, connector, &sunxi_connector_funcs, type);
+	drm_connector_helper_add(connector, &sunxi_connector_helper_funcs);
+	err = drm_sysfs_connector_add(connector);
+	if (err)
+		goto err_connector;
+
+	DRM_INFO("[%d]sunxi_con_id:%d(%d), fix:%d\n", __LINE__,
+		sunxi_connector->connector_id, connector->base.id,  fix_enc);
+
+	return 0;
+
+err_connector:
+	drm_connector_cleanup(connector);
+out:
+	kfree(sunxi_connector);
+	return -EINVAL;
+}
+
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_connector.h b/drivers/gpu/drm/sunxi/sunxi_drm_connector.h
new file mode 100755
index 0000000..0e82a63
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_connector.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+/*Connector --> HDMI/LCD/MIPI/etc*/
+
+#ifndef _SUNXI_DRM_CONNECTOR_H_
+#define _SUNXI_DRM_CONNECTOR_H_
+#include "de/include.h"
+#include "sunxi_drm_panel.h"
+
+enum chain_bit_mask{
+    CHAIN_BIT_CONNECTER = 0x01,
+    CHAIN_BIT_ENCODER = 0x02,
+    CHAIN_BIT_CRTC = 0x04,
+};
+
+struct sunxi_drm_connector {
+	struct drm_connector drm_connector;
+	int connector_id;
+	int dmps;
+	struct drm_property *brigt_linght_property; //0~15  0~7
+	struct sunxi_hardware_res *hw_res;
+	enum disp_output_type disp_out_type;
+
+	struct sunxi_panel *panel;
+};
+
+#define to_sunxi_connector(x)	container_of(x, struct sunxi_drm_connector, drm_connector)
+
+irqreturn_t sunxi_connector_vsync_handle(int irq, void *data);
+
+int sunxi_drm_connector_create(struct drm_device *dev, int possible_enc, int fix_enc, int id,
+     struct sunxi_panel *panel, enum disp_output_type disp_out_type, struct sunxi_hardware_res *hw_res);
+
+void sunxi_chain_disable(struct drm_connector *connector,
+        enum chain_bit_mask id);
+
+void sunxi_chain_enable(struct drm_connector *connector,
+        enum chain_bit_mask id);
+
+void sunxi_drm_connector_reset(struct drm_connector *connector);
+
+void sunxi_drm_display_power(struct drm_connector *connector, int mode);
+
+#endif
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_core.c b/drivers/gpu/drm/sunxi/sunxi_drm_core.c
new file mode 100755
index 0000000..d8c4947
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_core.c
@@ -0,0 +1,475 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
+
+#include "sunxi_drm_core.h"
+#include "sunxi_drm_crtc.h"
+#include "sunxi_drm_encoder.h"
+#include "sunxi_drm_connector.h"
+#include "subdev/sunxi_lcd.h"
+#include "subdev/sunxi_hdmi.h"
+#include "subdev/sunxi_common.h"
+#include "drm_de/drm_al.h"
+#include "subdev/sunxi_rotate.h"
+
+static bool has_res[DISP_MOD_NUM+3][3] = {
+	/* A64:{reg_base,irq,clk} */
+	{1,1,1}, /*DISP_MOD_DE*/
+#if defined(HAVE_DEVICE_COMMON_MODULE)
+	{1,0,0},  /*DISP_MOD_DEVICE*/
+	{0,1,1},  /*DISP_MOD_LCD0*/
+	{0,1,1},  /*DISP_MOD_LCD1*/
+	{0,1,1},  /*DISP_MOD_LCD2*/
+	{0,1,1},  /*DISP_MOD_LCD3*/
+#else
+	{0,0,0},  /*DISP_MOD_DEVICE*/
+	{1,1,1},  /*DISP_MOD_LCD0*/
+	{1,1,1},  /*DISP_MOD_LCD1*/
+	{1,1,1},  /*DISP_MOD_LCD2*/
+	{1,1,1},  /*DISP_MOD_LCD3*/
+#endif
+#if defined(SUPPORT_DSI)
+	{1,1,1},  /*DISP_MOD_DSI0*/
+#else
+	{0,0,0},  /*DISP_MOD_DSI0*/
+#endif
+	{0,0,0},  /*DISP_MOD_DSI1*/
+	{0,0,0},  /*DISP_MOD_DSI2*/
+	{1,1,1},  /*DISP_MOD_HDMI, but not in display device*/
+	{0,0,1},  /*DISP_MOD_LVDS*/
+	{1,1,1},  /*DISP_MOD_EINK*/
+	{1,1,1}  /*DISP_MOD_EDMA*/    
+};
+
+bool sunxi_find_irq_res(struct drm_connector *connector, unsigned int *irq,
+    void **irq_arg, irqreturn_t(**irq_handle)(int, void *), bool *enalbed)
+{
+	struct sunxi_drm_connector    *sunxi_connector;
+	struct sunxi_drm_encoder	  *sunxi_encoder;
+	struct sunxi_drm_crtc         *sunxi_crtc;
+	struct sunxi_hardware_res     *hw_res;
+
+	sunxi_connector = to_sunxi_connector(connector);
+	hw_res = sunxi_connector->hw_res;
+
+	if (hw_res && hw_res->irq_uesd) {
+
+		*irq = hw_res->irq_no;
+		*irq_arg = hw_res->irq_arg;
+		*irq_handle = sunxi_crtc_vsync_handle;
+		*enalbed = hw_res->irq_enable;
+		return true;
+	}
+
+	sunxi_encoder = to_sunxi_encoder(connector->encoder);
+	if (sunxi_encoder) {
+		hw_res = sunxi_connector->hw_res;
+	} else {
+		hw_res = NULL;
+	}
+	if (hw_res && hw_res->irq_uesd) {
+		*irq = hw_res->irq_no;
+		*irq_arg = hw_res->irq_arg;
+		*irq_handle = sunxi_crtc_vsync_handle;
+		*enalbed = hw_res->irq_enable;
+		return true;
+	}
+
+	sunxi_crtc = to_sunxi_crtc(sunxi_encoder->drm_encoder.crtc);
+	if (sunxi_crtc) {
+		hw_res = sunxi_connector->hw_res;
+	} else {
+		hw_res = NULL;
+	}
+	if (hw_res && hw_res->irq_uesd) {
+		*irq = hw_res->irq_no;
+		*irq_arg = hw_res->irq_arg;
+		*irq_handle = sunxi_crtc_vsync_handle;
+		*enalbed = hw_res->irq_enable;
+		return true;
+	}
+
+	*irq = 0;
+	*irq_arg = NULL;
+	*irq_handle = NULL;
+	return false;
+}
+
+
+int sunxi_drm_get_res_info(disp_bsp_init_para *para,
+        struct sunxi_hardware_res *hw_res, bool has_res[3])
+{
+
+	if (has_res[0]) {
+		hw_res->reg_base = para->reg_base[hw_res->res_id];
+	}
+	if (has_res[1]) {
+		hw_res->irq_no = para->irq_no[hw_res->res_id];
+	}
+	if (has_res[2]) {
+		hw_res->clk = para->mclk[hw_res->res_id];
+	}
+	return 0;
+}
+
+struct sunxi_hardware_res *sunxi_hwres_init(disp_mod_id id)
+{
+	struct sunxi_hardware_res *hw_res;
+	hw_res = kzalloc(sizeof(struct sunxi_hardware_res), GFP_KERNEL);  
+	if (!hw_res) {
+		DRM_ERROR("failed to alloc lcd sunxi_hardware_res.\n");
+		return NULL;
+	}
+	hw_res->res_id = id;
+	return hw_res;
+}
+
+void sunxi_hwres_destroy(struct sunxi_hardware_res *hw_res)
+{
+	sunxi_clk_disable(hw_res);
+	sunxi_irq_free(hw_res);
+	kfree(hw_res);
+}
+
+/* same with display driver */
+int sunxi_display_init(disp_bsp_init_para *para)
+{
+	struct device_node *node;
+	int i = 0, counter = 0;
+
+
+	memset(para, 0, sizeof(disp_bsp_init_para));
+	node = sunxi_drm_get_name_node("sunxi-disp");
+	if (!node) {
+		DRM_ERROR("get sunxi-disp node err.\n ");
+		return -EINVAL;
+	}
+	para->reg_base[DISP_MOD_DE] = (uintptr_t __force)of_iomap(node, counter);
+	if (!para->reg_base[DISP_MOD_DE]) {
+		DRM_ERROR( "unable to map de registers\n");
+		goto err_iomap;
+	}
+	counter ++;
+
+#if defined(HAVE_DEVICE_COMMON_MODULE)
+	para->reg_base[DISP_MOD_DEVICE] = (uintptr_t __force)of_iomap(node, counter);
+	if (!para->reg_base[DISP_MOD_DEVICE]) {
+		DRM_ERROR( "unable to map device common module registers\n");
+		goto err_iomap;
+	}
+	counter ++;
+#endif
+
+	for (i = 0; i < DISP_DEVICE_NUM; i++) {
+		para->reg_base[DISP_MOD_LCD0 + i] = (uintptr_t __force)of_iomap(node, counter);
+		if (!para->reg_base[DISP_MOD_LCD0 + i]) {
+			DRM_ERROR( "unable to map timing controller %d registers\n", i);
+			goto err_iomap;
+		}
+		counter ++;
+	}
+
+#if defined(SUPPORT_DSI)
+	para->reg_base[DISP_MOD_DSI0] = (uintptr_t __force)of_iomap(node, counter);
+	if (!para->reg_base[DISP_MOD_DSI0]) {
+		DRM_ERROR("unable to map dsi registers\n");
+		goto err_iomap;
+	}
+	counter ++;
+#endif
+
+#if defined(SUPPORT_EINK)
+	para->reg_base[DISP_MOD_EINK] = (uintptr_t __force)of_iomap(node, counter);
+	if (!para->reg_base[DISP_MOD_EINK]) {
+		DRM_ERROR( "unable to map eink registers\n");
+		goto err_iomap;
+	}
+	counter ++;
+#endif
+
+	/* parse and map irq */
+	/* lcd0/1/2.. - dsi */
+	counter = 0;
+	for (i = 0; i < DISP_DEVICE_NUM; i++) {
+		para->irq_no[DISP_MOD_LCD0 + i] = irq_of_parse_and_map(node, counter);
+		if (!para->irq_no[DISP_MOD_LCD0 + i]) {
+			DRM_ERROR("irq_of_parse_and_map irq %d fail for tcon%d\n", counter, i);
+		}
+		counter ++;
+	}
+
+#if defined(SUPPORT_DSI)
+	para->irq_no[DISP_MOD_DSI0] = irq_of_parse_and_map(node, counter);
+	if (!para->irq_no[DISP_MOD_DSI0]) {
+		DRM_ERROR("irq_of_parse_and_map irq %d fail for dsi\n", i);
+	}
+	counter ++;
+#endif
+
+#if defined(SUPPORT_EINK)
+	para->irq_no[DISP_MOD_DE] = irq_of_parse_and_map(node, counter);
+	if (!para->irq_no[DISP_MOD_DE]) {
+		DRM_ERROR("irq_of_parse_and_map de irq %d fail for dsi\n", i);
+	}
+	counter ++;
+
+	para->irq_no[DISP_MOD_EINK] = irq_of_parse_and_map(node, counter);
+	if (!para->irq_no[DISP_MOD_EINK]) {
+		DRM_ERROR("irq_of_parse_and_map eink irq %d fail for dsi\n", i);
+	}
+	counter ++;
+#endif
+
+
+	/* get clk */
+	/* de - [device(tcon-top)] - lcd0/1/2.. - lvds - dsi */
+	counter = 0;
+	para->mclk[DISP_MOD_DE] = of_clk_get(node, counter);
+	if (IS_ERR(para->mclk[DISP_MOD_DE])) {
+		DRM_ERROR("fail to get clk for de\n");
+	}
+	counter ++;
+
+#if defined(HAVE_DEVICE_COMMON_MODULE)
+	para->mclk[DISP_MOD_DEVICE] = of_clk_get(node, counter);
+	if (IS_ERR(para->mclk[DISP_MOD_DEVICE])) {
+		DRM_ERROR("fail to get clk for device common module\n");
+	}
+	counter ++;
+#endif
+
+	for (i = 0; i < DISP_DEVICE_NUM; i++) {
+		para->mclk[DISP_MOD_LCD0 + i] = of_clk_get(node, counter);
+		if (IS_ERR(para->mclk[DISP_MOD_LCD0 + i])) {
+			DRM_ERROR("fail to get clk for timing controller%d\n", i);
+		}
+		counter ++;
+	}
+
+#if defined(SUPPORT_LVDS)
+	para->mclk[DISP_MOD_LVDS] = of_clk_get(node, counter);
+	if (IS_ERR(para->mclk[DISP_MOD_LVDS])) {
+		DRM_ERROR("fail to get clk for lvds\n");
+	}
+	counter ++;
+#endif
+
+#if defined(SUPPORT_DSI)
+	para->mclk[DISP_MOD_DSI0] = of_clk_get(node, counter);
+	DRM_INFO("[dengbo]: sunxi_display_init 15\n");
+	if (IS_ERR(para->mclk[DISP_MOD_DSI0])) {
+		DRM_ERROR( "fail to get clk for dsi\n");
+	}
+	counter ++;
+#endif
+
+#if defined(SUPPORT_EINK)
+	para->mclk[DISP_MOD_EINK] = of_clk_get(node, counter);
+	DRM_INFO("[dengbo]: sunxi_display_init 16\n");
+	if (IS_ERR(para->mclk[DISP_MOD_EINK])) {
+		DRM_ERROR("fail to get clk for eink\n");
+	}
+	counter ++;
+
+	para->mclk[DISP_MOD_EDMA] = of_clk_get(node, counter);
+	if (IS_ERR(para->mclk[DISP_MOD_EDMA])) {
+		DRM_ERROR("fail to get clk for edma\n");
+	}
+	counter ++;
+#endif
+    return 0;
+
+err_iomap:
+	for (i = 0; i < DISP_DEVICE_NUM; i++) {
+		if (para->reg_base[i])
+			iounmap((char __iomem *)para->reg_base[i]);
+	}
+
+	return -EINVAL;
+}
+
+int sunxi_drm_init(struct drm_device *dev)
+{
+	int i, j, ret, max_crtc, max_enc, max_connector;
+	int possible_up = 0x00, fix_up = -1, asigned = 0x00;
+	int lcd_id = 0, hdmi_id = 0;
+	struct sunxi_panel *sunxi_panel;
+	struct sunxi_hardware_res *hw_res;
+	disp_bsp_init_para para;
+	disp_mod_id id;
+	enum disp_output_type disp_out_type;
+	struct resource *res_irq;
+
+	if (sunxi_display_init(&para)) {
+		goto err;
+	}
+	dev->vblank_disable_allowed = 1;
+	dev->irq_enabled = 1;
+	sunxi_drm_init_al(&para);
+	max_crtc = sunxi_drm_get_max_crtc();
+	max_enc = sunxi_drm_get_max_encoder();
+	max_connector = sunxi_drm_get_max_connector();
+
+	res_irq =  kzalloc(sizeof(struct resource), GFP_KERNEL);
+		if (res_irq == NULL) {
+		DRM_ERROR("fail to alloc res_irq for drm.\n");
+	}
+
+	init_crtc_array(max_crtc);
+	for (i = 0, id = DISP_MOD_DE; i < max_crtc; i++) {
+		hw_res = sunxi_hwres_init(DISP_MOD_DE);
+		if (!hw_res) {
+		goto err;
+		}
+		ret = sunxi_drm_get_res_info(&para, hw_res, has_res[id]);
+		if (ret) {
+			sunxi_hwres_destroy(hw_res);
+			goto err;
+		}
+
+		ret = sunxi_drm_crtc_create(dev, i, hw_res);
+		if (ret) {
+			sunxi_hwres_destroy(hw_res);
+			goto err;
+		}
+		DRM_DEBUG_KMS("[%d]:id[%d] reg_base[0x%lx] irq_id[%d]\n",__LINE__,
+		hw_res->res_id, hw_res->reg_base, hw_res->irq_no);
+	}
+#ifdef HAVE_DEVICE_COMMON_MODULE
+	id = DISP_MOD_DEVICE;
+#else
+	id = DISP_MOD_LCD0;
+#endif
+	possible_up = 0x03;
+	for (i = 0; i < max_enc; i++ ) {
+#ifdef HAVE_DEVICE_COMMON_MODULE
+		hw_res = sunxi_hwres_init(DISP_MOD_DEVICE);
+#else
+		hw_res = sunxi_hwres_init(DISP_MOD_LCD0 + i);
+		id += i;;
+#endif
+		if (!hw_res) {
+			goto err;
+		}
+
+		fix_up = i;
+		if (fix_up >= max_crtc)
+			fix_up = -1;
+		ret = sunxi_drm_get_res_info(&para, hw_res, has_res[id]);
+		if (ret) {
+			sunxi_hwres_destroy(hw_res);
+			goto err;
+		}
+
+		ret = sunxi_drm_encoder_create(dev, possible_up, fix_up, i, hw_res);
+		if (ret) {
+			goto err;
+		}
+		DRM_DEBUG_KMS("[%d]:id[%d] reg_base[0x%lx] irq_id[%d]\n",__LINE__, 
+		hw_res->res_id, hw_res->reg_base, hw_res->irq_no);
+		if (res_irq && hw_res->irq_no && has_res[id][1]) {
+			/* for drm_wait_vblank */
+			res_irq->start = hw_res->irq_no;
+			res_irq->flags = IORESOURCE_IRQ;
+			res_irq->name = "drm_irq";
+			platform_device_add_resources(dev->platformdev, res_irq, 1);
+			kfree(res_irq);
+			res_irq = NULL;
+		}
+	}
+	asigned = 0x00;
+	for (i = 0, id = DISP_MOD_DSI0, lcd_id = 0, hdmi_id = 0;
+			(id < DISP_MOD_NUM) && (i < max_connector);
+			id++) {
+		hw_res = sunxi_hwres_init(id);
+		if (!hw_res) {
+			goto err;
+		}
+		fix_up = -1;
+		possible_up = 0;
+		disp_out_type = DISP_OUTPUT_TYPE_NONE;
+		switch (id) {
+		case DISP_MOD_DSI0:
+		case DISP_MOD_DSI1:
+		case DISP_MOD_DSI2:
+		case DISP_MOD_LVDS:
+			sunxi_panel = sunxi_lcd_init(hw_res, i, lcd_id);
+			if (!sunxi_panel) {
+			sunxi_hwres_destroy(hw_res);
+			continue;
+			}
+			ret = sunxi_drm_get_res_info(&para, hw_res, has_res[id]);
+			if (ret) {
+				sunxi_hwres_destroy(hw_res);
+				goto err;
+			}
+			for (j = 0; j < max_enc; j++) {
+				if (sunxi_drm_encoder_support(j, DISP_OUTPUT_TYPE_LCD)) {
+					possible_up |= 1<<j;
+					if(!(asigned & (1 << j)) && fix_up == -1) {
+						asigned |= 1 << j;
+						fix_up = j;
+					}
+				}
+			}
+			disp_out_type = DISP_OUTPUT_TYPE_LCD;
+			lcd_id++;
+			break;
+		case DISP_MOD_HDMI:
+			sunxi_panel = sunxi_hdmi_pan_init(hw_res, i, hdmi_id);
+			if (!sunxi_panel) {
+				sunxi_hwres_destroy(hw_res);
+				continue;
+			}
+			for (j = 0; j < max_enc; j++) {
+				if (sunxi_drm_encoder_support(j, DISP_OUTPUT_TYPE_HDMI)) {
+					possible_up |= 1<<j;
+					if (!(asigned & (1 << j)) && fix_up == -1) {
+						asigned |= 1 << j;
+						fix_up = j;
+					}
+				}
+			}
+			disp_out_type = DISP_OUTPUT_TYPE_HDMI;
+			hdmi_id++;
+			break;
+		default:
+			DRM_ERROR("temple we don't support %d.\n", id);
+			sunxi_hwres_destroy(hw_res);
+			continue;
+		}
+		DRM_DEBUG_KMS("[%d]:id[%d] reg_base[0x%lx] irq_id[%d]\n", __LINE__,
+			hw_res->res_id, hw_res->reg_base, hw_res->irq_no);
+
+		ret = sunxi_drm_connector_create(dev, possible_up, fix_up, i, sunxi_panel, disp_out_type, hw_res);
+		if (ret) {
+		sunxi_lcd_destroy(sunxi_panel, hw_res);
+		sunxi_hwres_destroy(hw_res);
+		continue;
+		}
+		i++;
+	}
+
+	if (i == 0)
+		goto err;
+	if (sunxi_drm_rotate_init(dev->dev_private))
+		DRM_ERROR("rotate hw init err.\n");
+
+	return 0;
+err:
+    	return -EINVAL;
+}
+
+void sunxi_drm_destroy(struct drm_device *dev)
+{
+    	drm_mode_config_cleanup(dev);
+}
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_core.h b/drivers/gpu/drm/sunxi/sunxi_drm_core.h
new file mode 100755
index 0000000..2c7040b
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_core.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#ifndef _SUNXI_DRM_CORE_H_
+#define _SUNXI_DRM_CORE_H_
+
+#include <de/include.h>
+#include <linux/types.h>
+#include <sunxi_drm_crtc.h>
+#include <video/sunxi_display2.h>
+
+enum {
+    QUERY_VSYNC_IRQ = 0,
+};
+
+struct sunxi_hardware_ops {
+	bool    (*init)(void *init_data);
+	bool    (*reset)(void *init_data);
+	bool    (*enable)(void *enable_data);
+	bool    (*disable)(void *disable_data);
+	bool    (*updata_reg)(void *commit_data);
+	void    (*vsync_proc)(void *irq_data);
+	bool    (*irq_query)(void *irq_data, int need_irq);
+	void    (*vsync_delayed_do)(void *data);
+	int     (*set_timming)(void *data, struct drm_display_mode *mode);
+	int     (*user_def)(void *data);
+};
+
+struct sunxi_hardware_res {
+	disp_mod_id res_id;
+
+	struct clk *clk;
+	unsigned long clk_rate;
+	struct clk *parent_clk;
+	unsigned long parent_clk_rate;
+
+	bool clk_enable;
+	bool irq_enable;
+	bool irq_uesd;
+	bool en_ctl_by;
+	irq_handler_t irq_handle;
+	unsigned int irq_no;
+	void *irq_arg;
+	uintptr_t reg_base;
+	struct sunxi_hardware_ops *ops;
+	void *private;
+};
+
+struct sunxi_panel *sunxi_lcd_init(struct sunxi_hardware_res *hw_res, int panel_id, int lcd_id);
+
+int sunxi_drm_init(struct drm_device *dev);
+
+void sunxi_drm_destroy(struct drm_device *dev);
+
+void sunxi_hwres_destroy(struct sunxi_hardware_res *res);
+
+#endif
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_crtc.c b/drivers/gpu/drm/sunxi/sunxi_drm_crtc.c
new file mode 100755
index 0000000..dde81f5
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_crtc.c
@@ -0,0 +1,1082 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+/*CRT -->Display Engine*/
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <linux/clk.h>
+#include <drm/sunxi_drm.h>
+#include "sunxi_drm_drv.h"
+#include "sunxi_drm_core.h"
+#include "sunxi_drm_crtc.h"
+#include "sunxi_drm_encoder.h"
+#include "sunxi_drm_connector.h"
+#include "sunxi_drm_plane.h"
+#include "drm_de/drm_al.h"
+#include "subdev/sunxi_common.h"
+#include "sunxi_drm_fb.h"
+
+static struct drm_crtc **crtc_array;
+
+int init_crtc_array(int num)
+{
+	crtc_array = kzalloc(sizeof(struct drm_crtc *) *num, GFP_KERNEL);
+	if (!crtc_array) {
+		DRM_ERROR("sunxi crtc must have hardware resource.\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+struct drm_encoder *sunxi_get_encoder(struct drm_crtc *crtc)
+{
+	struct drm_encoder *encoder;
+	list_for_each_entry(encoder, &crtc->dev->mode_config.encoder_list, head) {
+		if (encoder->crtc == crtc) {
+			return encoder;
+		}
+	}
+	return NULL;
+}
+
+struct drm_connector  *sunxi_crtc_get_conector(struct drm_crtc *crtc)
+{
+
+	struct drm_encoder  *encoder;
+	encoder = sunxi_get_encoder(crtc);
+	if(!encoder)
+		return NULL;
+	return sunxi_get_conct(encoder);
+}
+
+struct sunxi_drm_crtc *get_sunxi_crt(struct drm_device *dev, int nr)
+{
+	struct drm_crtc *crtc = NULL;
+
+	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+		if (to_sunxi_crtc(crtc)->crtc_id == nr) {
+			return to_sunxi_crtc(crtc);
+		}
+	}
+	return NULL;
+}
+
+enum disp_output_type get_sunxi_crtc_out_type(int nr)
+{
+	struct drm_crtc *crtc = NULL;
+	struct drm_encoder	 *drm_encoder;
+	struct drm_connector *drm_connector;
+	bool find = 0;
+
+	if (crtc_array == NULL)
+		goto ret_err;
+	crtc = crtc_array[nr];
+	DRM_DEBUG_KMS("[%d] \n",__LINE__);
+
+	list_for_each_entry(drm_encoder, &crtc->dev->mode_config.encoder_list, head) {
+		if (drm_encoder->crtc == crtc) {
+			find =1;
+			break;
+		}
+	}
+
+	if (!find) 
+		goto ret_err;
+
+	list_for_each_entry(drm_connector, &crtc->dev->mode_config.encoder_list, head) {
+		if (drm_connector->encoder == drm_encoder) {
+		return to_sunxi_connector(drm_connector)->disp_out_type;
+		}
+	}
+
+ret_err:
+	return DISP_OUTPUT_TYPE_NONE;
+}
+
+static inline struct drm_encoder *sunxi_crtc_get_encoder(struct drm_crtc *crtc)
+{
+	struct drm_encoder *encoder;
+
+	list_for_each_entry(encoder, &crtc->dev->mode_config.encoder_list, head) {
+		if (encoder->crtc == crtc) {
+			return encoder;
+		}
+	}
+
+	return NULL;
+}
+
+static void sunxi_drm_crtc_disable(struct drm_crtc *crtc)
+{
+	/* disable is the crtc does not be used, so becareful */
+	struct sunxi_drm_crtc *sunxi_crtc = to_sunxi_crtc(crtc);
+	struct sunxi_hardware_ops *hw_ops = sunxi_crtc->hw_res->ops;
+
+	DRM_DEBUG_KMS("[%d] crtc_id:%d \n",__LINE__,sunxi_crtc->crtc_id);
+
+	hw_ops->disable(crtc);
+}
+
+static void sunxi_drm_crtc_enable(struct drm_crtc *crtc)
+{
+	/* disable is the crtc does not be used, so becareful */
+	struct sunxi_drm_crtc *sunxi_crtc = to_sunxi_crtc(crtc);
+	struct sunxi_hardware_ops *hw_ops = sunxi_crtc->hw_res->ops;
+
+	DRM_DEBUG_KMS("[%d] crtc_id:%d \n",__LINE__,sunxi_crtc->crtc_id);
+
+	hw_ops->enable(crtc);
+}
+
+static void sunxi_drm_crtc_dpms(struct drm_crtc *crtc, int mode)
+{
+	/* dpm just open the dmps , nothing about crtc used */
+	struct sunxi_drm_crtc *sunxi_crtc;
+	bool inused, enable;
+	struct sunxi_hardware_ops *hw_ops;
+
+	DRM_DEBUG_KMS("[%d] mode[%d]\n",__LINE__,mode);
+
+	sunxi_crtc = to_sunxi_crtc(crtc);
+	hw_ops = sunxi_crtc->hw_res->ops;
+
+	/* on :clk, irq, output ok
+	* standby suspend: disable irq
+	* off: disable irq,
+	* if on we must display the content when off
+	*/
+
+	inused = drm_helper_crtc_in_use(crtc);
+	switch (mode) {
+	case DRM_MODE_DPMS_ON:
+		if (inused) {
+			if (sunxi_crtc->dpms > mode) {
+				/* make sure display the last off content. */
+				enable = 1;
+				sunxi_set_global_cfg(crtc, MANAGER_ENABLE_DIRTY, &enable);
+				sunxi_crtc->update_frame_user_cnt++;
+			}
+			sunxi_drm_crtc_enable(&sunxi_crtc->drm_crtc);
+		}
+		break;
+	case DRM_MODE_DPMS_STANDBY:
+	case DRM_MODE_DPMS_SUSPEND:
+		sunxi_irq_disable(sunxi_crtc->hw_res);
+		break;
+	case DRM_MODE_DPMS_OFF:
+		if (!inused) {
+			sunxi_drm_crtc_finish_pageflip(sunxi_crtc->drm_crtc.dev, sunxi_crtc);
+			sunxi_crtc->update_frame_user_cnt = 0;
+			sunxi_crtc->update_frame_ker_cnt = 0;
+		}
+		drm_vblank_off(crtc->dev, sunxi_crtc->crtc_id);
+		enable = 0;
+		/* in fact disable the cfg not updata to hardware */
+		sunxi_set_global_cfg(crtc, MANAGER_ENABLE_DIRTY, &enable);
+		sunxi_drm_crtc_disable(&sunxi_crtc->drm_crtc);
+		break;
+	default:
+		return;
+	}
+	sunxi_crtc->dpms = mode;
+}
+
+static void sunxi_drm_crtc_prepare(struct drm_crtc *crtc)
+{
+	struct sunxi_drm_crtc *sunxi_crtc = to_sunxi_crtc(crtc);
+	//struct disp_manager_data *global_cfgs = sunxi_crtc->global_cfgs;
+
+	DRM_DEBUG_KMS("[%d]\n",__LINE__);
+
+	/* we colse the enhance, smartlight etc. we reset the hw */
+	//memset(&global_cfgs->config, 0, sizeof(struct disp_manager_info));
+
+	sunxi_drm_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);
+	sunxi_reset_plane(crtc);
+	sunxi_drm_crtc_dpms(crtc, DRM_MODE_DPMS_ON);
+	/*find the fb plane*/
+	if(sunxi_set_fb_plane(crtc, 0, 0))
+		DRM_ERROR("failed set fb_plane.\n");
+	/* clear the wait for event*/
+	sunxi_drm_crtc_finish_pageflip(sunxi_crtc->drm_crtc.dev, sunxi_crtc);
+	sunxi_crtc->user_skip_cnt = 0;
+	sunxi_crtc->ker_skip_cnt = 0;
+	sunxi_crtc->ker_update_frame = 0;
+	sunxi_crtc->update_frame_ker_cnt = 0;
+	sunxi_crtc->update_frame_user_cnt = 0;
+}
+
+static void sunxi_drm_crtc_commit(struct drm_crtc *crtc)
+{
+	struct sunxi_drm_crtc *sunxi_crtc = to_sunxi_crtc(crtc);
+	struct sunxi_hardware_ops *ops = sunxi_crtc->hw_res->ops;
+
+	DRM_DEBUG_KMS("[%d]  crtc_id:%d\n", __LINE__, sunxi_crtc->crtc_id);
+	/*commit the global cfg and plane cfgs to the reg or memory cache*/
+	ops->updata_reg(crtc);
+}
+
+static bool sunxi_drm_crtc_mode_fixup(struct drm_crtc *crtc,
+			    const struct drm_display_mode *mode,
+			    struct drm_display_mode *adjusted_mode)
+{
+	DRM_DEBUG_KMS("[%d]\n", __LINE__);
+	/* check it  for the linebuf  and other?*/
+	return true;
+}
+
+bool sunxi_set_global_cfg(struct drm_crtc *crtc,
+        int type, void *data)
+{
+	struct sunxi_drm_crtc *sunxi_crtc = to_sunxi_crtc(crtc);
+	struct disp_manager_data *global_cfg = sunxi_crtc->global_cfgs;
+	struct drm_display_mode *mode = NULL;
+
+	DRM_DEBUG_KMS("[%d] id:%d\n", __LINE__, crtc->base.id);
+
+	switch (type) {
+	/* screen windows size */
+	case MANAGER_ENABLE_DIRTY:
+		global_cfg->config.enable = *((bool *)data);
+		global_cfg->flag |= MANAGER_ENABLE_DIRTY;
+		break;
+	case MANAGER_SIZE_DIRTY:
+		mode = (struct drm_display_mode *)(data);
+		global_cfg->config.size.width = mode->hdisplay;
+		global_cfg->config.size.height = mode->vdisplay;
+		global_cfg->flag |= MANAGER_SIZE_DIRTY;
+		break;
+	case MANAGER_BACK_COLOR_DIRTY:
+		/* background  color*/
+		global_cfg->config.back_color.alpha = 0;
+		global_cfg->config.back_color.red = 0;
+		global_cfg->config.back_color.blue = 0;
+		global_cfg->config.back_color.green = 0;
+		global_cfg->flag |= MANAGER_BACK_COLOR_DIRTY;
+		break;
+	case MANAGER_CK_DIRTY:
+		/*color key*/
+		global_cfg->flag |= MANAGER_CK_DIRTY;
+		break;
+	case MANAGER_COLOR_RANGE_DIRTY:
+		global_cfg->flag |= MANAGER_COLOR_RANGE_DIRTY;
+		break;
+	case MANAGER_COLOR_SPACE_DIRTY:
+		global_cfg->config.cs = *((char *)(data));
+		global_cfg->flag |= MANAGER_COLOR_SPACE_DIRTY;
+		break;
+	case MANAGER_BLANK_DIRTY:
+		global_cfg->config.blank = *((bool *)data);
+		global_cfg->flag |= MANAGER_BLANK_DIRTY;
+		break;
+	case MANAGER_DEHZ_DIRTY:
+		global_cfg->config.de_freq = *(unsigned int*)(data);
+		break;
+	case MANAGER_TCON_DIRTY:
+		global_cfg->config.hwdev_index = *((int*)(data));
+		global_cfg->flag |= MANAGER_ENABLE_DIRTY;
+		break;
+	default:
+		global_cfg->flag = MANAGER_ALL_DIRTY;
+		DRM_ERROR("failed page flip request.\n");
+	}
+
+	return true;
+}
+
+static int sunxi_crtc_updata_fb(struct drm_crtc *crtc, int x, int y)
+{
+	struct sunxi_drm_crtc *sunxi_crtc = to_sunxi_crtc(crtc);
+	unsigned int crtc_w;
+	unsigned int crtc_h;
+	unsigned int fb_src_w;
+	unsigned int fb_src_h;
+	struct sunxi_drm_framebuffer *sunxi_fb;
+	struct drm_plane *plane = sunxi_crtc->fb_plane;
+
+	if (plane == NULL) {
+		DRM_ERROR("get fb plane err.\n");
+		return -EINVAL; 
+	}
+	sunxi_fb = to_sunxi_fb(crtc->fb);
+	crtc_w = crtc->mode.hdisplay;
+	crtc_h = crtc->mode.vdisplay;
+
+	fb_src_w = crtc->fb->width - x;
+	fb_src_h = crtc->fb->height - y;
+	if (sunxi_fb->fb_flag & SUNXI_FBDEV_FLAGS) {
+		fb_src_h = crtc->fb->height / FBDEV_BUF_NUM;
+	}
+
+	return sunxi_update_plane(plane, crtc, crtc->fb, 0, 0, crtc_w, crtc_h,
+				    x<<16, y<<16, fb_src_w<<16, fb_src_h<<16);
+}
+
+static int sunxi_drm_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
+					  struct drm_framebuffer *old_fb)
+{
+	int ret;
+
+	DRM_DEBUG_KMS("[%d] %p\n",__LINE__, crtc->fb);
+
+	ret = sunxi_crtc_updata_fb(crtc, x, y);
+	if (ret)
+		return ret;
+	sunxi_drm_crtc_commit(crtc);
+
+	return 0;
+}
+
+static int sunxi_drm_crtc_mode_set(struct drm_crtc *crtc, struct drm_display_mode *mode,
+			  struct drm_display_mode *adjusted_mode, int x, int y,
+			  struct drm_framebuffer *old_fb)
+{
+	struct sunxi_drm_crtc *sunxi_crtc = to_sunxi_crtc(crtc);
+
+	DRM_DEBUG_KMS("[%d] \n",__LINE__);
+
+	if (!crtc->fb) {
+		DRM_ERROR("give us a NULL fb, disable the crtc.\n");
+		sunxi_drm_crtc_disable(crtc);
+		return -EINVAL;
+	}
+
+	sunxi_set_global_cfg(crtc, MANAGER_SIZE_DIRTY, adjusted_mode);
+	sunxi_drm_crtc_updata_fps(sunxi_crtc->crtc_id, adjusted_mode->vrefresh);
+
+	return sunxi_crtc_updata_fb(crtc, x, y);
+}
+
+static void sunxi_drm_crtc_load_lut(struct drm_crtc *crtc)
+{
+	DRM_DEBUG_KMS("[%d] \n",__LINE__);
+	/* drm framework doesn't check NULL */
+}
+
+static struct drm_crtc_helper_funcs sunxi_crtc_helper_funcs = {
+	.dpms		= sunxi_drm_crtc_dpms,
+	.prepare	= sunxi_drm_crtc_prepare,
+	.commit		= sunxi_drm_crtc_commit,
+	.mode_fixup	= sunxi_drm_crtc_mode_fixup,
+	.mode_set	= sunxi_drm_crtc_mode_set,
+	.mode_set_base	= sunxi_drm_crtc_mode_set_base,
+	.load_lut	= sunxi_drm_crtc_load_lut,
+	.disable	= sunxi_drm_crtc_disable,
+};
+
+static int sunxi_manage_filp_data(struct drm_crtc *crtc,
+        	struct drm_pending_vblank_event *event)
+{
+	struct sunxi_flip_user_date flip_data;
+	__u32  plane_id = 0;
+	int zoder = 0;
+	struct sunxi_drm_crtc *sunxi_crtc;
+
+	DRM_DEBUG_KMS("[%d] \n", __LINE__);
+
+	sunxi_crtc = to_sunxi_crtc(crtc);
+	if (event && event->event.user_data) {
+		if (copy_from_user(&flip_data, (void __user *)event->event.user_data,
+				sizeof(struct sunxi_flip_user_date)) != 0) {
+			return -EINVAL;
+		}
+
+		plane_id = flip_data.plane_id;
+		zoder = flip_data.zpos;
+	}else{
+		if (sunxi_crtc->fb_plane != NULL)
+			return 0;
+	}
+
+	return sunxi_set_fb_plane(crtc, plane_id, zoder);
+}
+
+static int sunxi_drm_crtc_page_flip(struct drm_crtc *crtc,
+				      struct drm_framebuffer *fb,
+				      struct drm_pending_vblank_event *event)
+{
+	struct drm_device *dev = crtc->dev;
+	struct sunxi_drm_crtc *sunxi_crtc = to_sunxi_crtc(crtc);
+	struct drm_framebuffer *old_fb = crtc->fb;
+
+	int ret = -EINVAL;
+
+	DRM_DEBUG_KMS("(%d) \n", __LINE__);
+
+	/* when the page flip is requested, crtc's dpms should be on */
+	if (sunxi_crtc->dpms > DRM_MODE_DPMS_ON) {
+		DRM_ERROR("failed page flip request.\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&dev->struct_mutex);
+
+	ret = drm_vblank_get(dev, sunxi_crtc->crtc_id);
+	if (ret) {
+		DRM_DEBUG("failed to acquire vblank counter\n");
+		goto out;
+	}
+
+	crtc->fb = fb;
+	ret = sunxi_manage_filp_data(crtc, event);
+	if (ret < 0) {
+		DRM_ERROR("failed manage the page flip event.\n");
+		goto out;
+	}
+
+	ret = sunxi_drm_crtc_mode_set_base(crtc, crtc->x, crtc->y, NULL);
+	if (ret) {
+		crtc->fb = old_fb;
+		drm_vblank_put(dev, sunxi_crtc->crtc_id);
+		goto out;
+	}
+	if (event) {
+		/* make sure the list are the updata list in irq handle */
+		spin_lock_irq(&dev->event_lock);
+		list_add_tail(&event->base.link,
+			&sunxi_crtc->pageflip_event_list);
+		spin_unlock_irq(&dev->event_lock);
+	}
+out:
+	mutex_unlock(&dev->struct_mutex);
+	return ret;
+}
+
+void sunxi_drm_crtc_finish_pageflip(struct drm_device *dev,
+        struct sunxi_drm_crtc *sunxi_crtc)
+{
+	struct drm_pending_vblank_event *e, *t;
+	unsigned long flags;
+
+	DRM_DEBUG_KMS("[%d] \n", __LINE__);
+
+	spin_lock_irqsave(&dev->event_lock, flags);
+
+	list_for_each_entry_safe(e, t, &sunxi_crtc->pageflip_event_list, base.link) {
+
+		list_del(&e->base.link);
+		drm_send_vblank_event(dev, sunxi_crtc->crtc_id, e);
+		drm_vblank_put(dev, sunxi_crtc->crtc_id);
+	}
+
+	spin_unlock_irqrestore(&dev->event_lock, flags);
+}
+
+int sunxi_drm_info_fb_ioctl(struct drm_device *dev, void *data,
+				struct drm_file *file_priv)
+{
+	int ret = 0;
+	struct drm_crtc *crtc;
+	struct sunxi_fb_info_cmd *fb_info_plane;
+	struct drm_mode_object *obj;
+	struct sunxi_drm_crtc *sunxi_crtc;
+	struct sunxi_drm_plane *sunxi_plane;
+	fb_info_plane =  (struct sunxi_fb_info_cmd *)data;
+
+	DRM_DEBUG_KMS("setfb_ioctl: crtc_id[%d] plane[%d] zoder[%d]\n",
+	fb_info_plane->crtc_id, fb_info_plane->plane_id, fb_info_plane->zorder);
+
+	obj = drm_mode_object_find(dev, fb_info_plane->crtc_id,
+				DRM_MODE_OBJECT_CRTC);
+	if (!obj) {
+		ret = -EINVAL;
+		goto out;
+	}
+	crtc = obj_to_crtc(obj);
+	sunxi_crtc = to_sunxi_crtc(crtc);
+	if (fb_info_plane->set_get) {
+		return sunxi_set_fb_plane(crtc, fb_info_plane->plane_id, fb_info_plane->zorder);
+	}else {
+		if (sunxi_crtc->fb_plane) {
+			sunxi_plane = to_sunxi_plane(sunxi_crtc->fb_plane);
+			fb_info_plane->plane_id = sunxi_crtc->fb_plane->base.id;
+			fb_info_plane->zorder = sunxi_plane->plane_cfg->config.info.zorder;
+			return 0;
+		}   
+	}
+out:
+	DRM_ERROR("[%d] info_fb_ioctl err....\n", __LINE__);
+	return -EINVAL;
+}
+
+int sunxi_drm_flip_ioctl(struct drm_device *dev, void *data,
+				struct drm_file *file_priv)
+{
+	int ret = 0;
+	struct drm_crtc *crtc;
+	struct sunxi_flip_user_date *flip;
+	struct drm_mode_object *obj;
+
+	flip = (struct sunxi_flip_user_date *)data;
+	obj = drm_mode_object_find(dev, flip->crtc_id,
+				DRM_MODE_OBJECT_CRTC);
+	if (!obj) {
+		ret = -EINVAL;
+		goto out;
+	}
+	crtc = obj_to_crtc(obj);
+	sunxi_drm_crtc_commit(crtc);
+
+out:
+	return ret;
+}
+
+static void sunxi_drm_crtc_destroy(struct drm_crtc *crtc)
+{
+	struct sunxi_drm_crtc *sunxi_crtc = to_sunxi_crtc(crtc);
+	struct sunxi_hardware_res *hw_res;
+
+	DRM_DEBUG_KMS("[%d] \n", __LINE__);
+
+	hw_res = sunxi_crtc->hw_res;
+	drm_crtc_cleanup(crtc);
+
+	if (hw_res) {
+		sunxi_hwres_destroy(hw_res);
+	}
+	kfree(sunxi_crtc->plane_array);
+
+	kfree(sunxi_crtc);
+}
+
+bool sunxi_drm_crtc_set3d(struct drm_crtc *crtc, bool on_off)
+{
+	return 1;
+}
+
+bool sunxi_drm_crtc_enhance_hf(struct drm_crtc *crtc, bool on_off)
+{
+	return 1;
+}
+
+bool sunxi_drm_crtc_enhance(struct drm_crtc *crtc, bool on_off)
+{
+	return 1;
+}
+
+bool sunxi_drm_crtc_smart(struct drm_crtc *crtc, bool on_off)
+{
+	return 1;
+}
+
+inline int sunxi_mode_check(int new_mode, int old_mode)
+{
+	int mode_marsk = (1 << CRTC_MODE_LAST)-1;
+	new_mode &= mode_marsk;
+	old_mode &= mode_marsk;
+	return new_mode^old_mode;
+}
+
+static int sunxi_drm_crtc_set_property(struct drm_crtc *crtc,
+					struct drm_property *property,
+					uint64_t val)
+{
+	struct drm_device *dev = crtc->dev;
+	struct sunxi_drm_private *dev_priv = dev->dev_private;
+	uint64_t new_mode = val;
+	uint64_t old_mode;
+	int ret;
+	enum sunxi_crtc_mode mode = CRTC_MODE_3D;
+
+	DRM_DEBUG_KMS("[%d] \n", __LINE__);
+
+	if (property == dev_priv->crtc_mode_property) {
+		ret = drm_object_property_get_value(&crtc->base, property, &old_mode);
+		if (ret) {
+			DRM_ERROR("failed to get crtc disp_mode value.\n");
+			return -EINVAL;
+		}
+
+		ret = sunxi_mode_check(new_mode, old_mode);
+		while (ret && mode < CRTC_MODE_LAST) {
+			if(ret & (1 << mode)) {
+				bool on_off = new_mode & (1 << mode);
+				switch (mode) {
+				case CRTC_MODE_3D:
+					sunxi_drm_crtc_set3d(crtc, on_off);
+					break;
+				case CRTC_MODE_ENHANCE:
+					sunxi_drm_crtc_enhance(crtc, on_off);
+					break;
+				case CRTC_MODE_ENHANCE_HF:
+					sunxi_drm_crtc_enhance_hf(crtc, on_off);
+					break;
+				case CRTC_MODE_SMART_LIGHT:
+					sunxi_drm_crtc_smart(crtc, on_off);
+					break;
+				default:
+					break;
+				}
+			}
+			mode++;
+		}
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int sunxi_crtc_set_config(struct drm_mode_set *set)
+{
+	int ret = -EINVAL;
+	struct sunxi_drm_crtc *sunxi_crtc;
+	struct disp_manager_data *save_global_cfgs;
+
+	sunxi_crtc = to_sunxi_crtc(set->crtc);
+	DRM_DEBUG_KMS("[%d] fb:%p \n", __LINE__,set->fb);
+
+	save_global_cfgs = sunxi_crtc->global_cfgs;
+	sunxi_crtc->global_cfgs = kzalloc(sizeof(struct disp_manager_data), GFP_KERNEL);
+	if (sunxi_crtc->global_cfgs == NULL) {
+		DRM_ERROR("failed to allocate global_cfgs.\n");
+		return -ENOMEM;
+	}
+	/* change the */
+	ret = drm_crtc_helper_set_config(set);
+
+	if (ret) {
+		kfree(sunxi_crtc->global_cfgs);
+		sunxi_crtc->global_cfgs = save_global_cfgs;
+	}else{
+		kfree(save_global_cfgs);
+	}
+	return ret;
+}
+
+static struct drm_crtc_funcs sunxi_crtc_funcs = {
+	.set_config	= sunxi_crtc_set_config,
+	.page_flip	= sunxi_drm_crtc_page_flip,
+	.destroy	= sunxi_drm_crtc_destroy,
+	.set_property	= sunxi_drm_crtc_set_property,
+};
+
+static const struct drm_prop_enum_list mode_names[] = {
+	{ CRTC_MODE_3D,     "3d_mode" },// ToDo for many 3D mode, will set it to layer
+	{ CRTC_MODE_ENHANCE, "enhance" },
+	{ CRTC_MODE_ENHANCE_HF, "enhance_half" },
+	{ CRTC_MODE_SMART_LIGHT, "smart_light" },//ToDo
+};
+
+static void sunxi_drm_crtc_attach_mode_property(struct drm_crtc *crtc)
+{
+	struct drm_device *dev = crtc->dev;
+	struct  sunxi_drm_private *dev_priv = dev->dev_private;
+	struct drm_property *prop;
+
+	DRM_DEBUG_KMS("[%d] \n", __LINE__);
+
+	prop = dev_priv->crtc_mode_property;
+	if (!prop) {
+		prop = drm_property_create_bitmask(dev, 0, "disp_mode", mode_names,
+						ARRAY_SIZE(mode_names));
+		if (!prop)
+			return;
+
+		dev_priv->crtc_mode_property = prop;
+	}
+
+	drm_object_attach_property(&crtc->base, prop, 0);
+}
+
+bool sunxi_de_enable(void *data)
+{
+	struct sunxi_drm_crtc *sunxi_crtc = to_sunxi_crtc(data);
+
+	DRM_DEBUG_KMS("[%d] \n", __LINE__);
+
+	sunxi_clk_enable(sunxi_crtc->hw_res);
+	sunxi_drm_crtc_clk_enable(sunxi_crtc->crtc_id);
+	sunxi_irq_enable(sunxi_crtc->hw_res);
+	return true;
+}
+
+bool sunxi_de_disable(void *data)
+{
+	struct sunxi_drm_crtc *sunxi_crtc = to_sunxi_crtc(data);
+
+	DRM_DEBUG_KMS("[%d] \n", __LINE__);
+
+	sunxi_drm_crtc_clk_disable(sunxi_crtc->crtc_id);
+	sunxi_irq_free(sunxi_crtc->hw_res);
+	sunxi_clk_disable(sunxi_crtc->hw_res);
+	return true;
+}
+
+void sunxi_de_vsync_proc(void *data)
+{
+	struct sunxi_drm_crtc *sunxi_crtc = to_sunxi_crtc(data);
+	int try_count = 1, current_delayed = 0;
+	struct drm_encoder *encoder;
+
+	/* get the Tcon sync line,
+	  * and determine update and try lock times.
+	  */
+	encoder = sunxi_crtc_get_encoder(&sunxi_crtc->drm_crtc);
+	current_delayed = sunxi_encoder_updata_delayed(encoder);
+	if (current_delayed < 0) {
+		DRM_ERROR("crtc_id:%d no more time :%d.\n", sunxi_crtc->crtc_id, current_delayed);
+		goto false;
+	}
+
+	/* move it to the delayed work? THK a lot. in here */
+	if (sunxi_crtc->chain_irq_enable) {
+		drm_handle_vblank(sunxi_crtc->drm_crtc.dev, sunxi_crtc->crtc_id);
+		sunxi_drm_crtc_finish_pageflip(sunxi_crtc->drm_crtc.dev, sunxi_crtc);
+	}
+
+	if(sunxi_crtc->update_frame_ker_cnt == sunxi_crtc->update_frame_user_cnt)
+		return ;
+
+	try_count = current_delayed * 20;
+	if (try_count < 0) {
+		DRM_ERROR("crtc_id:%d  no more time :%d.\n", sunxi_crtc->crtc_id, current_delayed);
+		goto false; 
+	}
+	while (try_count-- && !spin_trylock(&sunxi_crtc->update_reg_lock)) {
+		if (!try_count) {
+			DRM_DEBUG_KMS("crtc_id:%d   lose the lock.\n", sunxi_crtc->crtc_id);
+			goto false;
+		}
+	}
+	/* in_update_frame  will use if DE can set  the layer(hardware register) for 1 or  */
+	if (!sunxi_crtc->in_update_frame &&
+			sunxi_crtc->update_frame_ker_cnt != sunxi_crtc->update_frame_user_cnt) {
+		sunxi_drm_sync_reg(sunxi_crtc->crtc_id);
+		sunxi_drm_updata_reg(sunxi_crtc->crtc_id);
+
+		/*careful for unsinged long roll */
+		sunxi_crtc->user_skip_cnt += 
+		sunxi_crtc->update_frame_user_cnt - (sunxi_crtc->update_frame_ker_cnt + 1);
+		sunxi_crtc->update_frame_ker_cnt = sunxi_crtc->update_frame_user_cnt;
+	}
+
+	spin_unlock(&sunxi_crtc->update_reg_lock);
+
+	schedule_work(&sunxi_crtc->delayed_work);
+	return ;
+
+false:
+	if(sunxi_crtc->update_frame_ker_cnt != sunxi_crtc->update_frame_user_cnt) {
+		sunxi_crtc->ker_skip_cnt++;
+	}
+	return ;
+}
+
+bool sunxi_de_updata_reg(void *data)
+{
+	struct sunxi_drm_crtc *sunxi_crtc = to_sunxi_crtc(data);
+	struct disp_manager_data *global_cfgs = sunxi_crtc->global_cfgs;
+	struct sunxi_drm_connector *sunxi_connector;
+	struct drm_connector *connector;
+
+	int i;
+	struct sunxi_drm_plane *sunxi_plane;
+
+	DRM_DEBUG_KMS("[%d] crtc_id:%d\n", __LINE__, sunxi_crtc->crtc_id);
+
+	connector = sunxi_crtc_get_conector(&sunxi_crtc->drm_crtc);
+	if(!connector)
+		return false;
+	sunxi_connector = to_sunxi_connector(connector);
+
+	spin_lock(&sunxi_crtc->update_reg_lock);
+	sunxi_crtc->update_frame_user_cnt++;
+
+	if (global_cfgs->flag) {
+		DRM_DEBUG_KMS("[%d]crtc_id:%d cfg:0x%x mux:%d, size(%d,%d)\n", __LINE__,
+		sunxi_crtc->crtc_id, global_cfgs->flag, sunxi_crtc->global_cfgs->config.hwdev_index,
+		sunxi_crtc->global_cfgs->config.size.width, sunxi_crtc->global_cfgs->config.size.height);
+
+		sunxi_drm_apply_cache(sunxi_crtc->crtc_id, sunxi_crtc->global_cfgs);
+		global_cfgs->flag = 0;
+	}
+
+	if (sunxi_crtc->has_delayed_updata) {
+		for (i = 0; i < sunxi_crtc->plane_of_de; i++) {
+			sunxi_plane = to_sunxi_plane(sunxi_crtc->plane_array[i]);
+			if (sunxi_plane->delayed_updata) {
+				sunxi_plane->hw_res->ops->updata_reg(sunxi_plane);
+				sunxi_plane->delayed_updata = 0;
+			}
+		}
+		sunxi_crtc->has_delayed_updata = 0;
+	}
+
+	sunxi_drm_updata_crtc(sunxi_crtc, sunxi_connector);
+
+	spin_unlock(&sunxi_crtc->update_reg_lock);
+
+	return true;
+}
+
+bool sunxi_de_query_irq(void *irq_data, int need_irq)
+{
+	//struct sunxi_drm_crtc *sunxi_crtc = to_sunxi_crtc(irq_data);
+	return false;
+}
+/*
+void sunxi_de_vsync_delayed_work(void *data)
+{
+
+}
+*/
+struct sunxi_hardware_ops de_hw_ops = {
+	.reset          = NULL,
+	.enable         = sunxi_de_enable,
+	.disable        = sunxi_de_disable,
+	.updata_reg     = sunxi_de_updata_reg,
+	.vsync_proc   = sunxi_de_vsync_proc,
+	.irq_query    = NULL,
+	.vsync_delayed_do = NULL,
+};
+
+irqreturn_t sunxi_crtc_vsync_handle(int irq, void *data)
+{
+	int i;
+	struct sunxi_drm_connector *sunxi_connector;
+	struct sunxi_drm_encoder *sunxi_encoder;
+	struct sunxi_drm_plane *sunxi_plane;
+	struct drm_encoder *encoder;
+	struct drm_connector *drm_connector;
+	struct sunxi_drm_crtc *sunxi_crtc = to_sunxi_crtc(data);
+	void (*vsync_proc)(void *irq_data);
+
+	DRM_DEBUG_KMS("[%d] \n", __LINE__);
+
+	if (!drm_helper_crtc_in_use(data))
+		goto handle_end;
+
+	if (!sunxi_irq_query(sunxi_crtc->hw_res, data, QUERY_VSYNC_IRQ))
+		return IRQ_HANDLED;
+
+	vsync_proc = sunxi_crtc->hw_res->ops->vsync_proc;
+	if (vsync_proc != NULL)
+		vsync_proc(sunxi_crtc);
+
+	for (i = 0; i < sunxi_crtc->plane_of_de; i++) {
+		sunxi_plane = to_sunxi_plane(sunxi_crtc->plane_array[i]);
+		vsync_proc = sunxi_plane->hw_res->ops->vsync_proc;
+		if(vsync_proc != NULL)
+			vsync_proc(sunxi_plane);
+	}
+	/* we hardware only support 1 chain */
+	encoder = sunxi_get_encoder(&sunxi_crtc->drm_crtc);
+	if (!encoder)
+		goto handle_end;
+	sunxi_encoder = to_sunxi_encoder(encoder);
+	if (!sunxi_encoder)
+		goto handle_end;
+	vsync_proc = sunxi_encoder->hw_res->ops->vsync_proc;
+	if (vsync_proc != NULL)
+		vsync_proc(sunxi_encoder);
+
+	drm_connector = sunxi_get_conct(encoder);
+	if (!drm_connector)
+		goto handle_end;
+	sunxi_connector = to_sunxi_connector(drm_connector);
+	vsync_proc = sunxi_connector->hw_res->ops->vsync_proc;
+	if(vsync_proc != NULL)
+		vsync_proc(sunxi_connector);
+
+handle_end:
+	return IRQ_HANDLED;
+}
+
+int sunxi_drm_enable_vblank(struct drm_device *dev, int crtc)
+{
+	struct sunxi_drm_crtc *sunxi_crtc = NULL;
+	/* crtc start from 0 */
+	sunxi_crtc = get_sunxi_crt(dev, crtc);
+	sunxi_crtc->chain_irq_enable = 1;
+
+	DRM_DEBUG_KMS("[%d] \n", __LINE__);
+
+	return 0;
+}
+
+void sunxi_drm_disable_vblank(struct drm_device *dev, int crtc)
+{
+	struct sunxi_drm_crtc *sunxi_crtc = NULL;
+	sunxi_crtc = get_sunxi_crt(dev, crtc);
+	sunxi_crtc->chain_irq_enable = 0;
+
+	DRM_DEBUG_KMS("[%d] \n", __LINE__);
+
+	return ;
+}
+
+void sunxi_crtc_delay_work(struct work_struct *work)
+{
+	int i;
+	struct sunxi_drm_plane  *sunxi_plane;
+	struct sunxi_drm_crtc *sunxi_crtc =
+	container_of(work, struct sunxi_drm_crtc, delayed_work);
+	void (*vsync_delayed_do)(void *data);
+
+	DRM_DEBUG_KMS("[%d] \n", __LINE__);
+
+	vsync_delayed_do = sunxi_crtc->hw_res->ops->vsync_delayed_do;
+	if (vsync_delayed_do != NULL) {
+		vsync_delayed_do(sunxi_crtc);
+	}
+	for (i = 0; i < sunxi_crtc->plane_of_de; i++) {
+		sunxi_plane = to_sunxi_plane(sunxi_crtc->plane_array[i]);
+		vsync_delayed_do = sunxi_plane->hw_res->ops->vsync_delayed_do;
+		if(vsync_delayed_do != NULL)
+			vsync_delayed_do(sunxi_plane);
+	}
+}
+
+int sunxi_drm_crtc_create(struct drm_device *dev,
+	unsigned int nr, struct sunxi_hardware_res *hw_res)
+{
+	struct sunxi_drm_crtc *sunxi_crtc = NULL; 
+	struct drm_crtc *crtc = NULL;
+	struct drm_property *prop = NULL;
+	struct drm_plane *drm_plane = NULL;
+	struct disp_layer_config_data *plane_cfg;
+	int i = 0, j = 0, z = 0, v = 0;
+
+	DRM_DEBUG_KMS("[%d]\n", __LINE__);
+
+	if (!hw_res) {
+		DRM_ERROR("sunxi crtc must have hardware resource.\n");
+		return -EINVAL;
+	}
+
+	sunxi_crtc = kzalloc(sizeof(*sunxi_crtc), GFP_KERNEL);
+	if (!sunxi_crtc) {
+		DRM_ERROR("failed to allocate sunxi crtc\n");
+		goto crtc_err;
+	}
+
+	sunxi_crtc->crtc_id = nr;
+	crtc = &sunxi_crtc->drm_crtc;
+
+	/*to the DE BSP get nr of lyr and chnl*/
+	sunxi_crtc->chn_count = sunxi_drm_get_num_chns_by_crtc(nr);
+	sunxi_crtc->plane_of_de = sunxi_drm_get_plane_by_crtc(nr);
+	if (sunxi_crtc->plane_of_de < 0) {
+		DRM_ERROR("failed to get the lyr count.\n");
+		goto crtc_err;
+	}
+
+	prop = drm_property_create_range(dev, 0, "zpos", 0,
+				sunxi_crtc->plane_of_de - 1);
+	if (!prop)
+		goto prop_err;
+	sunxi_crtc->plane_zpos_property = prop;
+
+	prop = drm_property_create_range(dev, DRM_MODE_PROP_IMMUTABLE, "channel_id", 0,
+						sunxi_crtc->chn_count - 1);
+	if (!prop)
+		goto prop_err;
+
+	sunxi_crtc->channel_id_property = prop;
+	/* Currently chosse 4, if de change we will change it */
+	z = sunxi_drm_get_crtc_pipe_plane(nr, 0);
+	prop = drm_property_create_range(dev, DRM_MODE_PROP_IMMUTABLE, "plane_id_chn", 0,
+					z - 1);
+	if (!prop)
+		goto prop_err;
+	sunxi_crtc->plane_id_chn_property = prop;
+
+	sunxi_crtc->plane_array = 
+	kzalloc(sizeof(struct drm_plane*) * sunxi_crtc->plane_of_de, GFP_KERNEL);
+	if (!sunxi_crtc->plane_array) {
+		DRM_ERROR("failed to allocate sunxi plane array.\n");
+		goto array_err;
+	}
+
+	sunxi_crtc->plane_cfgs = 
+	kzalloc(sizeof(struct disp_layer_config_data) * sunxi_crtc->plane_of_de, GFP_KERNEL);
+	if (!sunxi_crtc->plane_cfgs) {
+		DRM_ERROR("failed to allocate sunxi plane array.\n");
+		goto plane_cfgs_err;
+	}
+
+	for (j = 0, v = 0; j < sunxi_crtc->chn_count; j++) {
+		z = sunxi_drm_get_crtc_pipe_plane(nr, j);
+		for (i = 0; i < z; i++, v++) {
+			plane_cfg = sunxi_crtc->plane_cfgs + v;
+			drm_plane = sunxi_plane_init(dev, &sunxi_crtc->drm_crtc, plane_cfg, j, i, false);
+			if (!drm_plane) {
+				DRM_ERROR("failed to allocate sunxi plane.\n");
+				goto plane_err;
+			}
+			sunxi_crtc->plane_array[v] = drm_plane;
+		}
+	}
+
+	sunxi_crtc->global_cfgs = kzalloc(sizeof(struct disp_manager_data), GFP_KERNEL);
+	if (!sunxi_crtc->global_cfgs) {
+		DRM_ERROR("failed to allocate sunxi crtc global_cfgs.\n");
+		goto plane_err;
+	}
+	/* init the de hardware, clock all on, contorl the sub switch */
+	sunxi_crtc->hw_res = hw_res;
+	if (hw_res->ops == NULL) {
+		hw_res->ops = &de_hw_ops;
+		hw_res->irq_arg = (void*)sunxi_crtc;
+		hw_res->irq_handle = sunxi_crtc_vsync_handle;
+		hw_res->irq_uesd = false;
+	}
+
+	sunxi_updata_crtc_freq(clk_get_rate(hw_res->clk));
+
+	INIT_LIST_HEAD(&sunxi_crtc->pageflip_event_list);
+	INIT_WORK(&sunxi_crtc->delayed_work, sunxi_crtc_delay_work);
+
+	spin_lock_init(&sunxi_crtc->update_reg_lock);
+	drm_crtc_init(dev, crtc, &sunxi_crtc_funcs);
+	drm_crtc_helper_add(crtc, &sunxi_crtc_helper_funcs);
+
+	sunxi_drm_crtc_attach_mode_property(crtc);
+	crtc_array[nr] = &sunxi_crtc->drm_crtc;
+
+	DRM_INFO("[%d] crtc_id:%d(%d)\n", __LINE__, sunxi_crtc->crtc_id, crtc->base.id);
+
+	return 0;
+
+plane_err:
+	for (i = 0; i < sunxi_crtc->plane_of_de; i++) {
+		if(sunxi_crtc->plane_array[i] != NULL)
+			kfree(sunxi_crtc->plane_array[i]);
+		sunxi_crtc->plane_array[i] = NULL;
+	}
+	kfree(sunxi_crtc->plane_cfgs);
+	sunxi_crtc->plane_cfgs = NULL;
+
+plane_cfgs_err:
+	kfree(sunxi_crtc->plane_array);
+	sunxi_crtc->plane_array = NULL;
+
+array_err:
+prop_err:
+	if(sunxi_crtc->channel_id_property)
+		drm_property_destroy(sunxi_crtc->drm_crtc.dev,
+			sunxi_crtc->channel_id_property);
+
+	if(sunxi_crtc->plane_id_chn_property)
+		drm_property_destroy(sunxi_crtc->drm_crtc.dev,
+			sunxi_crtc->plane_id_chn_property);
+
+	if(sunxi_crtc->plane_zpos_property)
+		drm_property_destroy(sunxi_crtc->drm_crtc.dev,
+			sunxi_crtc->plane_zpos_property);    
+
+	kfree(sunxi_crtc);
+
+crtc_err:
+
+	return -EINVAL;
+}
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_crtc.h b/drivers/gpu/drm/sunxi/sunxi_drm_crtc.h
new file mode 100755
index 0000000..43ed3f8
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_crtc.h
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+/*CRT -->Display Engine*/
+
+#ifndef _SUNXI_DRM_CRTC_H_
+#define _SUNXI_DRM_CRTC_H_
+
+#include <drm/drm_crtc.h>
+
+#define MANAGER_DEHZ_DIRTY  0x00000080
+#define MANAGER_TCON_DIRTY  0x00000100
+
+enum sunxi_crtc_mode {
+	CRTC_MODE_3D,/* normal mode */
+	CRTC_MODE_ENHANCE,	/*enhance the color */
+	CRTC_MODE_ENHANCE_HF,
+	CRTC_MODE_SMART_LIGHT,
+	CRTC_MODE_LAST,
+};
+
+struct sunxi_drm_crtc {
+	struct drm_crtc drm_crtc;
+	/* crtc_id 0 start, make it careful for possible_crtcs from 1 start */
+	int crtc_id;
+	int dpms;
+	/* Channel has zOrder,
+	* and the layers in same channel must check zOrder
+	* with other channel.we adjust zpos to the zOder of
+	* the DE BSP 
+	*/
+	struct drm_property *plane_zpos_property; //0~15  0~7
+	struct drm_property *fill_color_mode_property;
+	/* You can set the zOrder  of the channel in pipe mux,
+	* but you must know the de feature
+	*/
+	struct drm_property *channel_id_property;
+	/* The id in the channel,
+	* the zOrder id is that: 3>2>1>0
+	*/
+	struct drm_property *plane_id_chn_property;
+	struct drm_property *_3d_property;
+
+	int chn_count;
+	int plane_of_de;
+	struct drm_plane **plane_array;
+	struct drm_plane *harware_cursor;
+	struct drm_plane *fb_plane;
+	struct disp_layer_config_data *plane_cfgs;
+
+	struct disp_manager_data *global_cfgs;
+	struct list_head pageflip_event_list;
+	struct work_struct delayed_work;
+	spinlock_t update_reg_lock;
+	unsigned long update_frame_user_cnt;
+	unsigned long user_skip_cnt; 
+	unsigned long update_frame_ker_cnt;
+	unsigned long ker_skip_cnt;
+	bool user_update_frame;
+	bool ker_update_frame;
+	bool has_delayed_updata;
+	bool chain_irq_enable;
+	bool in_update_frame;
+	struct sunxi_hardware_res *hw_res;
+
+};
+
+#define to_sunxi_crtc(x)	container_of(x, struct sunxi_drm_crtc, drm_crtc)
+
+irqreturn_t sunxi_crtc_vsync_handle(int irq, void *data);
+
+int  sunxi_drm_crtc_create(struct drm_device *dev,
+	unsigned int nr, struct sunxi_hardware_res *hw_res);
+
+int sunxi_drm_enable_vblank(struct drm_device *dev, int crtc);
+
+void sunxi_drm_disable_vblank(struct drm_device *dev, int crtc);
+
+struct sunxi_drm_crtc *get_sunxi_crt(struct drm_device *dev, int nr);
+
+bool sunxi_set_global_cfg(struct drm_crtc *crtc, int type, void *data);
+
+int init_crtc_array(int num);
+
+enum disp_output_type get_sunxi_crtc_out_type(int nr);
+
+void sunxi_drm_crtc_finish_pageflip(struct drm_device *dev,
+	struct sunxi_drm_crtc *sunxi_crtc);
+
+int sunxi_drm_flip_ioctl(struct drm_device *dev, void *data,
+				struct drm_file *file_priv);
+
+int sunxi_drm_info_fb_ioctl(struct drm_device *dev, void *data,
+				struct drm_file *file_priv);
+#endif
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_dmabuf.c b/drivers/gpu/drm/sunxi/sunxi_drm_dmabuf.c
new file mode 100755
index 0000000..57fc499
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_dmabuf.c
@@ -0,0 +1,313 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui <cuiyuntao@allwinnter.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <drm/drmP.h>
+#include <drm/sunxi_drm.h>
+#include <linux/dma-buf.h>
+
+#include "sunxi_drm_drv.h"
+#include "sunxi_drm_gem.h"
+#include "sunxi_drm_dmabuf.h"
+
+static int sunxi_gem_attach_dma_buf(struct dma_buf *dmabuf,
+		struct device *dev, struct dma_buf_attachment *attach)
+{
+	struct sunxi_gem_dmabuf_attachment *sunxi_attach;
+
+	sunxi_attach = kzalloc(sizeof(*sunxi_attach), GFP_KERNEL);
+	if (!sunxi_attach)
+		return -ENOMEM;
+
+	sunxi_attach->dir = DMA_NONE;
+	attach->priv = sunxi_attach;
+
+	return 0;
+}
+
+static void sunxi_gem_detach_dma_buf(struct dma_buf *dmabuf,
+					struct dma_buf_attachment *attach)
+{
+	struct sunxi_gem_dmabuf_attachment *sunxi_attach = attach->priv;
+	kfree(sunxi_attach);
+	attach->priv = NULL;
+}
+
+static struct sg_table *sunxi_gem_map_dma_buf(struct dma_buf_attachment *attach,
+					enum dma_data_direction dir)
+{
+	struct sunxi_gem_dmabuf_attachment *sunxi_attach;
+	struct drm_gem_object *gem_obj;
+	struct sunxi_drm_gem_buf *sunxi_buf;
+	struct drm_device *dev;
+	struct scatterlist *rd, *wr;
+	struct sg_table *sgt = NULL;
+	unsigned int i;
+	int nents, ret;
+
+	sunxi_attach = (struct sunxi_gem_dmabuf_attachment *)attach->priv;
+	gem_obj = (struct drm_gem_object *)attach->dmabuf->priv;
+	sunxi_buf = gem_obj->driver_private;
+	dev = gem_obj->dev;
+
+	DRM_DEBUG_PRIME("[%d]\n",__LINE__);
+
+	/* just return current sgt if already requested. */
+	if (sunxi_attach->dir == dir && sunxi_attach->is_mapped)
+		return &sunxi_attach->sgt;
+
+	if (!sunxi_buf) {
+		DRM_ERROR("buffer is null.\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	sgt = &sunxi_attach->sgt;
+	if (sgt->nents == 0) {
+		ret = sg_alloc_table(sgt, sunxi_buf->sgt->orig_nents, GFP_KERNEL);
+		if (ret) {
+			DRM_ERROR("failed to alloc sgt.\n");
+			return ERR_PTR(-ENOMEM);
+		}
+
+		rd = sunxi_buf->sgt->sgl;
+		wr = sgt->sgl;
+		for (i = 0; i < sgt->orig_nents; ++i) {
+			sg_set_page(wr, sg_page(rd), rd->length, rd->offset);
+			rd = sg_next(rd);
+			wr = sg_next(wr);
+		}
+	}
+	/* if attached dev impletment the dma_map_ops, so we must make a sg for it,
+	not use the sunxi_buf's sg. the same reason for the attach.
+	one dma_buf_attach() maybe call many dma_buf_map_attachment() for diffrent dir.
+	*/
+	if(sunxi_attach->dir != DMA_NONE) {
+		/* for invalte and clean cache POC*/
+		dma_unmap_sg(attach->dev, sgt->sgl, sgt->nents, sunxi_attach->dir);
+	}
+
+	if (dir != DMA_NONE) {
+		nents = dma_map_sg(attach->dev, sgt->sgl, sgt->orig_nents, dir);
+		if (!nents) {
+		DRM_ERROR("failed to map sgl with iommu.\n");
+		sg_free_table(sgt);
+		sgt = ERR_PTR(-EIO);
+		}
+	}
+
+	sunxi_attach->is_mapped = true;
+	sunxi_attach->dir = dir;
+
+	DRM_DEBUG_PRIME("buffer size = 0x%lu\n", sunxi_buf->size);
+
+	return sgt;
+}
+
+static void sunxi_gem_unmap_dma_buf(struct dma_buf_attachment *attach,
+						struct sg_table *sgt,
+						enum dma_data_direction dir)
+{
+	dma_unmap_sg(attach->dev, sgt->sgl, sgt->nents, dir);
+	sg_free_table(sgt);
+}
+
+static void sunxi_dmabuf_release(struct dma_buf *dmabuf)
+{
+	struct drm_gem_object *sunxi_gem_obj = dmabuf->priv;
+
+	DRM_DEBUG_PRIME("[%d]\n", __LINE__);
+	sunxi_gem_obj->export_dma_buf = NULL;
+	/* inc in drm_gem_prime_handle_to_fd */
+	drm_gem_object_unreference_unlocked(sunxi_gem_obj);
+}
+
+static void *sunxi_gem_dmabuf_kmap_atomic(struct dma_buf *dma_buf,
+						unsigned long page_num)
+{
+	/* TODO */
+
+	return NULL;
+}
+
+static void sunxi_gem_dmabuf_kunmap_atomic(struct dma_buf *dma_buf,
+						unsigned long page_num,
+						void *addr)
+{
+	/* TODO */
+}
+
+static void *sunxi_gem_dmabuf_kmap(struct dma_buf *dma_buf,
+					unsigned long page_num)
+{
+	/* TODO */
+
+	return NULL;
+}
+
+static void sunxi_gem_dmabuf_kunmap(struct dma_buf *dma_buf,
+					unsigned long page_num, void *addr)
+{
+	/* TODO */
+}
+
+static int sunxi_gem_dmabuf_mmap(struct dma_buf *dma_buf,
+	struct vm_area_struct *vma)
+{
+	struct drm_gem_object *obj;
+	struct sunxi_drm_gem_buf *sunxi_buf;
+	struct sg_table *table;
+	unsigned long addr = vma->vm_start;
+	unsigned long offset = vma->vm_pgoff * PAGE_SIZE;
+	struct scatterlist *sg;
+	int i, ret;
+	unsigned long remainder, len; 
+	struct page *page;
+
+	/* drm don't allow dma_fd to do other but DRM_CLOEXEC,
+	* if you want use dma_fd for the mmap(). modify the  
+	* drm_prime_handle_to_fd_ioctl add O_RDWR.
+	*/
+
+	obj = (struct drm_gem_object *)dma_buf->priv;
+	sunxi_buf = (struct sunxi_drm_gem_buf *)obj->driver_private;
+	table = sunxi_buf->sgt;
+	for_each_sg(table->sgl, sg, table->nents, i) {
+		page = sg_page(sg);
+		remainder = vma->vm_end - addr;
+		len = sg->length;
+
+		if (offset >= sg->length) {
+			offset -= sg->length;
+			continue;
+		} else if (offset) {
+			page += offset / PAGE_SIZE;
+			len = sg->length - offset;
+			offset = 0;
+		}
+		len = min(len, remainder);
+		ret = remap_pfn_range(vma, addr, page_to_pfn(page), len,
+		vma->vm_page_prot);
+		if (ret)
+			return ret;
+		addr += len;
+		if (addr >= vma->vm_end)
+			return 0;
+	}
+	DRM_DEBUG_PRIME("vma_start:%lx  end:%lx offset:%lu size = 0x%lu\n",
+			vma->vm_start, vma->vm_end, vma->vm_pgoff * PAGE_SIZE, sunxi_buf->size);
+
+	return 0;
+}
+
+static struct dma_buf_ops sunxi_gem_dmabuf_ops = {
+	.attach = sunxi_gem_attach_dma_buf,
+	.detach	= sunxi_gem_detach_dma_buf,
+	.map_dma_buf = sunxi_gem_map_dma_buf,
+	.unmap_dma_buf = sunxi_gem_unmap_dma_buf,
+	.kmap = sunxi_gem_dmabuf_kmap,
+	.kmap_atomic = sunxi_gem_dmabuf_kmap_atomic,
+	.kunmap = sunxi_gem_dmabuf_kunmap,
+	.kunmap_atomic = sunxi_gem_dmabuf_kunmap_atomic,
+	.mmap = sunxi_gem_dmabuf_mmap,
+	.release = sunxi_dmabuf_release,
+};
+
+struct dma_buf *sunxi_dmabuf_prime_export(struct drm_device *drm_dev,
+				struct drm_gem_object *obj, int flags)
+{
+	struct sunxi_drm_gem_buf *sunxi_buf =
+		(struct sunxi_drm_gem_buf *)obj->driver_private;
+
+	return dma_buf_export(obj, &sunxi_gem_dmabuf_ops,
+			sunxi_buf->size, flags);
+}
+
+struct drm_gem_object *sunxi_dmabuf_prime_import(struct drm_device *drm_dev,
+				struct dma_buf *dma_buf)
+{
+	struct dma_buf_attachment *attach;
+	struct sg_table *sgt;
+	struct scatterlist *sgl;
+	struct drm_gem_object *sunxi_gem_obj;
+	struct sunxi_drm_gem_buf *buffer;
+	int ret;
+
+	DRM_DEBUG_PRIME("[%d]\n",__LINE__);
+
+	/* is this one of own objects? */
+	if (dma_buf->ops == &sunxi_gem_dmabuf_ops) {
+		sunxi_gem_obj = dma_buf->priv;
+		/* is it from our device? */
+		if (sunxi_gem_obj->dev == drm_dev) {
+			/*
+			* Importing dmabuf exported from out own gem increases
+			* refcount on gem itself instead of f_count of dmabuf.
+			*/
+			drm_gem_object_reference(sunxi_gem_obj);
+			return sunxi_gem_obj;
+		}
+	}
+
+	attach = dma_buf_attach(dma_buf, drm_dev->dev);
+	if (IS_ERR(attach))
+		return ERR_PTR(-EINVAL);
+
+	get_dma_buf(dma_buf);
+
+	sgt = dma_buf_map_attachment(attach, DMA_BIDIRECTIONAL);
+	if (IS_ERR_OR_NULL(sgt)) {
+		ret = PTR_ERR(sgt);
+		goto err_buf_detach;
+	}
+
+	buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
+	if (!buffer) {
+		DRM_ERROR("failed to allocate sunxi_drm_gem_buf.\n");
+		ret = -ENOMEM;
+		goto err_unmap_attach;
+	}
+
+	sunxi_gem_obj = drm_gem_object_alloc(drm_dev, dma_buf->size);
+	if (!sunxi_gem_obj) {
+		ret = -ENOMEM;
+		goto err_free_buffer;
+	}
+
+	sgl = sgt->sgl;
+
+	buffer->size = dma_buf->size;
+	buffer->dma_addr = sg_dma_address(sgl);
+
+	if (sgt->nents == 1) {
+		buffer->flags |= SUNXI_BO_CONTIG;
+	} else {
+		buffer->flags &= ~SUNXI_BO_CONTIG;
+	}
+
+	sunxi_gem_obj->driver_private = (void *)buffer;
+	buffer->sgt = sgt;
+	sunxi_gem_obj->import_attach = attach;
+
+	DRM_DEBUG_PRIME("[%d] dma_addr = 0x%llx, size = 0x%lu\n",
+		__LINE__, buffer->dma_addr, buffer->size);
+
+	return sunxi_gem_obj;
+
+err_free_buffer:
+	kfree(buffer);
+	buffer = NULL;
+err_unmap_attach:
+	dma_buf_unmap_attachment(attach, sgt, DMA_BIDIRECTIONAL);
+err_buf_detach:
+	dma_buf_detach(dma_buf, attach);
+	dma_buf_put(dma_buf);
+
+	return ERR_PTR(ret);
+}
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_dmabuf.h b/drivers/gpu/drm/sunxi/sunxi_drm_dmabuf.h
new file mode 100755
index 0000000..1b9734a
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_dmabuf.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui <cuiyuntao@allwinnter.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+ 
+#ifndef     SUNXI_GEM_DMABUF_H_
+#define     SUNXI_GEM_DMABUF_H_
+#include <linux/dma-buf.h>
+
+struct sunxi_gem_dmabuf_attachment {
+	struct sg_table sgt;
+	enum dma_data_direction dir;
+	bool is_mapped;
+};
+
+struct dma_buf *sunxi_dmabuf_prime_export(struct drm_device *drm_dev,
+			struct drm_gem_object *obj, int flags);
+
+struct drm_gem_object *sunxi_dmabuf_prime_import(struct drm_device *drm_dev,
+	struct dma_buf *dma_buf);
+
+#endif
\ No newline at end of file
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_drv.c b/drivers/gpu/drm/sunxi/sunxi_drm_drv.c
new file mode 100755
index 0000000..e09ffa0
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_drv.c
@@ -0,0 +1,306 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/sunxi_drm.h>
+
+#include "sunxi_drm_drv.h"
+#include "sunxi_drm_core.h"
+#include "sunxi_drm_crtc.h"
+#include "sunxi_drm_encoder.h"
+#include "sunxi_drm_connector.h"
+#include "sunxi_drm_fb.h"
+#include "sunxi_drm_gem.h"
+#include "sunxi_drm_fbdev.h"
+#include "sunxi_drm_dmabuf.h"
+#include "subdev/sunxi_rotate.h"
+
+#define DRIVER_NAME	"sunxi"
+#define DRIVER_DESC	"allwinnertech SoC DRM"
+#define DRIVER_DATE	"20160530"
+#define DRIVER_MAJOR	1
+#define DRIVER_MINOR	0
+
+#define VBLANK_OFF_DELAY	50000
+
+/* platform device pointer for eynos drm device. */
+static struct platform_device *sunxi_drm_pdev;
+
+static int sunxi_drm_load(struct drm_device *dev, unsigned long flags)
+{
+	struct sunxi_drm_private *private;
+	int ret;
+
+	DRM_DEBUG_DRIVER("[%d]\n", __LINE__);
+	DRM_ERROR("[dengbo] debug from here\n");
+
+	private = kzalloc(sizeof(struct sunxi_drm_private), GFP_KERNEL);
+	if (!private) {
+		DRM_ERROR("failed to allocate private\n");
+		return -ENOMEM;
+	}
+
+    printk("[DRM_BUDDY][%s-%d]\n", __func__, __LINE__);
+	dev->dev_private = (void *)private;
+    printk("[DRM_BUDDY][%s-%d]\n", __func__, __LINE__);
+
+	drm_mode_config_init(dev);
+
+    printk("[DRM_BUDDY][%s-%d]\n", __func__, __LINE__);
+	/* init kms poll for handling hpd */
+	drm_kms_helper_poll_init(dev);
+
+    printk("[DRM_BUDDY][%s-%d]\n", __func__, __LINE__);
+	sunxi_drm_mode_config_init(dev);
+
+    printk("[DRM_BUDDY][%s-%d]\n", __func__, __LINE__);
+	if (sunxi_drm_init(dev)) {
+		DRM_ERROR("failed to initialize sunxi drm dev.\n");
+		goto err_init_sunxi;
+	}
+    printk("[DRM_BUDDY][%s-%d]\n", __func__, __LINE__);
+	ret = drm_vblank_init(dev, dev->mode_config.num_crtc);
+    printk("[DRM_BUDDY][%s-%d]\n", __func__, __LINE__);
+	if (ret) {
+		DRM_ERROR("failed to init vblank.\n");   
+		goto err_init_sunxi;
+	}
+    printk("[DRM_BUDDY][%s-%d]\n", __func__, __LINE__);
+	/*
+	* create and configure fb helper and also sunxi specific
+	* fbdev object.
+	*/
+	ret = sunxi_drm_fbdev_creat(dev);
+    printk("[DRM_BUDDY][%s-%d]\n", __func__, __LINE__);
+	if (ret) {
+		DRM_ERROR("failed to initialize drm fbdev\n");
+		goto err_vblank;
+	}
+    printk("[DRM_BUDDY][%s-%d]\n", __func__, __LINE__);
+
+	drm_vblank_offdelay = VBLANK_OFF_DELAY;
+
+    printk("[DRM_BUDDY][%s-%d]\n", __func__, __LINE__);
+	return 0;
+
+err_vblank:
+    printk("[DRM_BUDDY][%s-%d]\n", __func__, __LINE__);
+	drm_vblank_cleanup(dev);
+err_init_sunxi:
+    printk("[DRM_BUDDY][%s-%d]\n", __func__, __LINE__);
+	sunxi_drm_destroy(dev);
+    printk("[DRM_BUDDY][%s-%d]\n", __func__, __LINE__);
+	kfree(private);
+
+    printk("[DRM_BUDDY][%s-%d]\n", __func__, __LINE__);
+	return ret;
+}
+
+static int sunxi_drm_unload(struct drm_device *dev)
+{
+	struct sunxi_drm_private *private;
+
+	DRM_DEBUG_DRIVER("[%d]\n", __LINE__);
+	private = (struct sunxi_drm_private *)dev->dev_private;
+	sunxi_drm_fbdev_destroy(dev);
+	drm_vblank_cleanup(dev);
+	drm_kms_helper_poll_fini(dev);
+	drm_mode_config_cleanup(dev);
+
+	sunxi_drm_rotate_destroy(private->rotate_private);
+	kfree(dev->dev_private);
+
+	dev->dev_private = NULL;
+
+	return 0;
+}
+
+static int sunxi_drm_open(struct drm_device *dev, struct drm_file *file)
+{
+
+	DRM_DEBUG_DRIVER("[%d]\n", __LINE__);
+	return 0; 
+}
+
+static void sunxi_drm_preclose(struct drm_device *dev,
+				struct drm_file *file)
+{
+	struct drm_pending_vblank_event *e, *t;
+	unsigned long flags;
+	struct drm_crtc *crtc;
+	struct sunxi_drm_crtc *sunxi_crtc;
+
+	DRM_DEBUG_DRIVER("[%d]\n", __LINE__);
+
+	spin_lock_irqsave(&dev->event_lock, flags);
+
+	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+		sunxi_crtc = to_sunxi_crtc(crtc);	
+		list_for_each_entry_safe(e, t, &sunxi_crtc->pageflip_event_list,
+			base.link) {
+			if (e->base.file_priv == file) {
+				list_del(&e->base.link);
+				e->base.destroy(&e->base);
+			}
+		}
+	}
+	spin_unlock_irqrestore(&dev->event_lock, flags);
+
+}
+
+static void sunxi_drm_postclose(struct drm_device *dev, struct drm_file *file)
+{
+	DRM_DEBUG_DRIVER("[%d]\n", __LINE__);
+
+	if (!file->driver_priv)
+		return;
+
+	kfree(file->driver_priv);
+	file->driver_priv = NULL;
+}
+
+static void sunxi_drm_lastclose(struct drm_device *dev)
+{
+	DRM_DEBUG_DRIVER("[%d]\n", __LINE__);
+
+	sunxi_drm_fbdev_restore_mode(dev);
+}
+
+static const struct vm_operations_struct sunxi_drm_gem_vm_ops = {
+	.fault = sunxi_drm_gem_fault,
+	.open = drm_gem_vm_open,
+	.close = drm_gem_vm_close,
+};
+
+static struct drm_ioctl_desc sunxi_ioctls[] = {
+	DRM_IOCTL_DEF_DRV(SUNXI_FLIP_SYNC, sunxi_drm_flip_ioctl,
+		DRM_UNLOCKED | DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(SUNXI_ROTATE, sunxi_drm_rotate_ioctl,
+		DRM_UNLOCKED | DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(SUNXI_SYNC_GEM, sunxi_drm_gem_sync_ioctl,
+		DRM_UNLOCKED | DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(SUNXI_INFO_FB_PLANE, sunxi_drm_info_fb_ioctl,
+		DRM_UNLOCKED | DRM_AUTH),
+};
+
+static const struct file_operations sunxi_drm_driver_fops = {
+	.owner = THIS_MODULE,
+	.open = drm_open,
+	.mmap = sunxi_drm_gem_mmap,
+	.poll = drm_poll,
+	.read = drm_read,
+	.unlocked_ioctl	= drm_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = drm_compat_ioctl,
+#endif
+	.release = drm_release,
+};
+
+static struct drm_driver sunxi_drm_driver = {
+	.driver_features = DRIVER_HAVE_IRQ | DRIVER_MODESET |
+				DRIVER_GEM | DRIVER_PRIME,
+	.load = sunxi_drm_load,
+	.unload = sunxi_drm_unload,
+	.open = sunxi_drm_open,
+	.preclose = sunxi_drm_preclose,
+	.lastclose = sunxi_drm_lastclose,
+	.postclose = sunxi_drm_postclose,
+	.get_vblank_counter	= drm_vblank_count,
+	.enable_vblank = sunxi_drm_enable_vblank,
+	.disable_vblank = sunxi_drm_disable_vblank,
+	.gem_init_object = sunxi_drm_gem_init_object,
+	.gem_free_object = sunxi_drm_gem_free_object,
+	.gem_vm_ops = &sunxi_drm_gem_vm_ops,
+	.dumb_create = sunxi_drm_gem_dumb_create,
+	.dumb_map_offset = sunxi_drm_gem_dumb_map_offset,
+	.dumb_destroy = sunxi_drm_gem_dumb_destroy,
+	.prime_handle_to_fd	= drm_gem_prime_handle_to_fd,
+	.prime_fd_to_handle	= drm_gem_prime_fd_to_handle,
+	.gem_prime_export = sunxi_dmabuf_prime_export,
+	.gem_prime_import = sunxi_dmabuf_prime_import,
+	.ioctls = sunxi_ioctls,
+	.fops = &sunxi_drm_driver_fops,
+	.name = DRIVER_NAME,
+	.desc = DRIVER_DESC,
+	.date = DRIVER_DATE,
+	.major = DRIVER_MAJOR,
+	.minor = DRIVER_MINOR,
+};
+
+static int sunxi_drm_platform_probe(struct platform_device *pdev)
+{
+	DRM_DEBUG_DRIVER("[%d]\n", __LINE__);
+
+	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(64);
+	sunxi_drm_driver.num_ioctls = DRM_ARRAY_SIZE(sunxi_ioctls);
+
+	return drm_platform_init(&sunxi_drm_driver, pdev);
+}
+
+static int sunxi_drm_platform_remove(struct platform_device *pdev)
+{
+	DRM_DEBUG_DRIVER("[%d]\n", __LINE__);
+
+	drm_platform_exit(&sunxi_drm_driver, pdev);
+
+	return 0;
+}
+
+static struct platform_driver sunxi_drm_platform_driver = {
+	.probe = sunxi_drm_platform_probe,
+	.remove = sunxi_drm_platform_remove,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "sunxi-drm",
+	},
+};
+
+static int __init sunxi_drm_dev_init(void)
+{
+	int ret;
+
+	DRM_DEBUG_DRIVER("[%d]\n", __LINE__);
+
+	ret = platform_driver_register(&sunxi_drm_platform_driver);
+	if (ret < 0)
+		goto out_0;
+
+	sunxi_drm_pdev = platform_device_register_simple("sunxi-drm", -1,
+			NULL, 0);
+	if (IS_ERR(sunxi_drm_pdev)) {
+		ret = PTR_ERR(sunxi_drm_pdev);
+		goto out;
+	}
+
+	return 0;
+
+out:
+	platform_driver_unregister(&sunxi_drm_platform_driver);
+out_0:
+	return ret;
+}
+
+static void __exit sunxi_drm_dev_exit(void)
+{
+	DRM_DEBUG_DRIVER("[%d]\n", __LINE__);
+
+	platform_device_unregister(sunxi_drm_pdev);
+
+	platform_driver_unregister(&sunxi_drm_platform_driver);
+}
+
+module_init(sunxi_drm_dev_init);
+module_exit(sunxi_drm_dev_exit);
+
+MODULE_AUTHOR("Jet Cui");
+MODULE_DESCRIPTION("Allwinnertech SoC DRM Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_drv.h b/drivers/gpu/drm/sunxi/sunxi_drm_drv.h
new file mode 100755
index 0000000..9b95685
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_drv.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#ifndef _SUNXI_DRM_DRV_H_
+#define _SUNXI_DRM_DRV_H_
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_fb_helper.h>
+
+struct sunxi_drm_private {
+	struct drm_fb_helper *fb_helper;
+	struct drm_property *crtc_mode_property;
+	struct sunxi_rotate_private *rotate_private;
+};
+
+#endif
+
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_encoder.c b/drivers/gpu/drm/sunxi/sunxi_drm_encoder.c
new file mode 100755
index 0000000..de1ac33
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_encoder.c
@@ -0,0 +1,722 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui <cuiyuntao@allwinnter.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
+
+#include "sunxi_drm_crtc.h"
+#include "sunxi_drm_encoder.h"
+#include "sunxi_drm_connector.h"
+#include "sunxi_drm_core.h"
+#include "subdev/sunxi_lcd.h"
+#include "subdev/sunxi_hdmi.h"
+#include "subdev/sunxi_common.h"
+#include "drm_de/drm_al.h"
+
+bool sunxi_tcon_common_query_irq(void *irq_data, int need_irq);
+
+struct sunxi_drm_encoder *
+    get_sunxi_enc(struct drm_device *dev, unsigned int nr)
+{
+	struct drm_encoder *enc = NULL;
+
+	list_for_each_entry(enc, &dev->mode_config.encoder_list, head) {
+		if (to_sunxi_encoder(enc)->enc_id == nr) {
+			return to_sunxi_encoder(enc);
+		}
+	}
+
+	return NULL;
+}
+
+struct drm_connector *sunxi_get_conct(struct drm_encoder *encoder)
+{
+	struct drm_connector *conct;
+
+	list_for_each_entry(conct, &encoder->dev->mode_config.connector_list, head) {
+		if (conct->encoder == encoder) {
+			return conct;
+		}
+	}
+
+	return NULL;
+}
+
+static void sunxi_drm_encoder_reset(struct drm_encoder *encoder)
+{
+	struct sunxi_drm_encoder *sunxi_enc = to_sunxi_encoder(encoder);
+	struct sunxi_hardware_res *hw_res;
+	hw_res = sunxi_enc->hw_res;
+
+	if(hw_res->ops && hw_res->ops->reset)
+		hw_res->ops->reset(encoder);
+}
+
+void sunxi_drm_encoder_enable(struct drm_encoder *encoder)
+{
+	struct sunxi_drm_encoder *sunxi_enc = to_sunxi_encoder(encoder);
+	struct sunxi_hardware_res *hw_res;
+	hw_res = sunxi_enc->hw_res;
+
+	if(hw_res && hw_res->ops &&
+		hw_res->ops->enable && !hw_res->en_ctl_by) {
+		hw_res->ops->enable(encoder);
+	}
+}
+
+/* disable encoder when not in use - more explicit than dpms off */
+void sunxi_drm_encoder_disable(struct drm_encoder *encoder)
+{
+	struct sunxi_drm_encoder *sunxi_enc = to_sunxi_encoder(encoder);
+	struct sunxi_hardware_res *hw_res;
+	bool inused = drm_helper_encoder_in_use(encoder);
+	hw_res = sunxi_enc->hw_res;
+
+	if (hw_res && hw_res->ops &&
+		hw_res->ops->disable && (!hw_res->en_ctl_by||!inused)) {
+		hw_res->ops->disable(encoder);
+	}
+}
+
+static void sunxi_drm_encoder_dpms(struct drm_encoder *encoder, int mode)
+{
+	struct sunxi_drm_encoder *sunxi_enc = to_sunxi_encoder(encoder);
+	struct sunxi_hardware_res *hw_res = sunxi_enc->hw_res;
+
+	/* on :clk, irq, output ok
+	* standby suspend: disable irq
+	* off: disable irq,
+	* if on we must display the content when off
+	*/
+
+	bool inused = drm_helper_encoder_in_use(encoder);
+	switch (mode) {
+	case  DRM_MODE_DPMS_ON:
+		if(inused) {
+			sunxi_drm_encoder_enable(encoder);
+		}
+		break;
+	case DRM_MODE_DPMS_OFF:
+		sunxi_drm_encoder_disable(encoder);
+		break;
+	case DRM_MODE_DPMS_STANDBY:
+	case DRM_MODE_DPMS_SUSPEND:
+		sunxi_irq_disable(hw_res);
+		break;
+	default:
+		return;
+	}
+	sunxi_enc->dpms = mode;
+}
+
+static bool sunxi_drm_encoder_mode_fixup(struct drm_encoder *encoder,
+		   const struct drm_display_mode *mode,
+		   struct drm_display_mode *adjusted_mode)
+{
+	return true;
+}
+
+static void sunxi_drm_encoder_prepare(struct drm_encoder *encoder)
+{
+	/*set the clock and crtc global_cfg*/
+	struct sunxi_drm_encoder *sunxi_enc = to_sunxi_encoder(encoder);
+
+	sunxi_drm_encoder_disable(encoder);
+	sunxi_drm_encoder_reset(encoder);
+
+	sunxi_set_global_cfg(encoder->crtc, MANAGER_TCON_DIRTY, &sunxi_enc->enc_id);
+}
+
+static void sunxi_drm_encoder_commit(struct drm_encoder *encoder)
+{
+	sunxi_drm_encoder_enable(encoder);
+	return ;
+}
+
+static inline void sunxi_drm_encoder_set_timming(struct drm_encoder *encoder,
+            struct drm_display_mode *mode)
+{
+	struct sunxi_drm_encoder *sunxi_enc = to_sunxi_encoder(encoder);
+	struct sunxi_hardware_res *hw_res = sunxi_enc->hw_res;
+
+	if (hw_res && hw_res->ops && hw_res->ops->set_timming)
+		hw_res->ops->set_timming(encoder, mode);
+}
+
+static void sunxi_drm_encoder_mode_set(struct drm_encoder *encoder,
+		struct drm_display_mode *mode,
+		struct drm_display_mode *adjusted_mode)
+{
+	/*set the hardware Tcon or to mem cache of the register*/
+	sunxi_drm_encoder_set_timming(encoder, mode);
+}
+
+static struct drm_encoder_helper_funcs sunxi_encoder_helper_funcs = {
+	.dpms = sunxi_drm_encoder_dpms,
+	.mode_fixup = sunxi_drm_encoder_mode_fixup,
+	.mode_set = sunxi_drm_encoder_mode_set,
+	.prepare = sunxi_drm_encoder_prepare,
+	.commit = sunxi_drm_encoder_commit,
+	.disable = sunxi_drm_encoder_disable,
+};
+
+int sunxi_encoder_updata_delayed(struct drm_encoder *encoder)
+{
+	struct sunxi_drm_encoder *sunxi_enc = to_sunxi_encoder(encoder);
+	struct sunxi_hardware_res *hw_res = sunxi_enc->hw_res;
+
+	return hw_res->ops->user_def(encoder);
+}
+
+irqreturn_t sunxi_encoder_vsync_handle(int irq, void *data)
+{
+	struct drm_connector *conct;
+	struct drm_encoder *encoder = (struct drm_encoder *)data;
+	struct sunxi_drm_connector *sunxi_con;
+	struct sunxi_drm_crtc *sunxi_crtc;
+	struct sunxi_drm_encoder *sunxi_encoder =
+		to_sunxi_encoder(encoder);
+	if (!drm_helper_encoder_in_use(data)) {
+		/* avoid disable the irq with the user thread, return */
+		return IRQ_HANDLED;
+	}
+
+	if (!sunxi_irq_query(sunxi_encoder->hw_res, encoder, QUERY_VSYNC_IRQ))
+		return IRQ_HANDLED;
+
+	list_for_each_entry(conct,
+		&encoder->dev->mode_config.connector_list, head) {
+		if (conct->encoder == encoder) {
+			sunxi_con = to_sunxi_connector(conct);
+		if(sunxi_con->hw_res != NULL &&
+			sunxi_con->hw_res->ops != NULL &&
+			sunxi_con->hw_res->ops->vsync_proc != NULL) {
+
+			sunxi_con->hw_res->ops->vsync_proc(sunxi_con);
+			}
+		}
+	}
+
+	sunxi_crtc = to_sunxi_crtc(encoder->crtc);
+	if(sunxi_crtc != NULL &&
+		sunxi_crtc->hw_res != NULL &&
+		sunxi_crtc->hw_res->ops != NULL &&
+		sunxi_crtc->hw_res->ops->vsync_proc != NULL) {
+
+		sunxi_crtc->hw_res->ops->vsync_proc(sunxi_crtc);
+	}
+
+	if(sunxi_encoder != NULL &&
+		sunxi_encoder->hw_res != NULL &&
+		sunxi_encoder->hw_res->ops != NULL &&
+		sunxi_encoder->hw_res->ops->vsync_proc != NULL) {
+
+		sunxi_encoder->hw_res->ops->vsync_proc(sunxi_encoder);
+	}
+	return IRQ_HANDLED;
+}
+
+static void sunxi_drm_encoder_destroy(struct drm_encoder *encoder)
+{
+	struct sunxi_drm_encoder *sunxi_encoder =
+		to_sunxi_encoder(encoder);
+	struct sunxi_hardware_res *hw_res;
+
+	hw_res = sunxi_encoder->hw_res;
+	drm_encoder_cleanup(encoder);
+	sunxi_hwres_destroy(hw_res);
+	kfree(sunxi_encoder);
+}
+
+static struct drm_encoder_funcs sunxi_encoder_funcs = {
+	.reset = sunxi_drm_encoder_reset,
+	.destroy = sunxi_drm_encoder_destroy,
+};
+
+bool sunxi_tcon_common_reset(void *data)
+{
+	struct sunxi_drm_encoder *sunxi_encoder =
+		to_sunxi_encoder(data);
+	struct sunxi_hardware_res *hw_res;
+
+	hw_res = sunxi_encoder->hw_res;
+
+	sunxi_clk_set(hw_res);
+	sunxi_clk_enable(hw_res);
+	tcon_init(sunxi_encoder->enc_id);
+	sunxi_irq_request(hw_res);
+
+	return true;
+}
+
+bool sunxi_tcon_common_init(void *data)
+{
+	struct sunxi_drm_encoder *sunxi_encoder =
+		to_sunxi_encoder(data);
+	struct sunxi_hardware_res *hw_res;
+	hw_res = sunxi_encoder->hw_res;
+
+	if (hw_res->clk)
+		hw_res->parent_clk = clk_get_parent(hw_res->clk);
+
+	return true;
+}
+
+bool sunxi_tcon_hdmi_init(void *data)
+{
+	struct sunxi_drm_encoder *sunxi_encoder =
+		to_sunxi_encoder(data);
+	struct sunxi_hardware_res *hw_res;
+	hw_res = sunxi_encoder->hw_res;
+
+	return true;
+}
+
+bool sunxi_tcon_common_enable(void *data)
+{
+	struct sunxi_drm_encoder *sunxi_encoder =
+		to_sunxi_encoder(data);
+	struct sunxi_hardware_res *hw_res;
+
+	hw_res = sunxi_encoder->hw_res;
+	sunxi_clk_enable(hw_res);
+	DRM_DEBUG_KMS("[%d]\n", __LINE__);
+
+	return true;
+}
+
+bool sunxi_tcon_common_disable(void *data)
+{
+	struct sunxi_drm_encoder *sunxi_encoder =
+		to_sunxi_encoder(data);
+	struct sunxi_hardware_res *hw_res;
+	hw_res = sunxi_encoder->hw_res;
+
+	if (sunxi_encoder->enc_id == 1)
+		tcon1_close(1);
+	if (sunxi_encoder->enc_id == 0)
+		tcon0_close(0);
+
+	sunxi_irq_free(hw_res);
+	sunxi_clk_disable(hw_res);
+
+	return true;
+}
+
+int sunxi_tcon_common_set_timing(void *data, struct drm_display_mode *mode)
+{
+	return 0;
+}
+
+int sunxi_tcon_common_check_line(void *data)
+{
+	struct sunxi_drm_encoder *sunxi_enc = to_sunxi_encoder(data);
+	int cur_line = 0, start_delay = 0;
+
+	cur_line = tcon_get_cur_line(sunxi_enc->enc_id, sunxi_enc->part_id);
+	start_delay = tcon_get_start_delay(sunxi_enc->enc_id, sunxi_enc->part_id);
+
+	return start_delay - cur_line - ENCODER_UPDATA_DELAYED;
+}
+
+#ifdef SUPPORT_DSI
+bool sunxi_tcon_dsi_enable(void *data)
+{
+	struct sunxi_drm_encoder *sunxi_encoder =
+			to_sunxi_encoder(data);
+	struct sunxi_hardware_res *hw_res;
+	struct sunxi_lcd_private *lcd_private;
+
+	hw_res = sunxi_encoder->hw_res;
+	lcd_private = (struct sunxi_lcd_private *)hw_res->private;
+
+	tcon0_open(sunxi_encoder->enc_id, lcd_private->panel);
+	dsi_open(sunxi_encoder->enc_id, lcd_private->panel);
+
+	DRM_DEBUG_KMS("[%d]\n",__LINE__);
+
+	return true;
+}
+
+bool sunxi_tcon_dsi_disable(void *data)
+{
+	struct sunxi_drm_encoder *sunxi_encoder =
+		to_sunxi_encoder(data);
+	struct sunxi_hardware_res *hw_res;
+	hw_res = sunxi_encoder->hw_res;
+
+	dsi_close(sunxi_encoder->enc_id);
+	tcon0_close(sunxi_encoder->enc_id);
+	tcon_exit(sunxi_encoder->enc_id);
+
+	sunxi_irq_free(hw_res);
+	sunxi_clk_disable(hw_res);
+
+	return true;
+}
+
+int sunxi_tcon_dsi_set_timing(void *data, struct drm_display_mode *mode)
+{
+	struct sunxi_drm_encoder *sunxi_encoder =
+	to_sunxi_encoder(data);
+	struct sunxi_hardware_res *hw_res;
+	struct sunxi_lcd_private *lcd_private;
+
+	hw_res = sunxi_encoder->hw_res;
+	lcd_private = (struct sunxi_lcd_private *)hw_res->private;
+
+	tcon0_set_dclk_div(sunxi_encoder->enc_id, lcd_private->clk_info->tcon_div);
+	tcon0_cfg(sunxi_encoder->enc_id, lcd_private->panel);
+	tcon0_cfg_ext(sunxi_encoder->enc_id, lcd_private->extend_panel);
+	return 0;
+}
+
+int sunxi_tcon_dsi_check_line(void *data)
+{
+	struct sunxi_drm_encoder *sunxi_enc = to_sunxi_encoder(data);
+	int cur_line = 0, start_delay = 0;
+
+	cur_line = dsi_get_cur_line(sunxi_enc->enc_id);
+	start_delay = dsi_get_start_delay(sunxi_enc->enc_id);
+
+	return start_delay - cur_line - ENCODER_UPDATA_DELAYED;
+}
+#endif
+
+bool sunxi_tcon_lvds_enable(void *data)
+{
+	struct sunxi_drm_encoder *sunxi_encoder =
+		to_sunxi_encoder(data);
+	struct sunxi_hardware_res *hw_res;
+	struct sunxi_lcd_private *lcd_private;
+
+	hw_res = sunxi_encoder->hw_res;
+	lcd_private = (struct sunxi_lcd_private *)hw_res->private;
+
+	tcon0_open(sunxi_encoder->enc_id, lcd_private->panel);
+	lvds_open(sunxi_encoder->enc_id, lcd_private->panel);
+
+	DRM_DEBUG_KMS("[%d]\n",__LINE__);
+
+	return true;
+}
+
+bool sunxi_tcon_lvds_disable(void *data)
+{
+	struct sunxi_drm_encoder *sunxi_encoder =
+		to_sunxi_encoder(data);
+	struct sunxi_hardware_res *hw_res;
+	hw_res = sunxi_encoder->hw_res;
+
+	lvds_close(sunxi_encoder->enc_id);
+	tcon0_close(sunxi_encoder->enc_id);
+	tcon_exit(sunxi_encoder->enc_id);
+
+	sunxi_irq_free(hw_res);
+	sunxi_clk_disable(hw_res);
+
+    	return true;
+}
+
+int sunxi_tcon_lvds_set_timing(void *data, struct drm_display_mode *mode)
+{
+	struct sunxi_drm_encoder *sunxi_encoder =
+	to_sunxi_encoder(data);
+	struct sunxi_drm_crtc *sunxi_crtc;
+	struct sunxi_hardware_res *hw_res;
+	struct sunxi_lcd_private *lcd_private;
+	int crtc_id = 0;
+	sunxi_crtc = to_sunxi_crtc(sunxi_encoder->drm_encoder.crtc);
+	crtc_id = sunxi_crtc ? sunxi_crtc->crtc_id : 0;
+
+	DRM_DEBUG_KMS("[%d] encoder_id:%d\n",__LINE__, sunxi_encoder->enc_id);
+
+	hw_res = sunxi_encoder->hw_res;
+	lcd_private = (struct sunxi_lcd_private *)hw_res->private;
+
+	tcon0_set_dclk_div(sunxi_encoder->enc_id, lcd_private->clk_info->tcon_div);
+	tcon0_cfg(sunxi_encoder->enc_id, lcd_private->panel);
+	tcon0_cfg_ext(sunxi_encoder->enc_id, lcd_private->extend_panel);
+	tcon0_src_select(sunxi_encoder->enc_id, LCD_SRC_DE, crtc_id);
+
+	    return 0;
+}
+
+bool sunxi_tcon_hdmi_reset(void *data)
+{
+	struct sunxi_drm_encoder *sunxi_encoder =
+		to_sunxi_encoder(data);
+	struct sunxi_hardware_res *hw_res;
+	hw_res = sunxi_encoder->hw_res;
+	sunxi_irq_request(hw_res);
+	return true;
+}
+
+bool sunxi_tcon_hdmi_enable(void *data)
+{
+	struct sunxi_drm_encoder *sunxi_encoder =
+		to_sunxi_encoder(data);
+	tcon1_open(sunxi_encoder->enc_id);
+	return true;
+}
+
+bool sunxi_tcon_hdmi_disable(void *data)
+{
+	struct sunxi_drm_encoder *sunxi_encoder =
+			to_sunxi_encoder(data);
+	struct sunxi_hardware_res *hw_res;
+
+	hw_res = sunxi_encoder->hw_res;
+
+	tcon1_close(sunxi_encoder->enc_id);
+	tcon_exit(sunxi_encoder->enc_id);
+	tcon1_hdmi_clk_enable(sunxi_encoder->enc_id, 0);
+
+	sunxi_irq_free(hw_res);
+	sunxi_clk_disable(hw_res);
+
+	return true;
+}
+
+int sunxi_tcon_hdmi_set_timing(void *data, struct drm_display_mode *mode)
+{
+	struct sunxi_drm_encoder *sunxi_encoder =
+	to_sunxi_encoder(data);
+	struct sunxi_drm_crtc *sunxi_crtc;
+	struct sunxi_hardware_res *hw_res;
+	struct sunxi_hdmi_private *hdmi_private;
+	struct disp_video_timings *hdmi_timing;
+	int crtc_id = 0;
+	sunxi_crtc = to_sunxi_crtc(sunxi_encoder->drm_encoder.crtc);
+	crtc_id = sunxi_crtc ? sunxi_crtc->crtc_id : 0;
+	hw_res = sunxi_encoder->hw_res;
+	hdmi_private = (struct sunxi_hdmi_private *)hw_res->private;
+	hdmi_timing = hdmi_private->timing;
+	if (MODE_OK != sunxi_hdmi_mode_timmings(hdmi_timing, mode)) {
+		DRM_ERROR("failed to change mode to hdmi timming.\n");
+		return -EINVAL;
+	}
+
+	DRM_INFO("[%d] encoder_id: %d vic:%d\n",__LINE__,
+		sunxi_encoder->enc_id, hdmi_timing->vic);
+
+	hw_res->clk_rate = hdmi_timing->pixel_clk * (hdmi_timing->pixel_repeat + 1);
+	sunxi_clk_set(hw_res);
+	sunxi_clk_enable(hw_res);
+	tcon1_hdmi_clk_enable(sunxi_encoder->enc_id,1);//need check Jet Cui
+	tcon_init(sunxi_encoder->enc_id);
+
+	sunxi_set_global_cfg(sunxi_encoder->drm_encoder.crtc,
+			MANAGER_COLOR_SPACE_DIRTY, &hdmi_private->video_para.is_yuv);
+
+	tcon1_set_timming(sunxi_encoder->enc_id, hdmi_timing);
+	tcon1_hdmi_color_remap(sunxi_encoder->enc_id, hdmi_private->video_para.is_yuv);
+	tcon1_src_select(sunxi_encoder->enc_id, LCD_SRC_DE, crtc_id);
+
+	return 0;
+}
+
+bool sunxi_tcon_updata_reg(void *data)
+{
+	return true;
+}
+
+void sunxi_tcon_vsync_proc(void *data)
+{
+	/* */
+	return;
+}
+
+#ifdef SUPPORT_DSI
+struct sunxi_hardware_ops tcon_dsi_ops = {
+	.init = sunxi_tcon_common_init,
+	.reset = sunxi_tcon_common_reset,
+	.enable = sunxi_tcon_dsi_enable,
+	.disable = sunxi_tcon_dsi_disable,
+	.updata_reg = sunxi_tcon_updata_reg,
+	.vsync_proc = sunxi_tcon_vsync_proc,
+	.irq_query = sunxi_tcon_common_query_irq,
+	.vsync_delayed_do = NULL,
+	.set_timming = sunxi_tcon_dsi_set_timing,
+	.user_def = sunxi_tcon_dsi_check_line,
+};
+#endif
+
+struct sunxi_hardware_ops tcon_lvds_ops = {
+	.init = sunxi_tcon_common_init,
+	.reset = sunxi_tcon_common_reset,
+	.enable = sunxi_tcon_lvds_enable,
+	.disable = sunxi_tcon_lvds_disable,
+	.updata_reg = sunxi_tcon_updata_reg,
+	.vsync_proc = sunxi_tcon_vsync_proc,
+	.irq_query = sunxi_tcon_common_query_irq,
+	.vsync_delayed_do = NULL,
+	.set_timming = sunxi_tcon_lvds_set_timing,
+	.user_def = sunxi_tcon_common_check_line,
+};
+
+struct sunxi_hardware_ops tcon_hdmi_ops = {
+	.init = sunxi_tcon_hdmi_init,
+	.reset = sunxi_tcon_hdmi_reset,
+	.enable = sunxi_tcon_hdmi_enable,
+	.disable = sunxi_tcon_hdmi_disable,
+	.updata_reg = sunxi_tcon_updata_reg,
+	.vsync_proc = sunxi_tcon_vsync_proc,
+	.irq_query = sunxi_tcon_common_query_irq,
+	.vsync_delayed_do = NULL,
+	.set_timming = sunxi_tcon_hdmi_set_timing,
+	.user_def = sunxi_tcon_common_check_line,
+};
+
+struct sunxi_hardware_ops tcon_tv_ops = {
+	.init = sunxi_tcon_common_init,
+	.reset = sunxi_tcon_common_reset,
+	.enable = sunxi_tcon_common_enable,
+	.disable = sunxi_tcon_common_disable,
+	.updata_reg = sunxi_tcon_updata_reg,
+	.vsync_proc = sunxi_tcon_vsync_proc,
+	.irq_query = sunxi_tcon_common_query_irq,
+	.vsync_delayed_do = NULL,
+	.set_timming = sunxi_tcon_common_set_timing,
+	.user_def = sunxi_tcon_common_check_line,
+};
+
+bool sunxi_tcon_common_query_irq(void *irq_data, int need_irq)
+{
+	struct sunxi_drm_encoder *sunxi_encoder =
+		to_sunxi_encoder(irq_data);
+#ifdef CONFIG_ARCH_SUN8IW11
+	enum __lcd_irq_id_t id;
+#endif
+#ifdef CONFIG_ARCH_SUN50IW1P1
+	__lcd_irq_id_t id;
+#endif
+#ifdef CONFIG_ARCH_SUN50IW2P1
+	enum __lcd_irq_id_t id;
+#endif
+
+	if (QUERY_VSYNC_IRQ == need_irq) {
+		if (sunxi_encoder->part_id == 1) {
+			id = LCD_IRQ_TCON1_VBLK;
+		}else{
+			id = LCD_IRQ_TCON0_VBLK;
+		}
+	}else {
+		return false;
+	}
+
+	if(tcon_irq_query(sunxi_encoder->enc_id, id))
+		return true;
+	return false;
+}
+
+int sunxi_drm_encoder_create(struct drm_device *dev, unsigned int possible_crtcs,
+				int fix_crtc, int id, struct sunxi_hardware_res *hw_res)
+{
+	struct sunxi_drm_encoder *sunxi_enc;
+	struct drm_encoder *encoder = NULL;
+	struct sunxi_drm_crtc *sunxi_crtc = NULL;
+	DRM_DEBUG_KMS("[%d]\n",__LINE__);
+
+	if (!hw_res) {
+		DRM_ERROR("failed to allocate encoder\n");
+		return -EINVAL;
+	}
+
+	sunxi_enc = kzalloc(sizeof(*sunxi_enc), GFP_KERNEL);
+	if (!sunxi_enc) {
+		DRM_ERROR("failed to allocate encoder\n");
+		return -EINVAL;
+	}
+
+	sunxi_enc->enc_id = id;
+	sunxi_enc->hw_res = hw_res;
+	if (hw_res != NULL) {
+		hw_res->irq_arg = (void *)sunxi_enc;
+		hw_res->irq_handle = sunxi_encoder_vsync_handle;
+	}
+
+	encoder = &sunxi_enc->drm_encoder;
+	encoder->possible_crtcs = possible_crtcs;
+	drm_encoder_init(dev, encoder, &sunxi_encoder_funcs,
+			DRM_MODE_ENCODER_TMDS);
+
+	drm_encoder_helper_add(encoder, &sunxi_encoder_helper_funcs);
+	if (fix_crtc != -1)
+		sunxi_crtc = get_sunxi_crt(dev, fix_crtc);
+	encoder->crtc = &sunxi_crtc->drm_crtc;
+	DRM_DEBUG_KMS("[%d] encoder_id:%d(%d) possible_crtcs:0x%x\n", __LINE__,
+	    sunxi_enc->enc_id, encoder->base.id, possible_crtcs);
+
+	return 0;
+}
+
+int sunxi_encoder_assign_ops(struct drm_device *dev, int nr,
+    enum encoder_ops_type type, void *private)
+{
+	struct sunxi_drm_encoder *sunxi_encoder;
+	struct sunxi_hardware_res *hw_res;
+	struct sunxi_lcd_private *lcd_p;
+
+	sunxi_encoder = get_sunxi_enc(dev, nr);
+	if (!sunxi_encoder)
+	return -EINVAL;
+
+	sunxi_encoder->hw_res->private = private;
+	hw_res = sunxi_encoder->hw_res;
+	switch(type) {
+#ifdef SUPPORT_DSI
+	case ENCODER_OPS_DSI:
+		lcd_p = (struct sunxi_lcd_private *)private;
+		hw_res->ops = &tcon_dsi_ops;
+		hw_res->clk_rate = lcd_p->panel->lcd_dclk_freq * 1000000
+		* lcd_p->clk_info->dsi_div;
+		hw_res->parent_clk_rate = hw_res->clk_rate * lcd_p->clk_info->lcd_div;
+		hw_res->en_ctl_by = 1;
+		sunxi_encoder->part_id = 0;
+		break;
+#endif
+	case ENCODER_OPS_LVDS:
+		lcd_p = (struct sunxi_lcd_private *)private;
+		hw_res->ops = &tcon_lvds_ops;
+		hw_res->clk_rate = lcd_p->panel->lcd_dclk_freq * 1000000
+		*lcd_p->clk_info->tcon_div;
+		hw_res->parent_clk_rate = hw_res->clk_rate * lcd_p->clk_info->lcd_div;
+		hw_res->en_ctl_by = 1;
+		sunxi_encoder->part_id = 0;
+		break;
+	case ENCODER_OPS_TV:
+		hw_res->ops = &tcon_tv_ops;
+		sunxi_encoder->part_id = 1;
+		break;
+	case ENCODER_OPS_HDMI:
+		hw_res->ops = &tcon_hdmi_ops;
+		sunxi_encoder->part_id = 1;
+		/* we must set the clk when set timing for hdmi */
+		break;
+	default:
+		DRM_ERROR("give us a err ops\n");
+		return -EINVAL;
+	}
+
+	if (hw_res->ops->init) {
+		if (!hw_res->ops->init(sunxi_encoder)) {
+			DRM_ERROR("init encoder err.\n");
+			return -EINVAL;
+		}
+	}
+	/* Currently the tcon just support 1 ops for connector */
+	/* must assign 1 times, avoid mutex with vsync handle. becareful */
+	DRM_INFO("[%d]:type:%d parent_rate:%lu  rate:%lu. encoder[%d][%d][%d] \n",__LINE__, type,
+			hw_res->parent_clk_rate, hw_res->clk_rate, sunxi_encoder->enc_id,sunxi_encoder->part_id,
+			sunxi_encoder->drm_encoder.base.id);
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_encoder.h b/drivers/gpu/drm/sunxi/sunxi_drm_encoder.h
new file mode 100755
index 0000000..2e9b89a
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_encoder.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+/*Encoder --> Tcon*/
+
+#ifndef _SUNXI_DRM_ENCODER_H_
+#define _SUNXI_DRM_ENCODER_H_
+
+#define ENCODER_UPDATA_DELAYED 3
+
+enum encoder_ops_type {
+    ENCODER_OPS_DSI = 0,
+    ENCODER_OPS_LVDS,
+    ENCODER_OPS_TV,
+    ENCODER_OPS_HDMI,
+    ENCODER_OPS_VGA,
+    ENCODER_OPS_NUM,
+
+};
+
+struct sunxi_drm_encoder {
+	struct drm_encoder	drm_encoder;
+	int	enc_id;
+	int 	part_id;
+	int	dpms;
+	struct sunxi_hardware_res *hw_res; 
+};
+
+#define to_sunxi_encoder(x)	(container_of(x, struct sunxi_drm_encoder, drm_encoder))
+
+irqreturn_t sunxi_encoder_vsync_handle(int irq, void *data);
+
+int sunxi_drm_encoder_create(struct drm_device *dev, unsigned int possible_crtcs,
+			int fix_crtc, int id, struct sunxi_hardware_res *hw_res);
+int  sunxi_encoder_updata_delayed(struct drm_encoder *encoder);
+
+void sunxi_drm_encoder_enable(struct drm_encoder *encoder);
+
+void sunxi_drm_encoder_disable(struct drm_encoder *encoder);
+
+struct drm_connector *sunxi_get_conct(struct drm_encoder *encoder);
+
+int sunxi_encoder_assign_ops(struct drm_device *dev, int nr,
+		enum encoder_ops_type type, void *private);
+
+#endif
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_fb.c b/drivers/gpu/drm/sunxi/sunxi_drm_fb.c
new file mode 100755
index 0000000..47f6ce3
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_fb.c
@@ -0,0 +1,223 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#include <drm/drmP.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_fb_helper.h>
+
+#include "sunxi_drm_drv.h"
+#include "sunxi_drm_fb.h"
+#include "sunxi_drm_gem.h"
+#include "sunxi_drm_encoder.h"
+
+static int sunxi_drm_framebuffer_create_handle(struct drm_framebuffer *fb,
+					struct drm_file *file_priv,
+					unsigned int *handle)
+{
+	struct sunxi_drm_framebuffer *sunxi_fb = to_sunxi_fb(fb);
+	int i;
+
+	DRM_DEBUG_KMS("[%d]\n", __LINE__);
+
+	for (i =0; i < MAX_FB_BUFFER; i++) {
+		if (sunxi_fb->gem_obj[i] != NULL) {
+			return drm_gem_handle_create(file_priv,
+				sunxi_fb->gem_obj[i], handle);
+		}
+	}
+	return -ENODEV;
+}
+
+static int sunxi_drm_framebuffer_dirty(struct drm_framebuffer *fb,
+			struct drm_file *file_priv, unsigned flags,
+			unsigned color, struct drm_clip_rect *clips,
+			unsigned num_clips)
+{
+	DRM_DEBUG_KMS("[%d]\n", __LINE__);
+
+	/* TODO */
+
+	return 0;
+}
+
+static void sunxi_drm_framebuffer_destroy(struct drm_framebuffer *fb)
+{
+	struct sunxi_drm_framebuffer *sunxi_fb = to_sunxi_fb(fb);
+	unsigned int i;
+
+	DRM_DEBUG_KMS("[%d]\n", __LINE__);
+
+	/* make sure that overlay data are updated before relesing fb. */
+
+	drm_framebuffer_cleanup(fb);
+
+	for (i = 0; i < MAX_FB_BUFFER; i++) {
+		if (sunxi_fb->gem_obj[i] != NULL)
+		drm_gem_object_unreference_unlocked(sunxi_fb->gem_obj[i]);
+	}
+
+	kfree(sunxi_fb);
+	sunxi_fb = NULL;
+}
+
+static int sunxi_check_max_plane_num_format(__u32 pixel_format)
+{
+	int ret = 3;
+
+	return ret;
+}
+
+static struct drm_framebuffer *sunxi_user_fb_create(struct drm_device *dev,
+	struct drm_file *file_priv, struct drm_mode_fb_cmd2 *mode_cmd)
+{
+	struct drm_gem_object *obj[MAX_FB_BUFFER];
+	struct drm_framebuffer *fb_obj;
+	int i, ret, max_cnt, nr_gem;
+
+	DRM_DEBUG_KMS("[%d]\n", __LINE__);
+	/* becareful for a buf but the yuv  in it,
+	 * and you must set the y is 0,u is 1,v is 2,etc.
+	 */
+	for (i = 0, nr_gem = 0; i < MAX_FB_BUFFER; i++) {
+		obj[i] = drm_gem_object_lookup(dev, file_priv,
+			mode_cmd->handles[i]);
+		if (!obj[i]) {
+			DRM_DEBUG_KMS("failed to lookup gem object\n");
+			continue;
+		}
+
+		nr_gem++;
+		if (!sunxi_check_gem_memory_type(obj[i], SUNXI_BO_CONTIG)) {
+			DRM_ERROR("cannot use this gem memory type for fb.\n");
+			ret = -EFAULT;
+			goto err_unreference;
+		}
+	}
+
+	max_cnt = sunxi_check_max_plane_num_format(mode_cmd->pixel_format);
+
+	if (nr_gem == 0 || nr_gem > max_cnt) {
+		DRM_ERROR("cannot use this gem memory type for fb, gem[%d][%08x].\n",nr_gem,mode_cmd->pixel_format);
+		ret = -EINVAL;
+		goto err_unreference;
+	}
+
+	fb_obj = sunxi_drm_framebuffer_creat(dev, mode_cmd, obj, nr_gem, 0);
+	if (NULL == fb_obj) {
+		ret = -ENOMEM;
+		DRM_ERROR("cannot creat drm_framebuffer.\n");
+		goto err_unreference;
+	}
+	DRM_DEBUG_KMS("line[%d] fb:%d obj:%p\n", __LINE__, fb_obj->base.id, obj[0]);
+	return fb_obj;
+
+err_unreference:
+	for (i = 0; i < MAX_FB_BUFFER; i++) {
+		if (NULL != obj[i])
+		drm_gem_object_unreference_unlocked(obj[i]);
+	}
+	return ERR_PTR(ret);
+}
+
+struct sunxi_drm_gem_buf *sunxi_drm_framebuffer_buffer(struct drm_framebuffer *fb, int index)
+{
+	struct sunxi_drm_framebuffer *sunxi_fb = to_sunxi_fb(fb);
+	struct sunxi_drm_gem_buf *buffer;
+	struct drm_gem_object	*gem_obj = sunxi_fb->gem_obj[index];
+
+	DRM_DEBUG_KMS("[%d]\n", __LINE__);
+
+	if (index >= MAX_FB_BUFFER)
+		return NULL;
+	if (NULL == gem_obj) {
+		return NULL;
+	}
+
+	buffer = (struct sunxi_drm_gem_buf *)gem_obj->driver_private;
+	if (!buffer)
+		return NULL;
+
+	DRM_DEBUG_KMS("dma_addr = 0x%llx\n", buffer->dma_addr);
+
+	return buffer;
+}
+
+static struct drm_framebuffer_funcs sunxi_drm_framebuffer_funcs = {
+	.destroy = sunxi_drm_framebuffer_destroy,
+	.create_handle = sunxi_drm_framebuffer_create_handle,
+	.dirty = sunxi_drm_framebuffer_dirty,
+};
+
+struct drm_framebuffer *sunxi_drm_framebuffer_creat(struct drm_device *dev,
+		struct drm_mode_fb_cmd2 *mode_cmd,
+		struct drm_gem_object *obj[MAX_FB_BUFFER], int nr_gem, int flags)
+{
+	struct sunxi_drm_framebuffer *sunxi_fb;
+	int ret, i, nr;
+
+	DRM_DEBUG_KMS("[%d]\n", __LINE__);
+
+	sunxi_fb = kzalloc(sizeof(*sunxi_fb), GFP_KERNEL);
+	if (!sunxi_fb) {
+		DRM_ERROR("failed to allocate sunxi drm framebuffer\n");
+		return NULL;
+	}
+
+	drm_helper_mode_fill_fb_struct(&sunxi_fb->drm_fb, mode_cmd);
+	/* fb->refcount = 2 */
+	ret = drm_framebuffer_init(dev, &sunxi_fb->drm_fb, &sunxi_drm_framebuffer_funcs);
+	if (ret) {
+		kfree(sunxi_fb);
+		DRM_ERROR("failed to initialize framebuffer\n");
+		return NULL;
+	}
+
+	for (i = 0, nr = 0; i < MAX_FB_BUFFER && nr < nr_gem; i++) {
+		if (obj[i] != NULL) {
+			sunxi_fb->gem_obj[i] = obj[i];
+			nr++;
+		}
+	}
+	sunxi_fb->drm_fb.flags = mode_cmd->flags;
+	sunxi_fb->nr_gem = nr_gem;
+	sunxi_fb->fb_flag = flags;
+
+	return &sunxi_fb->drm_fb;
+}
+
+static void sunxi_drm_output_poll_changed(struct drm_device *dev)
+{
+	struct sunxi_drm_private *private = dev->dev_private;
+	struct drm_fb_helper *fb_helper = private->fb_helper;
+
+	DRM_DEBUG_KMS("[%d]\n", __LINE__);
+
+	if (fb_helper)
+		drm_fb_helper_hotplug_event(fb_helper);
+}
+
+static const struct drm_mode_config_funcs sunxi_drm_mode_config_funcs = {
+	.fb_create = sunxi_user_fb_create,
+	.output_poll_changed = sunxi_drm_output_poll_changed,
+};
+
+void sunxi_drm_mode_config_init(struct drm_device *dev)
+{
+	dev->mode_config.min_width = 0;
+	dev->mode_config.min_height = 0;
+
+	/* max_width be decided by the de bufferline */
+	dev->mode_config.max_width = 4096;
+	dev->mode_config.max_height = 4096;
+
+	dev->mode_config.funcs = &sunxi_drm_mode_config_funcs;
+
+}
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_fb.h b/drivers/gpu/drm/sunxi/sunxi_drm_fb.h
new file mode 100755
index 0000000..ba4d28c
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_fb.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui <cuiyuntao@allwinnter.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#ifndef _SUNXI_DRM_FB_H_
+#define _SUNXI_DRM_FB_H_
+
+#include "sunxi_drm_gem.h"
+/* fix the drm_mode_fb_cmd2 may add 4 handle */
+#define MAX_FB_BUFFER 4
+#define PREFERRED_BPP 32
+/*
+ * sunxi specific framebuffer structure.
+ *
+ * @fb: drm framebuffer obejct.
+ * @buf_cnt: a buffer count to drm framebuffer.
+ * @sunxi_gem_obj: array of sunxi specific gem object containing a gem object.
+ */
+
+#define SUNXI_FBDEV_FLAGS (1<<0)
+
+#define FBDEV_BUF_NUM 2
+
+struct sunxi_drm_framebuffer {
+	struct drm_framebuffer drm_fb;
+	struct drm_gem_object *gem_obj[MAX_FB_BUFFER];
+	int nr_gem;
+	unsigned int fb_flag;
+};
+
+#define to_sunxi_fb(x)	container_of(x, struct sunxi_drm_framebuffer, drm_fb)
+
+void sunxi_drm_mode_config_init(struct drm_device *dev);
+
+struct sunxi_drm_gem_buf *sunxi_drm_framebuffer_buffer(struct drm_framebuffer *fb, int index);
+
+struct drm_framebuffer *sunxi_drm_framebuffer_creat(struct drm_device *dev,
+	struct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_object *obj[MAX_FB_BUFFER], int nr_gem, int f);
+
+#endif
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_fbdev.c b/drivers/gpu/drm/sunxi/sunxi_drm_fbdev.c
new file mode 100755
index 0000000..e5f9ac8
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_fbdev.c
@@ -0,0 +1,598 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#include <drm/drmP.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include "sunxi_drm_gem.h"
+#include "sunxi_drm_fb.h"
+#include "sunxi_drm_dmabuf.h"
+#include "sunxi_drm_fbdev.h"
+#include "sunxi_drm_drv.h"
+#include "sunxi_drm_connector.h"
+
+struct fb_dmabuf_export
+{
+	__u32 fd;
+	__u32 flags;
+};
+
+struct __fb_addr_para
+{
+	uintptr_t fb_paddr;
+	int fb_size;
+};
+
+struct __fb_addr_para g_fb_addr;
+
+#define FBIOGET_DMABUF       _IOR('F', 0x21, struct fb_dmabuf_export)
+
+int sunxi_drm_fb_ioctl(struct fb_info *info, unsigned int cmd,
+			unsigned long arg)
+{
+	struct drm_fb_helper *helper;
+	struct drm_framebuffer *fb;
+	struct sunxi_drm_framebuffer *sunxi_fb;
+	void __user *argp = (void __user *)arg;
+	int crtc = 0;
+	DRM_DEBUG_KMS("### %s:%s() ###\n", __FILE__,__func__);
+
+	helper = info->par;
+	fb = helper->fb;
+	sunxi_fb = to_sunxi_fb(fb);
+
+	switch(cmd) {
+	case FBIO_WAITFORVSYNC:
+	if (get_user(crtc, (int *)(argp))) {
+		return -EFAULT;
+	}
+	/* TODO JetCui */
+	break;
+	case FBIOGET_DMABUF:
+	{     
+	struct fb_dmabuf_export dma_arg;
+	struct dma_buf *buf;
+	int fd;
+	if (copy_from_user(&dma_arg, argp, sizeof(dma_arg))) {
+		return -EFAULT;
+	}
+
+	buf = sunxi_dmabuf_prime_export(NULL,
+	sunxi_fb->gem_obj[0], dma_arg.flags);
+
+	fd = dma_buf_fd(buf, dma_arg.flags);
+	if (fd < 0) {
+		DRM_ERROR("can not get dma_buf fd.\n");
+		dma_buf_put(buf);
+		return -ENODEV;
+	}
+
+	dma_arg.fd = (__u32)fd;
+	if (copy_to_user(argp, &dma_arg, sizeof(dma_arg))) {
+		DRM_ERROR("can not copy dma_buf fd.\n");
+		dma_buf_put(buf);
+		return -ENODEV;
+	}
+	}
+		break;
+	default:
+	DRM_ERROR("bad cmd to drm fb.\n");
+	}
+	return 0;
+}
+
+int sunxi_drm_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+	struct drm_fb_helper *helper = (struct drm_fb_helper *)info->par;
+	struct sunxi_drm_fbdev *sunxi_fbdev = to_sunxi_fbdev(helper);
+	struct sunxi_drm_framebuffer *sunxi_fb = to_sunxi_fb(sunxi_fbdev->drm_fb_helper.fb);
+	struct drm_gem_object *sunxi_gem_obj = sunxi_fb->gem_obj[0];
+	struct sunxi_drm_gem_buf *buffer = (struct sunxi_drm_gem_buf *)sunxi_gem_obj->driver_private;
+	unsigned long vm_size;
+	int ret;
+
+	DRM_DEBUG_KMS("### %s:%s() ###\n", __FILE__,__func__);
+
+	vma->vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;
+
+	vm_size = vma->vm_end - vma->vm_start;
+
+	if (vm_size > buffer->size) {
+		DRM_ERROR("failed to mmap %ld > %ld.\n",vm_size, buffer->size);
+		return -EINVAL;
+	}
+	ret = dma_mmap_attrs(helper->dev->dev, vma, buffer->kvaddr,
+	buffer->dma_addr, buffer->size, &buffer->dma_attrs);
+	if (ret < 0) {
+		DRM_ERROR("failed to mmap.\n");
+		return ret;
+	}
+
+	return 0;
+}
+/*
+int sunxi_fb_fpan_display(struct fb_var_screeninfo *var,
+			      struct fb_info *info)
+{
+    struct drm_fb_helper *fb_helper = info->par;
+	struct drm_device *dev = fb_helper->dev;
+    struct drm_framebuffer *fb;
+
+    DRM_DEBUG_KMS("%s:(%s):%d ###\n", __FILE__,__func__,__LINE__);
+
+    fb = fb_helper->fb;
+	drm_modeset_lock_all(dev);
+    fb->offsets[0] = var->yoffset * fb->pitches[0];
+    //var->yoffset = 0;
+	drm_modeset_unlock_all(dev);
+    
+	return drm_fb_helper_pan_display(var, info);
+    
+}
+*/
+void sunxi_get_fb_addr_para(struct __fb_addr_para *fb_addr_para)
+{
+	if (fb_addr_para){
+		fb_addr_para->fb_paddr = g_fb_addr.fb_paddr;
+		fb_addr_para->fb_size  = g_fb_addr.fb_size;
+	}
+}
+EXPORT_SYMBOL(g_fb_addr);
+/*
+ * BUG: EXPORT SYMBOL: sunxi_get_fb_addr_para isn't unique!
+ * Buddy
+ */
+EXPORT_SYMBOL(sunxi_get_fb_addr_para);
+
+static struct fb_ops sunxi_drm_fb_ops = {
+	.owner = THIS_MODULE,
+	.fb_mmap = sunxi_drm_fb_mmap,
+#if defined(CONFIG_FB_CONSOLE_SUNXI)
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+#endif
+	.fb_check_var = drm_fb_helper_check_var,
+	.fb_set_par = drm_fb_helper_set_par,
+	.fb_blank = drm_fb_helper_blank,
+	.fb_pan_display	= drm_fb_helper_pan_display,
+	.fb_setcmap = drm_fb_helper_setcmap,
+	.fb_ioctl = sunxi_drm_fb_ioctl,
+#ifdef CONFIG_COMPAT
+	.fb_compat_ioctl = NULL,
+#endif
+};
+
+static int sunxi_fb_fill_fbdev(struct drm_fb_helper *helper,
+				     struct drm_framebuffer *fb)
+{
+	struct fb_info *fbi = helper->fbdev;
+	struct drm_device *dev = helper->dev;
+	struct sunxi_drm_gem_buf *buffer;
+	unsigned long offset;
+
+	DRM_DEBUG_KMS("[%d]\n", __LINE__);
+
+	drm_fb_helper_fill_fix(fbi, fb->pitches[0], fb->depth);
+	drm_fb_helper_fill_var(fbi, helper, fb->width, fb->height / FBDEV_BUF_NUM);//TODO for picth
+	buffer = sunxi_drm_framebuffer_buffer(fb, 0);
+	if (!buffer) {
+		DRM_LOG_KMS("buffer is null.\n");
+		return -EFAULT;
+	}
+
+	offset = fbi->var.xoffset * (fb->bits_per_pixel >> 3);
+	offset += fbi->var.yoffset * fb->pitches[0];
+
+	dev->mode_config.fb_base = (resource_size_t)buffer->dma_addr;
+	fbi->screen_base = buffer->kvaddr + offset;
+	fbi->fix.smem_start = (unsigned long)buffer->dma_addr;
+
+	fbi->screen_size = buffer->size;
+	fbi->fix.smem_len = buffer->size;
+	printk("addr:0x%lx  size:%ld\n",(unsigned long)buffer->dma_addr,buffer->size);
+	g_fb_addr.fb_paddr = (unsigned long)buffer->dma_addr;
+	g_fb_addr.fb_size = buffer->size;
+
+	return 0;
+}
+
+void sunxi_fb_gamma_set(struct drm_crtc *crtc, u16 red, u16 green,
+		  u16 blue, int regno)
+{
+}
+
+void sunxi_fb_gamma_get(struct drm_crtc *crtc, u16 *red, u16 *green,
+		  u16 *blue, int regno)
+{
+
+}
+
+int sunxi_fb_probe(struct drm_fb_helper *helper,
+		struct drm_fb_helper_surface_size *sizes)
+{
+	struct drm_gem_object *gem_obj[MAX_FB_BUFFER];
+	struct drm_device *dev = helper->dev;
+	struct fb_info *fbi;
+	struct drm_mode_fb_cmd2 mode_cmd = { 0 };
+	struct platform_device *pdev = dev->platformdev;
+	struct drm_mode_create_dumb dump_args = { 0 };
+	int ret;
+
+
+	sizes->surface_depth = 32;
+	mode_cmd.width = sizes->fb_width;
+	mode_cmd.height = sizes->fb_height * FBDEV_BUF_NUM;//double buffers? or more?
+	mode_cmd.pitches[0] = sizes->fb_width * (sizes->surface_bpp >> 3);//with GPU
+	mode_cmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,
+							  sizes->surface_depth);
+
+	dump_args.height = mode_cmd.height;
+	dump_args.width = mode_cmd.width;
+	dump_args.bpp = sizes->surface_bpp;
+	dump_args.flags = SUNXI_BO_CONTIG |SUNXI_BO_CACHABLE;
+	DRM_INFO("surface(%d x %d), fb(%d x %d) and bpp(%d) form(%d)\n",
+			sizes->surface_width, sizes->surface_height,
+			sizes->fb_width, sizes->fb_height,
+			sizes->surface_bpp, mode_cmd.pixel_format);
+	mutex_lock(&dev->struct_mutex);
+
+	fbi = framebuffer_alloc(0, &pdev->dev);
+	if (!fbi) {
+		DRM_ERROR("failed to allocate fb info.\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/*if sync with bootloader, creat the gem_obj from paddr */
+	gem_obj[0] = sunxi_drm_gem_creat(dev, &dump_args);
+	if (NULL == gem_obj[0]) {
+	DRM_ERROR("failed to creat sunxi gem for fbdev.\n");
+		goto err_release_framebuffer;
+	}
+
+	helper->fb = sunxi_drm_framebuffer_creat(dev, &mode_cmd,
+			gem_obj, 1, SUNXI_FBDEV_FLAGS);
+	if (IS_ERR(helper->fb)) {
+		DRM_ERROR("failed to create drm framebuffer.\n");
+		ret = PTR_ERR(helper->fb);
+		goto err_destroy_gem;
+	}
+
+	helper->fbdev = fbi;
+
+	fbi->par = helper;
+	fbi->flags = FBINFO_FLAG_DEFAULT;
+	fbi->fbops = &sunxi_drm_fb_ops;
+
+	ret = fb_alloc_cmap(&fbi->cmap, 256, 0);
+	if (ret) {
+		DRM_ERROR("failed to allocate cmap.\n");
+		goto err_destroy_framebuffer;
+	}
+
+	ret = sunxi_fb_fill_fbdev(helper, helper->fb);
+	if (ret < 0)
+		goto err_dealloc_cmap;
+
+	mutex_unlock(&dev->struct_mutex);
+	return ret;
+
+err_dealloc_cmap:
+	fb_dealloc_cmap(&fbi->cmap);
+err_destroy_framebuffer:
+	drm_framebuffer_cleanup(helper->fb);
+err_destroy_gem:
+	drm_gem_object_unreference(gem_obj[0]);
+err_release_framebuffer:
+	framebuffer_release(fbi);
+
+/*
+* if failed, all resources allocated above would be released by
+* drm_mode_config_cleanup() when drm_load() had been called prior
+* to any specific driver such as fimd or hdmi driver.
+*/
+out:
+	mutex_unlock(&dev->struct_mutex);
+	return ret;
+}
+
+static struct drm_display_mode *sunx_pick_cmdline_mode(struct drm_fb_helper_connector *fb_helper_conn)
+{
+	struct drm_cmdline_mode *cmdline_mode;
+	struct drm_display_mode *mode = NULL;
+
+	cmdline_mode = &fb_helper_conn->cmdline_mode;
+	if (cmdline_mode->specified == false)
+		return mode;
+
+	list_for_each_entry(mode, &fb_helper_conn->connector->modes, head) {
+		/* check width/height */
+		if (mode->hdisplay != cmdline_mode->xres ||
+			mode->vdisplay != cmdline_mode->yres)
+			continue;
+
+		if (cmdline_mode->refresh_specified) {
+			if (mode->vrefresh != cmdline_mode->refresh)
+			continue;
+		}
+
+		if (cmdline_mode->interlace) {
+			if (!(mode->flags & DRM_MODE_FLAG_INTERLACE))
+				continue;
+			}
+		return mode;
+	}
+	return mode;
+}
+
+static struct drm_display_mode *sunxi_find_similar_modes(struct drm_display_mode *ref_mode,
+				struct drm_connector *connector)
+{
+#ifdef CONFIG_ARM
+	unsigned int ref_factor, tmp_factor, little_factor = 1000000, cmp_factor;
+#endif
+#ifdef CONFIG_ARM64
+	unsigned long long ref_factor, tmp_factor, little_factor = 100000000, cmp_factor;
+#endif
+	struct drm_display_mode *mode = NULL;
+	struct drm_display_mode *fix_mode = NULL;
+#ifdef CONFIG_ARM
+	ref_factor = ((ref_mode->hdisplay) << 10) / ref_mode->vdisplay;
+#endif
+#ifdef CONFIG_ARM64
+	ref_factor = (((unsigned long long)ref_mode->hdisplay) << 10) / ref_mode->vdisplay;
+#endif
+
+	fix_mode = list_entry(connector->modes.next, struct drm_display_mode, head);
+
+	list_for_each_entry(mode, &connector->modes, head) {
+		/* check width/height */
+		if (mode->hdisplay < ref_mode->hdisplay || mode->vdisplay < ref_mode->vdisplay)
+			continue;
+#ifdef CONFIG_ARM
+		tmp_factor = ((mode->hdisplay) << 10) / mode->vdisplay;
+#endif
+#ifdef CONFIG_ARM64
+		tmp_factor = (((unsigned long long)mode->hdisplay) << 10) / mode->vdisplay;
+#endif
+		if (tmp_factor > ref_factor) {
+			cmp_factor = tmp_factor - ref_factor;
+		}else {
+			cmp_factor = ref_factor - tmp_factor;
+		}
+		if (little_factor > cmp_factor) {
+			little_factor = cmp_factor;
+			fix_mode = mode;
+		}
+	}
+	DRM_DEBUG_KMS("ref width(%d) height(%d) and fix_w(%d) h(%d)\n",
+	ref_mode->hdisplay, ref_mode->vdisplay, fix_mode->hdisplay, fix_mode->vdisplay);
+
+	return fix_mode;
+}
+
+bool sunxi_fb_initial_config(struct drm_fb_helper *fb_helper,
+		struct drm_fb_helper_crtc **crtcs,
+		struct drm_display_mode **modes,
+		bool *enabled, int width, int height)
+{
+	/*set the mode or the connector and becareful for using 1 fb*/
+	int i, ref = -1, c = 0;
+	struct drm_connector *connector;
+	struct sunxi_drm_connector *sunxi_connector;
+	struct drm_display_mode *ref_modes = NULL;
+	struct drm_encoder	    *encoder;
+	struct drm_connector_helper_funcs *connector_funcs;
+	unsigned int assign_crtc = 0;
+	struct drm_fb_helper_crtc *crtc;
+
+retry:
+	assign_crtc = 0;
+	/* pick the modes for connector */
+	for (i = 0; i < fb_helper->connector_count; i++) {
+		connector = fb_helper->connector_info[i]->connector;
+		sunxi_connector = to_sunxi_connector(connector);
+		if (!enabled[i]) {
+		modes[i] = NULL;
+		continue;
+		}
+
+		if (ref_modes == NULL && sunxi_connector->disp_out_type == DISP_OUTPUT_TYPE_LCD) {
+			ref_modes = list_entry(connector->modes.next, struct drm_display_mode, head);
+			modes[i] = ref_modes;
+			goto retry;
+		}
+
+		modes[i] = sunx_pick_cmdline_mode(fb_helper->connector_info[i]);
+		if (modes[i]) {
+			ref = i;
+			if (!ref_modes) {
+				goto retry;
+			}
+		}
+
+		if (ref == -1) {
+			modes[i] = list_entry(connector->modes.next, struct drm_display_mode, head);
+			ref = i;
+		}
+
+		if (ref_modes) {
+			modes[i] = sunxi_find_similar_modes(ref_modes, connector);
+		} else {
+			modes[i] = sunxi_find_similar_modes(modes[ref], connector);
+		}
+		if (!modes[i])
+			continue;
+
+		connector_funcs = connector->helper_private;
+		encoder = connector_funcs->best_encoder(connector);
+		if (!encoder)
+			continue;
+
+		for (c = 0; c < fb_helper->crtc_count; c++) {
+			crtc = &fb_helper->crtc_info[c];
+
+			if ((encoder->possible_crtcs & (1 << c)) == 0)
+				continue;
+			if ((assign_crtc & (1 << c)) == 0) {
+				assign_crtc |= (1 << c);
+				crtcs[i] = crtc;
+				DRM_INFO("connetor(%d)--->crtc(%d) encoder:%d,resolution(%d x %d)\n",
+				i,c,encoder->base.id, modes[i]->hdisplay, modes[i]->vdisplay);
+				break;
+			}
+		}
+	}
+
+	return true;
+}
+
+struct drm_fb_helper_funcs sunxi_drm_fb_helper = {
+	.gamma_set = NULL,
+	.gamma_get = NULL,
+	.fb_probe = sunxi_fb_probe,
+	.initial_config = sunxi_fb_initial_config,
+};
+
+int sunxi_drm_fbdev_creat(struct drm_device *dev)
+{
+	struct sunxi_drm_fbdev *fbdev;
+	struct sunxi_drm_private *private = dev->dev_private;
+	struct drm_fb_helper *helper;
+	unsigned int num_crtc;
+	int ret;
+
+	DRM_DEBUG_KMS("[%d]\n", __LINE__);
+
+	if (!dev->mode_config.num_crtc || !dev->mode_config.num_connector)
+		return 0;
+
+    printk("[BUDDY_DRM][%s-%d]\n", __func__, __LINE__);
+	fbdev = kzalloc(sizeof(*fbdev), GFP_KERNEL);
+	if (!fbdev) {
+		DRM_ERROR("failed to allocate drm fbdev.\n");
+		return -ENOMEM;
+	}
+    printk("[BUDDY_DRM][%s-%d]\n", __func__, __LINE__);
+
+	private->fb_helper = helper = &fbdev->drm_fb_helper;
+    printk("[BUDDY_DRM][%s-%d]\n", __func__, __LINE__);
+	helper->funcs = &sunxi_drm_fb_helper;
+    printk("[BUDDY_DRM][%s-%d]\n", __func__, __LINE__);
+
+	num_crtc = dev->mode_config.num_crtc;
+    printk("[BUDDY_DRM][%s-%d]\n", __func__, __LINE__);
+
+	ret = drm_fb_helper_init(dev, helper, num_crtc, dev->mode_config.num_connector);
+    printk("[BUDDY_DRM][%s-%d]\n", __func__, __LINE__);
+	if (ret < 0) {
+		DRM_ERROR("failed to initialize drm fb helper.\n");
+		goto err_init;
+	}
+    printk("[BUDDY_DRM][%s-%d]\n", __func__, __LINE__);
+
+	ret = drm_fb_helper_single_add_all_connectors(helper);
+    printk("[BUDDY_DRM][%s-%d]\n", __func__, __LINE__);
+	if (ret < 0) {
+		DRM_ERROR("failed to register drm_fb_helper_connector.\n");
+		goto err_setup;
+	}
+    printk("[BUDDY_DRM][%s-%d]\n", __func__, __LINE__);
+
+	/* TODO disable all the possible outputs/crtcs before entering KMS mode */
+	drm_helper_disable_unused_functions(dev);
+    printk("[BUDDY_DRM][%s-%d]\n", __func__, __LINE__);
+
+	ret = drm_fb_helper_initial_config(helper, PREFERRED_BPP);
+    printk("[BUDDY_DRM][%s-%d]\n", __func__, __LINE__);
+	if (ret < 0) {
+		DRM_ERROR("failed to set up hw configuration.\n");
+		goto err_setup;
+	}
+    printk("[BUDDY_DRM][%s-%d]\n", __func__, __LINE__);
+
+	return 0;
+
+err_setup:
+    printk("[BUDDY_DRM][%s-%d]\n", __func__, __LINE__);
+	drm_fb_helper_fini(helper);
+    printk("[BUDDY_DRM][%s-%d]\n", __func__, __LINE__);
+
+err_init:
+    printk("[BUDDY_DRM][%s-%d]\n", __func__, __LINE__);
+	private->fb_helper = NULL;
+	kfree(fbdev);
+
+    printk("[BUDDY_DRM][%s-%d]\n", __func__, __LINE__);
+	return ret;
+}
+
+void sunxi_drm_fbdev_destroy(struct drm_device *dev)
+{
+	struct sunxi_drm_private *private = dev->dev_private;
+	struct sunxi_drm_fbdev *fbdev;
+	struct drm_framebuffer *fb;
+	struct sunxi_drm_framebuffer *sunxi_fb;
+	struct drm_fb_helper	*fb_helper;
+
+	if (!private || !private->fb_helper)
+		return;
+	fb_helper = private->fb_helper;
+	fbdev = to_sunxi_fbdev(private->fb_helper);
+	fb = fbdev->drm_fb_helper.fb;
+	if (!fb) {
+		return;
+	}
+
+	sunxi_fb = (struct sunxi_drm_framebuffer *)fb;
+	/* release drm framebuffer and gem_obj */
+	if (fb_helper->fb && fb_helper->fb->funcs) {
+		fb = fb_helper->fb;
+		if (fb) {
+			drm_framebuffer_unregister_private(fb);
+			drm_framebuffer_remove(fb);
+		}
+	}
+
+	/* release linux framebuffer */
+	if (fb_helper->fbdev) {
+		struct fb_info *info;
+		int ret;
+
+		info = fb_helper->fbdev;
+		ret = unregister_framebuffer(info);
+		if (ret < 0)
+			DRM_DEBUG_KMS("failed unregister_framebuffer()\n");
+
+		if (info->cmap.len)
+			fb_dealloc_cmap(&info->cmap);
+
+		framebuffer_release(info);
+	}
+
+	drm_fb_helper_fini(fb_helper);
+	kfree(fbdev);
+	private->fb_helper = NULL;
+}
+
+void sunxi_drm_fbdev_restore_mode(struct drm_device *dev)
+{
+	struct sunxi_drm_private *private = dev->dev_private;
+
+	if (!private || !private->fb_helper)
+		return;
+
+	drm_modeset_lock_all(dev);
+	drm_fb_helper_restore_fbdev_mode(private->fb_helper);
+	drm_modeset_unlock_all(dev);
+}
+
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_fbdev.h b/drivers/gpu/drm/sunxi/sunxi_drm_fbdev.h
new file mode 100755
index 0000000..ca6b649
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_fbdev.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui <cuiyuntao@allwinnter.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#ifndef _SUNXI_DRM_FBDEV_H_
+#define _SUNXI_DRM_FBDEV_H_
+#include <drm/drm_fb_helper.h>
+
+
+struct sunxi_drm_fbdev {
+        struct drm_fb_helper drm_fb_helper;
+};
+
+#define to_sunxi_fbdev(x)	container_of(x, struct sunxi_drm_fbdev,\
+				drm_fb_helper)
+
+void sunxi_drm_fbdev_restore_mode(struct drm_device *dev);
+
+void sunxi_drm_fbdev_destroy(struct drm_device *dev);
+
+int sunxi_drm_fbdev_creat(struct drm_device *dev);
+
+#endif
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_gem.c b/drivers/gpu/drm/sunxi/sunxi_drm_gem.c
new file mode 100755
index 0000000..16bdfdc
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_gem.c
@@ -0,0 +1,594 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <drm/drmP.h>
+ 
+#include <linux/shmem_fs.h>
+#include "sunxi_drm_gem.h"
+#include <drm/sunxi_drm.h>
+
+struct page_info {
+	struct page *page;
+	unsigned int order;
+	struct list_head list;
+};
+
+void sunxi_sync_buf(struct sunxi_drm_gem_buf *buf)
+{
+	dma_sync_sg_for_device(NULL, buf->sgt->sgl,
+		buf->sgt->nents, DMA_BIDIRECTIONAL);
+
+}
+
+static int contig_buf_alloc(struct drm_device *dev,
+            struct sunxi_drm_gem_buf *buf)
+{
+
+	unsigned int nr_pages, i;
+	struct page **pages = NULL;
+	dma_addr_t start_addr;
+	enum dma_attr attr;
+	struct scatterlist *sg;
+	nr_pages = buf->size >> PAGE_SHIFT;
+
+	init_dma_attrs(&buf->dma_attrs);
+
+	dma_set_attr(DMA_ATTR_FORCE_CONTIGUOUS, &buf->dma_attrs);
+
+	if (buf->flags & SUNXI_BO_WC || !(buf->flags & SUNXI_BO_CACHABLE))
+		attr = DMA_ATTR_WRITE_COMBINE;
+	else
+		attr = DMA_ATTR_NON_CONSISTENT;
+	pages = kzalloc(sizeof(struct page*) * nr_pages,
+			GFP_KERNEL);
+	if (!pages) {
+		DRM_ERROR("failed to allocate pages.\n");
+		return -ENOMEM;
+	}
+
+	buf->kvaddr = dma_alloc_attrs(dev->dev, buf->size,
+			&buf->dma_addr, GFP_HIGHUSER | __GFP_ZERO,
+			&buf->dma_attrs);
+	if (!buf->kvaddr) {
+		DRM_ERROR("failed to allocate buffer.\n");
+		kfree(pages);
+		return -ENOMEM;
+	}
+	i = 0;
+	start_addr = buf->dma_addr;
+	while (i < nr_pages) {
+		pages[i] = phys_to_page(start_addr);
+		start_addr += PAGE_SIZE;
+		i++;
+	}
+
+	buf->sgt = drm_prime_pages_to_sg(pages, nr_pages);
+	if (!buf->sgt) {
+		DRM_ERROR("failed to get sg table.\n");
+		goto err_free;
+	}
+
+	for_each_sg(buf->sgt->sgl, sg, buf->sgt->nents, i) {
+		sg_dma_address(sg) = sg_phys(sg);
+		sg_dma_len(sg) = sg->length;
+	}
+
+	kfree(pages);
+	return 0;
+
+err_free:
+	dma_free_attrs(dev->dev, buf->size, buf->kvaddr,
+			(dma_addr_t)buf->dma_addr, &buf->dma_attrs);
+	buf->dma_addr = (dma_addr_t)NULL;
+	kfree(pages);
+	return -ENOMEM;
+}
+
+static inline int sunxi_order_gfp(unsigned long size, gfp_t *gfp_flags)
+{
+	int gem_order;
+
+	gem_order = get_order(size);
+	if (gem_order >= MAX_ORDER)
+	gem_order = MAX_ORDER - 1;
+	if (gem_order > 4) {
+		*gfp_flags = GFP_HIGHUSER | __GFP_ZERO | __GFP_NOWARN |
+				__GFP_NORETRY;
+	} else {
+		*gfp_flags = GFP_HIGHUSER | __GFP_ZERO | __GFP_NOWARN;
+	}
+
+	if ((1 << gem_order) * PAGE_SIZE - size <= PAGE_SIZE)
+		return gem_order;
+
+	return gem_order - 1;
+}
+
+static int nocontig_buf_alloc(struct drm_device *dev,
+            struct sunxi_drm_gem_buf *buf)
+{
+	long tmp_size, count;
+	int cur_order;
+	struct list_head head;
+	struct page_info *curs, *tmp_curs;
+	gfp_t gfp_flags;
+	struct page *page;
+	struct scatterlist *sg;
+
+	INIT_LIST_HEAD(&head);
+	tmp_size = buf->size;
+	if (buf->size / PAGE_SIZE > totalram_pages / 2)
+		return -ENOMEM;
+
+	cur_order = sunxi_order_gfp(tmp_size, &gfp_flags);
+
+	if (unlikely(cur_order < 0)) {
+		DRM_ERROR("bad order.\n");
+		return -ENOMEM;
+	}
+
+	count = 0;
+	while (tmp_size > 0 && cur_order >= 0) {
+
+		page = alloc_pages(gfp_flags, cur_order);
+		if (page == NULL) {
+			cur_order--;
+			if (cur_order < 0) {
+				DRM_ERROR("bad alloc for 0 order.\n");
+				goto err_alloc;
+			}
+			continue;
+		}
+		curs = kzalloc(sizeof(struct page_info), GFP_KERNEL);
+		if (curs == NULL) {
+			DRM_ERROR("bad alloc for page info.\n");
+			goto err_alloc;
+		}
+		curs->order = cur_order;
+		curs->page = page;
+		list_add_tail(&curs->list, &head);
+		tmp_size -= (1 << cur_order) * PAGE_SIZE;
+		cur_order = sunxi_order_gfp(tmp_size, &gfp_flags);
+		count++;
+
+	}
+
+	if (tmp_size > 0) {
+		DRM_ERROR("bad alloc err for totle size.\n");
+		goto err_alloc;
+	}
+
+	buf->sgt = kzalloc(sizeof(struct sg_table), GFP_KERNEL);
+	if (!buf->sgt) {
+		DRM_ERROR("bad alloc for sgt.\n");
+		goto err_alloc;
+	}
+
+	if (sg_alloc_table(buf->sgt, count, GFP_KERNEL)) {
+		DRM_ERROR("bad alloc for sg.\n");
+		goto err_alloc;
+	}
+
+	sg = buf->sgt->sgl;
+	list_for_each_entry_safe(curs, tmp_curs, &head, list) {
+		sg_set_page(sg, curs->page, (1 << curs->order) * PAGE_SIZE, 0);
+		sg->dma_address = sg_phys(sg);
+		list_del(&curs->list);
+		kfree(curs);
+		sg = sg_next(sg);
+	}
+
+	return 0;
+err_alloc:
+	list_for_each_entry_safe(curs, tmp_curs, &head, list) {
+		__free_pages(curs->page, curs->order);
+		list_del(&curs->list);
+	}
+
+	return -ENOMEM;
+}
+
+static int lowlevel_buffer_allocate(struct drm_device *dev,
+            struct sunxi_drm_gem_buf *buf)
+{
+	DRM_DEBUG_DRIVER("[%d]\n", __LINE__);
+
+	buf->size = PAGE_ALIGN(buf->size);
+	if (buf->flags & SUNXI_BO_CONTIG) {
+		return contig_buf_alloc(dev, buf);
+	}else{
+		return nocontig_buf_alloc(dev, buf);
+	}
+}
+
+static void lowlevel_buffer_destroy(struct drm_device *dev,
+            struct sunxi_drm_gem_buf *buf)
+{
+	struct scatterlist *sg;
+	int i, order;
+	struct page *page;
+
+	DRM_DEBUG_DRIVER("[%d]\n", __LINE__);
+
+	if ((buf->flags & SUNXI_BO_CONTIG) == 0) {
+		DRM_INFO("destroy non-contig mem.\n");
+		for_each_sg(buf->sgt->sgl, sg, buf->sgt->nents, i) {
+			page = sg_page(sg);
+			order = get_order(sg->length);
+			__free_pages(page, order);
+		}
+	}else{
+
+		DRM_DEBUG_KMS("dma_addr(0x%lx), size(0x%lx)\n",
+				(unsigned long)buf->dma_addr,
+				buf->size);
+
+		dma_free_attrs(dev->dev, buf->size, buf->kvaddr,
+				(dma_addr_t)buf->dma_addr, &buf->dma_attrs);
+
+		buf->dma_addr = (dma_addr_t)NULL;
+	}
+	sg_free_table(buf->sgt);
+
+	kfree(buf->sgt);
+	buf->sgt = NULL;
+}
+
+static struct sunxi_drm_gem_buf *sunxi_buf_create(struct drm_mode_create_dumb *args)
+{
+	struct sunxi_drm_gem_buf *sunxi_buf;
+	/*
+	  * The pitch decided by driver, but you must consult the gpu ddk.
+	  * "pitch should be 8 aligned" mali GPU said.
+	 */
+	uint64_t size;
+	sunxi_buf =  kzalloc(sizeof(struct sunxi_drm_gem_buf), GFP_KERNEL);
+	if (NULL == sunxi_buf) {
+		DRM_ERROR("Bad alloc for sunxi_buf.\n");
+		return NULL;
+	}
+
+	args->pitch = args->width * ((args->bpp + 7) / 8);
+	size = args->pitch * args->height;
+	/* GEM use the size for PAGE_ALIGN */
+	args->size = PAGE_ALIGN(size);
+	sunxi_buf->flags = args->flags;
+	sunxi_buf->size = args->size;
+
+	return sunxi_buf;
+}
+
+void sunxi_buf_destroy(struct sunxi_drm_gem_buf *sunxi_buf)
+{
+	kfree(sunxi_buf);
+}
+
+void sunxi_drm_gem_destroy(struct drm_gem_object *gem_obj)
+{
+	struct sunxi_drm_gem_buf *sunxi_buf;
+
+	DRM_DEBUG_DRIVER("[%d]\n", __LINE__);
+
+	sunxi_buf = (struct sunxi_drm_gem_buf *)gem_obj->driver_private;
+	gem_obj->driver_private = NULL;
+
+	DRM_DEBUG_DRIVER("handle count = %d\n", atomic_read(&gem_obj->handle_count));
+
+	if (gem_obj->import_attach) {
+		drm_prime_gem_destroy(gem_obj, sunxi_buf->sgt);
+	}else {
+		lowlevel_buffer_destroy(gem_obj->dev, sunxi_buf);
+	}
+
+	sunxi_buf_destroy(sunxi_buf);
+
+	if (gem_obj->map_list.map) {
+		drm_gem_free_mmap_offset(gem_obj);
+	}
+
+	drm_gem_object_release(gem_obj);
+	kfree(gem_obj);
+}
+
+struct drm_gem_object *sunxi_drm_gem_creat(struct drm_device *dev,
+			struct drm_mode_create_dumb *args)
+{
+	struct drm_gem_object *sunxi_gem_obj;
+	struct sunxi_drm_gem_buf *sunxi_buf;
+	DRM_DEBUG_DRIVER("[%d]\n", __LINE__);
+
+	sunxi_buf = sunxi_buf_create(args);
+	if (sunxi_buf == NULL) {
+		DRM_ERROR("failed to delete sunxi_drm_gem_buf.\n");
+		return NULL;
+	}
+
+	if (lowlevel_buffer_allocate(dev, sunxi_buf)) {
+		sunxi_buf_destroy(sunxi_buf);
+		return NULL;
+	}
+
+	sunxi_gem_obj = drm_gem_object_alloc(dev, sunxi_buf->size);
+	if (IS_ERR_OR_NULL(sunxi_gem_obj)) {
+		DRM_ERROR("failed to delete sunxi_gem_obj.\n");
+		lowlevel_buffer_destroy(dev, sunxi_buf);
+		sunxi_buf_destroy(sunxi_buf);
+		return NULL;
+	}
+
+	sunxi_gem_obj->driver_private = (void *)sunxi_buf;
+
+	DRM_DEBUG_DRIVER("obj:%p  addr:%llx\n", sunxi_gem_obj, sunxi_buf->dma_addr);
+
+	return sunxi_gem_obj;
+}
+
+int sunxi_drm_gem_dumb_create(struct drm_file *file_priv,
+			struct drm_device *dev,
+			struct drm_mode_create_dumb *args)
+{
+	struct drm_gem_object *gem_obj;
+	int ret;
+
+	DRM_DEBUG_KMS("[%d]\n", __LINE__);
+
+	gem_obj = sunxi_drm_gem_creat(dev, args);
+	if (NULL == gem_obj)
+		return -ENOMEM;
+
+	ret = drm_gem_handle_create(file_priv, gem_obj,
+					&args->handle);
+	/* refcount = 2, so unreference;
+	* refcount = 1, handle_count = 1
+	*/
+	drm_gem_object_unreference_unlocked(gem_obj); 
+	if (ret) {
+		sunxi_drm_gem_destroy(gem_obj);
+		return ret;
+	}
+	DRM_DEBUG_DRIVER("obj:%p handle:%u [%d  %d  %d] bpp:%d.\n"
+			,gem_obj,args->handle, args->width, args->height,
+				args->pitch, args->bpp);
+	return 0;
+}
+
+int sunxi_drm_gem_dumb_destroy(struct drm_file *file_priv,
+			struct drm_device *dev,
+			unsigned int handle)
+{
+	int ret;
+
+	DRM_DEBUG_DRIVER("[%d]\n", __LINE__);
+	ret = drm_gem_handle_delete(file_priv, handle);
+	if (ret < 0) {
+		DRM_ERROR("failed to delete drm_gem_handle.\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void sunxi_update_vm_attr(struct sunxi_drm_gem_buf *sunxi_buf,
+					struct vm_area_struct *vma)
+{
+	DRM_DEBUG_DRIVER("flags = 0x%x\n", sunxi_buf->flags);
+
+	if (sunxi_buf->flags & SUNXI_BO_CACHABLE) {
+		vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
+	}else if(sunxi_buf->flags & SUNXI_BO_WC) {
+		vma->vm_page_prot =
+		pgprot_writecombine(vm_get_page_prot(vma->vm_flags));
+	}else{
+		vma->vm_page_prot =
+		pgprot_noncached(vm_get_page_prot(vma->vm_flags));
+	}
+}
+
+static int sunxi_drm_gem_map_buf(struct drm_gem_object *obj,
+				struct vm_area_struct *vma,
+				unsigned long f_vaddr,
+				pgoff_t page_offset)
+{
+	struct sunxi_drm_gem_buf *buf =
+	(struct sunxi_drm_gem_buf *)obj->driver_private;
+	struct scatterlist *sgl;
+	unsigned long pfn;
+	int i;
+
+	if (!buf->sgt)
+		return -EINTR;
+
+	if (page_offset >= (buf->size >> PAGE_SHIFT)) {
+		DRM_ERROR("invalid page offset\n");
+		return -EINVAL;
+	}
+
+	sgl = buf->sgt->sgl;
+	for_each_sg(buf->sgt->sgl, sgl, buf->sgt->nents, i) {
+		if (page_offset < (sgl->length >> PAGE_SHIFT))
+			break;
+		page_offset -=	(sgl->length >> PAGE_SHIFT);
+	}
+
+	pfn = __phys_to_pfn(sg_phys(sgl)) + page_offset;
+
+	DRM_DEBUG_DRIVER("map:%llx  vm:[%lx,%lx] fault:%lx pfn:%ld  flag:%lx, page:\n",
+			buf->dma_addr, vma->vm_start,vma->vm_end,f_vaddr, pfn,
+			vma->vm_flags);
+
+	return vm_insert_pfn(vma, f_vaddr, pfn);
+}
+
+static unsigned int convert_to_vm_err_msg(int msg)
+{
+	unsigned int out_msg;
+
+	switch (msg) {
+	case 0:
+	case -ERESTARTSYS:
+	case -EINTR:
+		out_msg = VM_FAULT_NOPAGE;
+		break;
+
+	case -ENOMEM:
+		out_msg = VM_FAULT_OOM;
+		break;
+
+	default:
+		out_msg = VM_FAULT_SIGBUS;
+		break;
+	}
+
+	return out_msg;
+}
+
+int sunxi_drm_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+	struct drm_gem_object *obj = vma->vm_private_data;
+	struct drm_device *dev = obj->dev;
+	unsigned long f_vaddr;
+	pgoff_t page_offset;
+	int ret;
+
+	page_offset = ((unsigned long)vmf->virtual_address -
+			vma->vm_start) >> PAGE_SHIFT;
+	f_vaddr = (unsigned long)vmf->virtual_address;
+
+	mutex_lock(&dev->struct_mutex);
+
+	ret = sunxi_drm_gem_map_buf(obj, vma, f_vaddr, page_offset);
+	if (ret < 0)
+		DRM_ERROR("failed to map a buffer with user.\n");
+
+	mutex_unlock(&dev->struct_mutex);
+
+	return convert_to_vm_err_msg(ret);
+}
+
+static int check_gem_flags(unsigned int flags)
+{
+	if (flags & ~(SUNXI_BO_MASK)) {
+		DRM_ERROR("invalid flags.\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int sunxi_drm_gem_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	struct drm_gem_object *obj;
+	struct sunxi_drm_gem_buf *sunxi_buf;
+	int ret;
+
+	DRM_DEBUG_DRIVER("[%d]\n", __LINE__);
+
+	/* set vm_area_struct. */
+	ret = drm_gem_mmap(filp, vma);
+	if (ret < 0) {
+		DRM_ERROR("failed to mmap.\n");
+		return ret;
+	}
+
+	obj = vma->vm_private_data;
+	sunxi_buf = (struct sunxi_drm_gem_buf *)obj->driver_private;
+	ret = check_gem_flags(sunxi_buf->flags);
+	if (ret) {
+		drm_gem_vm_close(vma);
+		drm_gem_free_mmap_offset(obj);
+		return ret;
+	}
+
+	vma->vm_flags |= VM_PFNMAP | VM_DONTEXPAND |
+				VM_DONTDUMP;
+	sunxi_update_vm_attr(sunxi_buf, vma);
+
+	return ret;
+}
+
+int sunxi_drm_gem_dumb_map_offset(struct drm_file *file_priv,
+					struct drm_device *dev, uint32_t handle,
+					uint64_t *offset)
+{
+	struct drm_gem_object *obj;
+	int ret = 0;
+
+	DRM_DEBUG_DRIVER("[%d]\n", __LINE__);
+
+	mutex_lock(&dev->struct_mutex);//protect drm_gem_create_mmap_offset
+
+	/*
+	* get offset of memory allocated for drm framebuffer.
+	* - this callback would be called by user application
+	*	with DRM_IOCTL_MODE_MAP_DUMB command.
+	*/
+
+	obj = drm_gem_object_lookup(dev, file_priv, handle);
+	if (!obj) {
+		DRM_ERROR("failed to lookup gem object.\n");
+		ret = -EINVAL;
+		goto unlock;
+	}
+
+	if (!obj->map_list.map) {
+		ret = drm_gem_create_mmap_offset(obj);
+		if (ret)
+		goto out;
+	}
+
+	*offset = (u64)obj->map_list.hash.key << PAGE_SHIFT;
+	DRM_DEBUG_DRIVER("offset = 0x%lx\n", (unsigned long)*offset);
+
+out:
+	drm_gem_object_unreference(obj);
+unlock:
+	mutex_unlock(&dev->struct_mutex);
+	return ret;
+}
+
+int sunxi_drm_gem_init_object(struct drm_gem_object *obj)
+{
+	/*TODO maybe*/
+	return 0;
+}
+
+void sunxi_drm_gem_free_object(struct drm_gem_object *obj)
+{
+	sunxi_drm_gem_destroy(obj);
+}
+
+int sunxi_drm_gem_sync_ioctl(struct drm_device *dev, void *data,
+				struct drm_file *file_priv)
+{
+	int ret = 0;
+	struct sunxi_sync_gem_cmd *gem_cmd;
+	struct drm_gem_object *obj;
+	struct sunxi_drm_gem_buf *buf;
+
+	gem_cmd = (struct sunxi_sync_gem_cmd *)data;
+	obj = drm_gem_object_lookup(dev, file_priv, gem_cmd->gem_handle);
+	if (!obj) {
+		DRM_ERROR("failed to lookup gem object.\n");
+		return -EINVAL;
+	}
+	buf = (struct sunxi_drm_gem_buf *)obj->driver_private;
+	if (!buf) {
+		DRM_ERROR("failed to lookup sunxi_drm_gem_buf.\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	sunxi_sync_buf(buf);
+out:
+	drm_gem_object_unreference(obj);
+
+	return ret;
+}
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_gem.h b/drivers/gpu/drm/sunxi/sunxi_drm_gem.h
new file mode 100755
index 0000000..273f66e
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_gem.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifndef _SUNXI_DRM_GEM_H_
+#define _SUNXI_DRM_GEM_H_
+
+#include <drm/drmP.h>
+#include <drm/sunxi_drm.h>
+
+
+struct sunxi_drm_gem_buf {
+	struct drm_gem_object *obj;
+	void __iomem *kvaddr;
+	dma_addr_t dma_addr;
+	struct dma_attrs dma_attrs;
+	struct sg_table *sgt;
+	unsigned long size;
+	unsigned int flags;
+};
+
+int sunxi_drm_gem_dumb_map_offset(struct drm_file *file_priv,
+				struct drm_device *dev, uint32_t handle,
+				uint64_t *offset);
+
+int sunxi_drm_gem_mmap(struct file *filp, struct vm_area_struct *vma);
+
+int sunxi_drm_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf);
+
+int sunxi_drm_gem_dumb_destroy(struct drm_file *file_priv,
+				struct drm_device *dev, unsigned int handle);
+
+int sunxi_drm_gem_dumb_create(struct drm_file *file_priv,
+				struct drm_device *dev, struct drm_mode_create_dumb *args);
+
+struct drm_gem_object *sunxi_drm_gem_creat(struct drm_device *dev,
+				struct drm_mode_create_dumb *args);
+
+void sunxi_drm_gem_destroy(struct drm_gem_object *gem_obj);
+
+static inline int sunxi_check_gem_memory_type(struct drm_gem_object *sunxi_gem_obj,
+	enum sunxi_drm_gem_buf_type need)
+{
+	struct sunxi_drm_gem_buf *buf = (struct sunxi_drm_gem_buf *)sunxi_gem_obj->driver_private;
+	return buf->flags & need;
+}
+void sunxi_sync_buf(struct sunxi_drm_gem_buf *buf);
+
+void sunxi_drm_gem_free_object(struct drm_gem_object *obj);
+
+int sunxi_drm_gem_init_object(struct drm_gem_object *obj);
+
+int sunxi_drm_gem_sync_ioctl(struct drm_device *dev, void *data,
+				struct drm_file *file_priv);
+
+#endif
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_panel.c b/drivers/gpu/drm/sunxi/sunxi_drm_panel.c
new file mode 100755
index 0000000..625ea23
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_panel.c
@@ -0,0 +1,57 @@
+ /*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+ 
+/* panel  for the lcd and hdmi panel*/
+#include <drm/drmP.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_fb_helper.h>
+
+#include "sunxi_drm_panel.h"
+#include "subdev/sunxi_lcd.h"
+#include "subdev/sunxi_hdmi.h"
+#include "sunxi_drm_connector.h"
+
+struct sunxi_panel *sunxi_panel_creat(enum disp_output_type type, int pan_id)
+{
+	struct sunxi_panel *sunxi_panel;
+	sunxi_panel = kzalloc(sizeof(struct sunxi_panel), GFP_KERNEL);
+	if (!sunxi_panel) {
+		DRM_ERROR("failed to allocate sunxi_panel.\n");
+		goto out;
+	}
+	sunxi_panel->panel_id = pan_id;
+	sunxi_panel->type = type;
+out:
+	return sunxi_panel;
+}
+
+void sunxi_panel_destroy(struct sunxi_panel *panel)
+{
+	struct sunxi_drm_connector *sunxi_connector; 
+	sunxi_connector = to_sunxi_connector(panel->drm_connector);
+	switch (panel->type){
+	case DISP_OUTPUT_TYPE_LCD:
+		sunxi_lcd_destroy(panel, sunxi_connector->hw_res);
+		break;
+	case DISP_OUTPUT_TYPE_TV:
+		break;
+	case DISP_OUTPUT_TYPE_HDMI:
+		sunxi_hdmi_pan_destroy(panel, sunxi_connector->hw_res);
+		break;
+	case DISP_OUTPUT_TYPE_VGA:
+		break;
+	default:
+		DRM_ERROR("give us a err type sunxi_panel.\n");
+	}
+	kfree(panel);
+}
+
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_panel.h b/drivers/gpu/drm/sunxi/sunxi_drm_panel.h
new file mode 100755
index 0000000..f5b9589
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_panel.h
@@ -0,0 +1,58 @@
+ /*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+/*panel --> display panel(hdmi)*/
+
+#ifndef _SUNXI_DRM_PANEL_H_
+#define _SUNXI_DRM_PANEL_H_
+
+#include "de/disp_lcd.h"
+
+struct sunxi_panel;
+
+struct panel_ops {
+	bool (*init)(struct sunxi_panel *panel);
+	bool (*open)(struct sunxi_panel *panel);
+	bool (*close)(struct sunxi_panel *panel);
+	bool (*reset)(struct sunxi_panel *panel);
+	bool (*bright_light)(struct sunxi_panel *panel, unsigned int bright);
+	enum drm_connector_status (*detect)(struct sunxi_panel *panel);
+	enum drm_mode_status (*check_valid_mode)(struct sunxi_panel *panel, struct drm_display_mode *mode);
+	enum drm_mode_status (*change_mode_to_timming)(void *timing, struct drm_display_mode *mode);
+	unsigned int (*get_modes)(struct sunxi_panel *panel);
+};
+
+struct pwm_info_t{
+	struct pwm_device *pwm_dev;
+	u32 channel;
+	u32 polarity;
+	u32 period_ns;
+	u32 duty_ns;
+	bool enabled;
+};
+
+struct sunxi_panel {
+	struct drm_connector *drm_connector;
+	enum disp_output_type type;
+	char *name;
+	int panel_id;
+	uint32_t dpms;
+	struct panel_ops *panel_ops;
+	struct clk *clk;
+	unsigned long clk_rate;
+	void *private;
+};
+
+struct sunxi_panel *sunxi_panel_creat(enum disp_output_type type, int pan_id);
+
+void sunxi_panel_destroy(struct sunxi_panel *panel);
+
+#endif
+
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_plane.c b/drivers/gpu/drm/sunxi/sunxi_drm_plane.c
new file mode 100755
index 0000000..2740791
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_plane.c
@@ -0,0 +1,953 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui 
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+/*plane --> Layer*/
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
+#include "sunxi_drm_plane.h"
+#include <video/sunxi_display2.h>
+#include <drm/sunxi_drm.h>
+#include <asm-generic/dma-mapping-common.h>
+
+
+#include "sunxi_drm_drv.h"
+#include "sunxi_drm_core.h"
+#include "sunxi_drm_crtc.h"
+#include "sunxi_drm_encoder.h"
+#include "sunxi_drm_connector.h"
+#include "sunxi_drm_plane.h"
+#include "drm_de/drm_al.h"
+
+#include "subdev/sunxi_common.h"
+#include "sunxi_drm_gem.h"
+#include "sunxi_drm_plane.h"
+#include "sunxi_drm_fb.h"
+
+struct pixel_info_t {
+	enum disp_pixel_format format;
+	unsigned char plane;
+	unsigned char plane_bpp[3];
+	unsigned char wscale[3];
+	unsigned char hscale[3];
+	bool    swap_uv;
+};
+
+static const uint32_t ui_formats[] = {
+	DRM_FORMAT_RGB888,
+	DRM_FORMAT_BGR888,
+
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_ABGR8888,
+	DRM_FORMAT_RGBA8888,
+	DRM_FORMAT_BGRA8888,
+
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_XBGR8888,
+	DRM_FORMAT_RGBX8888,
+	DRM_FORMAT_BGRX8888,
+
+	DRM_FORMAT_RGB565,
+	DRM_FORMAT_BGR565,
+
+	DRM_FORMAT_ARGB4444,
+	DRM_FORMAT_ABGR4444,
+	DRM_FORMAT_RGBA4444,
+	DRM_FORMAT_BGRA4444,
+
+	DRM_FORMAT_ARGB1555,
+	DRM_FORMAT_ABGR1555,
+	DRM_FORMAT_RGBA5551,
+	DRM_FORMAT_BGRA5551,
+};
+
+static const uint32_t vi_formats[] = {
+	DRM_FORMAT_RGB888,
+	DRM_FORMAT_BGR888,
+
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_ABGR8888,
+	DRM_FORMAT_RGBA8888,
+	DRM_FORMAT_BGRA8888,
+
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_XBGR8888,
+	DRM_FORMAT_RGBX8888,
+	DRM_FORMAT_BGRX8888,
+
+	DRM_FORMAT_RGB565,
+	DRM_FORMAT_BGR565,
+
+	DRM_FORMAT_ARGB4444,
+	DRM_FORMAT_ABGR4444,
+	DRM_FORMAT_RGBA4444,
+	DRM_FORMAT_BGRA4444,
+
+	DRM_FORMAT_ARGB1555,
+	DRM_FORMAT_ABGR1555,
+	DRM_FORMAT_RGBA5551,
+	DRM_FORMAT_BGRA5551,
+
+	DRM_FORMAT_AYUV,
+	DRM_FORMAT_YUV444,
+	DRM_FORMAT_YUV422,
+	DRM_FORMAT_YUV420,
+	DRM_FORMAT_YUV411,
+
+	DRM_FORMAT_NV61,
+	DRM_FORMAT_NV16,
+	DRM_FORMAT_NV21,
+	DRM_FORMAT_NV12,
+
+};
+
+uint32_t disp_to_drm_format(enum disp_pixel_format format)
+{
+	switch (format) {
+	case DISP_FORMAT_ARGB_8888:
+		return DRM_FORMAT_ARGB8888;
+
+	case DISP_FORMAT_ABGR_8888:
+		return DRM_FORMAT_ABGR8888;
+
+	case DISP_FORMAT_RGBA_8888:
+		return DRM_FORMAT_RGBA8888;
+
+	case DISP_FORMAT_BGRA_8888:
+		return DRM_FORMAT_BGRA8888;
+
+	case DISP_FORMAT_XRGB_8888:
+		return DRM_FORMAT_XRGB8888;
+
+	case DISP_FORMAT_XBGR_8888:
+		return DRM_FORMAT_XBGR8888;
+
+	case DISP_FORMAT_RGBX_8888:
+		return DRM_FORMAT_RGBX8888;
+
+	case DISP_FORMAT_BGRX_8888:
+		return DRM_FORMAT_BGRX8888;
+
+	case DISP_FORMAT_RGB_888:
+		return DRM_FORMAT_RGB888;
+
+	case DISP_FORMAT_BGR_888:
+		return DRM_FORMAT_BGR888;
+
+	case DISP_FORMAT_RGB_565:
+		return DRM_FORMAT_RGB565;
+
+	case DISP_FORMAT_BGR_565:
+		return DRM_FORMAT_BGR565;
+
+	case DISP_FORMAT_ARGB_4444:
+		return DRM_FORMAT_ARGB4444;
+
+	case DISP_FORMAT_ABGR_4444:
+		return DRM_FORMAT_ABGR4444;
+
+	case DISP_FORMAT_RGBA_4444:
+		return DRM_FORMAT_RGBA4444;
+
+	case DISP_FORMAT_BGRA_4444:
+		return DRM_FORMAT_BGRA4444;
+
+	case DISP_FORMAT_ARGB_1555:
+		return DRM_FORMAT_ARGB1555;
+
+	case DISP_FORMAT_ABGR_1555:
+		return DRM_FORMAT_ABGR1555;
+
+	case DISP_FORMAT_RGBA_5551:
+		return DRM_FORMAT_RGBA5551;
+
+	case DISP_FORMAT_BGRA_5551:
+		return DRM_FORMAT_BGRA5551;
+
+	/* SP: semi-planar, P:planar, I:interleaved
+	* UVUV: U in the LSBs;     VUVU: V in the LSBs */
+
+	case DISP_FORMAT_YUV444_I_AYUV:
+		return DRM_FORMAT_AYUV;
+
+	case DISP_FORMAT_YUV444_I_VUYA:
+		return 0;
+
+	case DISP_FORMAT_YUV422_I_YVYU:
+		return 0;
+
+	case DISP_FORMAT_YUV422_I_YUYV:
+		return 0;
+
+	case DISP_FORMAT_YUV422_I_UYVY:
+		return 0;
+
+	case DISP_FORMAT_YUV422_I_VYUY:
+		return 0;
+
+	case DISP_FORMAT_YUV444_P:
+		return DRM_FORMAT_YUV444;
+
+	case DISP_FORMAT_YUV422_P:
+		return DRM_FORMAT_YUV422;
+
+	case DISP_FORMAT_YUV420_P:
+		return DRM_FORMAT_YUV420;
+
+	case DISP_FORMAT_YUV411_P:
+		return DRM_FORMAT_YUV411;
+
+	case DISP_FORMAT_YUV422_SP_UVUV:
+		return DRM_FORMAT_NV61;
+
+	case DISP_FORMAT_YUV422_SP_VUVU:
+		return DRM_FORMAT_NV16;
+
+	case DISP_FORMAT_YUV420_SP_UVUV:
+		return DRM_FORMAT_NV21;
+
+	case DISP_FORMAT_YUV420_SP_VUVU:
+		return DRM_FORMAT_NV12;
+
+	case DISP_FORMAT_YUV411_SP_UVUV:
+		return 0;
+
+	case DISP_FORMAT_YUV411_SP_VUVU:
+		return 0;
+
+	default:
+		DRM_ERROR("get a err display format.\n");
+	}
+	return 0;
+}
+
+bool drm_to_disp_format(struct pixel_info_t *pixel_info, uint32_t format)
+{
+	pixel_info->plane = 1;
+	pixel_info->wscale[0] = 1;
+	pixel_info->hscale[0] = 1;
+	pixel_info->plane_bpp[0] = 32;
+	pixel_info->swap_uv = 0;
+	/*  */
+	switch (format) {
+	case DRM_FORMAT_ARGB8888:
+		pixel_info->format = DISP_FORMAT_ARGB_8888;
+		return true;
+
+	case DRM_FORMAT_ABGR8888:
+		pixel_info->format = DISP_FORMAT_ABGR_8888;
+		return true;
+
+	case DRM_FORMAT_RGBA8888:
+		pixel_info->format = DISP_FORMAT_RGBA_8888;
+		return true;
+
+	case DRM_FORMAT_BGRA8888:
+		pixel_info->format = DISP_FORMAT_BGRA_8888;
+		return true;
+
+	case DRM_FORMAT_XRGB8888:
+		pixel_info->format = DISP_FORMAT_XRGB_8888;
+		return true;
+
+	case DRM_FORMAT_XBGR8888:
+		pixel_info->format = DISP_FORMAT_XBGR_8888;
+		return true;
+
+	case DRM_FORMAT_RGBX8888:
+		pixel_info->format = DISP_FORMAT_RGBX_8888;
+		return true;
+
+	case DRM_FORMAT_BGRX8888:
+		pixel_info->format = DISP_FORMAT_BGRX_8888;
+		return true;
+
+	case DRM_FORMAT_RGB888:
+		pixel_info->format = DISP_FORMAT_RGB_888;
+		pixel_info->plane_bpp[0] = 24;
+		return true;
+
+	case DISP_FORMAT_BGR_888:
+		pixel_info->format = DRM_FORMAT_BGR888;
+		pixel_info->plane_bpp[0] = 24;
+		return true;
+
+	case DRM_FORMAT_RGB565:
+		pixel_info->format = DISP_FORMAT_RGB_565;
+		pixel_info->plane_bpp[0] = 16;
+		return true;
+
+	case DRM_FORMAT_BGR565:
+		pixel_info->format = DISP_FORMAT_BGR_565;
+		pixel_info->plane_bpp[0] = 16;
+		return true;
+
+	case DRM_FORMAT_ARGB4444:
+		pixel_info->format = DISP_FORMAT_ARGB_4444;
+		return true;
+
+	case DRM_FORMAT_ABGR4444:
+		pixel_info->format = DISP_FORMAT_ABGR_4444;
+		pixel_info->plane_bpp[0] = 16;
+		return true;
+
+	case DRM_FORMAT_RGBA4444:
+		pixel_info->format = DISP_FORMAT_RGBA_4444;
+		pixel_info->plane_bpp[0] = 16;
+		return true;
+
+	case DRM_FORMAT_BGRA4444:
+		pixel_info->format = DISP_FORMAT_BGRA_4444;
+		pixel_info->plane_bpp[0] = 16;
+		return true;
+
+	case DRM_FORMAT_ARGB1555:
+		pixel_info->format = DISP_FORMAT_ARGB_1555;
+		pixel_info->plane_bpp[0] = 16;
+		return true;
+
+	case DRM_FORMAT_ABGR1555:
+		pixel_info->format = DISP_FORMAT_ABGR_1555;
+		pixel_info->plane_bpp[0] = 16;
+		return true;
+
+	case DRM_FORMAT_RGBA5551:
+		pixel_info->format = DISP_FORMAT_RGBA_5551;
+		pixel_info->plane_bpp[0] = 16;
+		return true;
+
+	case DRM_FORMAT_BGRA5551:
+		pixel_info->format = DISP_FORMAT_BGRA_5551;
+		pixel_info->plane_bpp[0] = 16;
+		return true;
+
+	/* SP: semi-planar, P:planar, I:interleaved
+	* UVUV: U in the LSBs;     VUVU: V in the LSBs */
+
+	case DRM_FORMAT_AYUV:
+		pixel_info->format = DISP_FORMAT_YUV444_I_AYUV;
+		pixel_info->plane_bpp[0] = 32;
+		return true;
+
+	case DRM_FORMAT_YUV444:
+		pixel_info->format = DISP_FORMAT_YUV444_P;
+		pixel_info->plane = 3;
+		pixel_info->wscale[1] = 1;
+		pixel_info->hscale[1] = 1;
+		pixel_info->wscale[2] = 1;
+		pixel_info->hscale[2] = 1;
+		pixel_info->plane_bpp[0] = 8;
+		pixel_info->plane_bpp[1] = 8;
+		pixel_info->plane_bpp[2] = 8;
+		return true;
+
+	case DRM_FORMAT_YUV422:
+		pixel_info->format = DISP_FORMAT_YUV422_P;
+		pixel_info->plane = 3;
+		pixel_info->wscale[1] = 2;
+		pixel_info->hscale[1] = 1;
+		pixel_info->wscale[2] = 2;
+		pixel_info->hscale[2] = 1;
+		pixel_info->plane_bpp[0] = 8;
+		pixel_info->plane_bpp[1] = 8;
+		pixel_info->plane_bpp[2] = 8;
+		return true;
+
+	case DRM_FORMAT_YUV420:
+		pixel_info->format = DISP_FORMAT_YUV420_P;
+		pixel_info->plane = 3;
+		pixel_info->wscale[1] = 2;
+		pixel_info->hscale[1] = 2;
+		pixel_info->wscale[2] = 2;
+		pixel_info->hscale[2] = 2;
+		pixel_info->plane_bpp[0] = 8;
+		pixel_info->plane_bpp[1] = 8;
+		pixel_info->plane_bpp[2] = 8;
+		return true;
+
+	case DRM_FORMAT_YUV411:
+		pixel_info->format = DISP_FORMAT_YUV411_P;
+		pixel_info->plane = 3;
+		pixel_info->wscale[1] = 4;
+		pixel_info->hscale[1] = 1;
+		pixel_info->wscale[2] = 4;
+		pixel_info->hscale[2] = 1;
+		pixel_info->plane_bpp[0] = 8;
+		pixel_info->plane_bpp[1] = 8;
+		pixel_info->plane_bpp[2] = 8;
+		return true;
+
+	case DRM_FORMAT_NV61:
+		pixel_info->format = DISP_FORMAT_YUV422_SP_UVUV;
+		pixel_info->plane = 2;
+		pixel_info->wscale[1] = 2;
+		pixel_info->hscale[1] = 1;
+		pixel_info->plane_bpp[0] = 8;
+		pixel_info->plane_bpp[1] = 16;
+		return true;
+
+	case DRM_FORMAT_NV16:
+		pixel_info->format = DISP_FORMAT_YUV422_SP_VUVU;
+		pixel_info->plane = 2;
+		pixel_info->wscale[1] = 2;
+		pixel_info->hscale[1] = 1;
+		pixel_info->plane_bpp[0] = 8;
+		pixel_info->plane_bpp[1] = 16;
+		return true;
+
+	case DRM_FORMAT_NV21:
+		pixel_info->format = DISP_FORMAT_YUV420_SP_UVUV;
+		pixel_info->plane = 2;
+		pixel_info->wscale[1] = 2;
+		pixel_info->hscale[1] = 2;
+		pixel_info->plane_bpp[0] = 8;
+		pixel_info->plane_bpp[1] = 16;
+		return true;
+
+	case DRM_FORMAT_NV12:
+		pixel_info->format = DISP_FORMAT_YUV420_SP_VUVU;
+		pixel_info->plane = 2;
+		pixel_info->wscale[1] = 2;
+		pixel_info->hscale[1] = 2;
+		pixel_info->plane_bpp[0] = 8;
+		pixel_info->plane_bpp[1] = 16;
+		return true;
+
+	default:
+		DRM_ERROR("get a err drm format.\n");
+	}
+	return false;
+}
+
+static struct drm_plane *sunxi_find_fb_plane(struct drm_crtc *crtc)
+{
+	struct sunxi_drm_crtc  *sunxi_crtc = to_sunxi_crtc(crtc);
+	struct drm_plane *plane = NULL;
+	struct sunxi_drm_plane *ui_plane, *fb_plane;
+	int video_chn, i;
+
+	video_chn = sunxi_drm_get_vi_pipe_by_crtc(sunxi_crtc->crtc_id);
+	for (i = 0; i < sunxi_crtc->plane_of_de; i++) {
+		plane = sunxi_crtc->plane_array[i];
+		ui_plane = to_sunxi_plane(plane);
+		if(ui_plane->chn_id > (video_chn - 1)) {
+			break;
+		}
+		ui_plane = NULL;
+	}
+
+	if (crtc->fb) {
+		switch (crtc->fb->pixel_format) {
+		case DRM_FORMAT_RGB888:
+		case DRM_FORMAT_BGR888:
+		case DRM_FORMAT_ARGB8888:
+		case DRM_FORMAT_ABGR8888:
+		case DRM_FORMAT_RGBA8888:
+		case DRM_FORMAT_BGRA8888:
+		case DRM_FORMAT_XRGB8888:
+		case DRM_FORMAT_XBGR8888:
+		case DRM_FORMAT_RGBX8888:
+		case DRM_FORMAT_BGRX8888:
+		case DRM_FORMAT_RGB565:
+		case DRM_FORMAT_BGR565:
+		case DRM_FORMAT_ARGB4444:
+		case DRM_FORMAT_ABGR4444:
+		case DRM_FORMAT_RGBA4444:
+		case DRM_FORMAT_BGRA4444:
+		case DRM_FORMAT_ARGB1555:
+		case DRM_FORMAT_ABGR1555:
+		case DRM_FORMAT_RGBA5551:
+		case DRM_FORMAT_BGRA5551:
+			if(sunxi_crtc->fb_plane) {
+				fb_plane = to_sunxi_plane(sunxi_crtc->fb_plane);
+				if(fb_plane->chn_id >= video_chn) {
+					return sunxi_crtc->fb_plane;
+				}
+			}
+			if(ui_plane)
+				return &ui_plane->drm_plane;
+			break;
+
+		case DRM_FORMAT_AYUV:
+		case DRM_FORMAT_YUV444:
+		case DRM_FORMAT_YUV422:
+		case DRM_FORMAT_YUV420:
+		case DRM_FORMAT_YUV411:
+
+		case DRM_FORMAT_NV61:
+		case DRM_FORMAT_NV16:
+		case DRM_FORMAT_NV21:
+		case DRM_FORMAT_NV12:
+			if(video_chn != 0)
+				return sunxi_crtc->plane_array[0];
+			break;
+		default:
+			DRM_ERROR("get fb_plane got a error fb format.\n");
+		}
+	}else {
+		if (sunxi_crtc->fb_plane) {
+			return sunxi_crtc->fb_plane;
+		}
+		if (ui_plane) {
+			return &ui_plane->drm_plane;
+		}
+		DRM_ERROR("must init err,there is not ui_plane.\n");
+	}
+	DRM_ERROR("must  err,there is not fb_plane return.\n");
+	return NULL;
+}
+
+/*
+ * sunxi_update_plane()
+ * Only  update the args to the register,
+ * but no use it for the next frame(vsync).
+ * so you must call sunxi_plane_commit() to 
+ * validate the register.
+ */
+static int sunxi_plane_mode_set(struct disp_layer_config_data *cfg, struct drm_crtc *crtc,
+		struct drm_framebuffer *fb, int crtc_x, int crtc_y,
+		unsigned int crtc_w, unsigned int crtc_h,
+		uint32_t src_x, uint32_t src_y,
+		uint32_t src_w, uint32_t src_h)
+{
+	int  i, j;
+	bool buf_packed = 0;
+	struct sunxi_drm_framebuffer *sunxi_fb = to_sunxi_fb(fb);
+	struct sunxi_drm_gem_buf *buffer;
+	struct drm_gem_object *gem_obj;
+	struct pixel_info_t pixel_info;
+	struct disp_layer_config *config = &cfg->config;
+
+	if (!drm_to_disp_format(&pixel_info, fb->pixel_format)) {
+		DRM_ERROR("got a bad pixel format.\n");
+		return -EINVAL;
+	}
+
+	if (sunxi_fb->nr_gem > pixel_info.plane ||
+		sunxi_fb->nr_gem > 3) {
+		DRM_ERROR("have too manny gem for plane.\n");
+		return -EINVAL;
+	}
+
+	if (pixel_info.plane > sunxi_fb->nr_gem) {
+		buf_packed = 1;
+	}
+
+	for (i = 0, j = 0; i < MAX_FB_BUFFER; i++) {
+		gem_obj = sunxi_fb->gem_obj[i];
+		if (gem_obj) {
+			buffer = (struct sunxi_drm_gem_buf *)gem_obj->driver_private;
+			if (!buffer)
+				continue;
+			if (buffer->flags & SUNXI_BO_CACHABLE) {
+				/* SUNXI_BO_CACHABLE must dma_sync_sg_for_device , becareful*/
+				DRM_DEBUG_KMS("plane set dma_addr(0x%lx)(%lx), size(%lu)\n",
+						(unsigned long)buffer->dma_addr, (unsigned long)buffer->kvaddr,
+						buffer->size);
+
+				sunxi_sync_buf(buffer);
+			}
+
+			if (!(buffer->flags & SUNXI_BO_CONTIG)) {
+				memset(config, 0, sizeof(*config));
+				cfg->flag |= BLEND_ENABLE_DIRTY;
+				DRM_ERROR("no_contig mem.\n");
+				return -EINVAL;
+			}
+			/* mem offset */
+			config->info.fb.addr[j++] = buffer->dma_addr + fb->offsets[i];
+		}
+	}
+
+	config->info.fb.format = pixel_info.format;
+	config->enable = 1;
+	config->info.screen_win.x = crtc_x;
+	config->info.screen_win.y = crtc_y;
+	config->info.screen_win.width = crtc_w;
+	config->info.screen_win.height = crtc_h;
+	/* 3D mode set in property */
+	config->info.alpha_mode = 1;
+	config->info.alpha_value = 0xff;
+	/* screen crop set */
+	config->info.fb.crop.x = ((long long)src_x)<<32;
+	config->info.fb.crop.y = ((long long)src_y)<<32;
+	config->info.fb.crop.height = ((long long)src_h)<<32;
+	config->info.fb.crop.width = ((long long)src_w)<<32;
+	/* set in property  TODO*/
+	config->info.fb.pre_multiply = 0;
+	/* fb stride/bpp , is pixel */
+	if (buf_packed) {
+		config->info.fb.size[0].width = fb->pitches[0] /
+						(fb->bits_per_pixel>>3) /
+						pixel_info.wscale[0];
+	}else {
+		config->info.fb.size[0].width = fb->pitches[0] /
+						(pixel_info.plane_bpp[0]>>3) /
+						pixel_info.wscale[0];
+	}
+
+	config->info.fb.size[0].height = fb->height / pixel_info.hscale[0];
+
+	config->info.fb.align[0] = 0;
+
+	for (i = 1; i < pixel_info.plane; i++) {
+		/* set align will in  property for GPU / g2d / video,
+		* all use the plane , currently set it use fb.pitches, 
+		* we control it by fb.pitch which user set, so  set it 0.
+		*/
+		config->info.fb.align[i] = 0;
+		config->info.fb.size[i].width =
+		config->info.fb.size[0].width / pixel_info.wscale[i];
+		config->info.fb.size[i].height =
+		config->info.fb.size[0].height / pixel_info.hscale[i];
+
+		if (buf_packed) {
+			config->info.fb.addr[i] =
+			config->info.fb.size[i-1].width * config->info.fb.size[i-1].height;
+		}
+	}
+
+	if (pixel_info.swap_uv) {
+		unsigned long long  swap_addr;
+		swap_addr = config->info.fb.addr[1];
+		config->info.fb.addr[1] = config->info.fb.addr[2];
+		config->info.fb.addr[2] = swap_addr;
+	}
+	DRM_DEBUG_KMS("plane cfg:"
+			"crt_id:%d\nchn[%d] lyr[%d] z[%d] from[%lld, %lld, %lld, %lld]"
+			" to [%d, %d, %d, %d] pitch[%d,%d] addr:0x%llx (%d)\n",
+	crtc->base.id,
+	config->channel,
+	config->layer_id,
+	config->info.zorder,
+	config->info.fb.crop.x>>32,
+	config->info.fb.crop.y>>32,
+	config->info.fb.crop.width>>32,
+	config->info.fb.crop.height>>32,
+	config->info.screen_win.x,
+	config->info.screen_win.y,
+	config->info.screen_win.width,
+	config->info.screen_win.height,
+	config->info.fb.size[0].width,
+	config->info.fb.size[0].height,
+	config->info.fb.addr[0],
+	config->info.fb.format);
+	cfg->flag |= LAYER_ALL_DIRTY;
+
+	return 0;
+}
+
+int sunxi_update_plane(struct drm_plane *plane, struct drm_crtc *crtc,
+		     struct drm_framebuffer *fb, int crtc_x, int crtc_y,
+		     unsigned int crtc_w, unsigned int crtc_h,
+		     uint32_t src_x, uint32_t src_y,
+		     uint32_t src_w, uint32_t src_h)
+{
+	struct sunxi_drm_plane *sunxi_plane = to_sunxi_plane(plane);
+	struct disp_layer_config_data *cfg;
+	struct sunxi_hardware_ops *plane_ops = sunxi_plane->hw_res->ops;
+	int ret = 0;
+
+	DRM_DEBUG_KMS("[%d]crtc_id:%d\n", __LINE__,crtc->base.id);
+
+	cfg = sunxi_plane->plane_cfg;
+	/* TODO for 3D */
+	ret = sunxi_plane_mode_set(cfg, crtc, fb, crtc_x, crtc_y,
+				crtc_w, crtc_h, src_x >> 16, src_y >> 16,
+				src_w >> 16, src_h >> 16);
+	if (ret) {
+		DRM_ERROR("updata_plane err.\n");
+		return -EINVAL; 
+	}
+	/* protect the current layer to vsync period */
+	mutex_lock(&sunxi_plane->delayed_work_lock);
+	if (sunxi_plane->old_fb) {
+		/* for many update */
+		drm_framebuffer_unreference(sunxi_plane->old_fb);
+	}
+	sunxi_plane->old_fb = plane->fb;
+	mutex_unlock(&sunxi_plane->delayed_work_lock);
+
+	drm_framebuffer_reference(fb);
+
+	cfg = sunxi_plane->plane_cfg;
+	cfg->config.enable = 1;
+	cfg->flag |= LAYER_ALL_DIRTY;
+	if (plane_ops->updata_reg != NULL) {
+		if (!plane_ops->updata_reg(cfg)) {
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+void sunxi_plane_dpms(struct drm_plane *plane, int status)
+{
+	struct sunxi_drm_plane *sunxi_plane = to_sunxi_plane(plane);
+	struct disp_layer_config_data *cfg;
+	struct sunxi_hardware_ops *plane_ops = sunxi_plane->hw_res->ops;
+	bool changed = 0;
+
+	cfg = sunxi_plane->plane_cfg;
+	DRM_DEBUG_KMS("[%d] status[%d]\n", __LINE__, status);
+
+	switch(status){
+		case  DRM_MODE_DPMS_ON:
+			if (cfg->config.enable == 0) {
+				cfg->config.enable = 1;
+				cfg->flag = BLEND_ENABLE_DIRTY;
+			}
+			break;
+		case  DRM_MODE_DPMS_STANDBY:
+		case  DRM_MODE_DPMS_SUSPEND:
+		case  DRM_MODE_DPMS_OFF:
+			if (cfg->config.enable == 1) {
+				cfg->config.enable = 0;
+				cfg->flag = BLEND_ENABLE_DIRTY;
+				changed = 1;
+			}
+			if (changed && plane_ops->disable != NULL) {
+				plane_ops->disable(cfg);
+			}
+			break;
+		default:
+		DRM_ERROR("sunxi_plane_dpms error arg.\n");
+	}
+}
+
+static int sunxi_disable_plane(struct drm_plane *plane)
+{
+	DRM_DEBUG_KMS("[%d]\n", __LINE__);
+
+	sunxi_plane_dpms(plane, DRM_MODE_DPMS_OFF);
+	return 0;
+}
+
+static void sunxi_plane_destroy(struct drm_plane *plane)
+{
+	struct sunxi_drm_plane *sunxi_plane = to_sunxi_plane(plane);
+
+	DRM_DEBUG_KMS("[%d]\n", __LINE__);
+
+	sunxi_disable_plane(plane);
+	drm_plane_cleanup(plane);
+	kfree(sunxi_plane);
+}
+
+static int sunxi_plane_set_property(struct drm_plane *plane,
+				     struct drm_property *property,
+				     uint64_t val)
+{
+	struct sunxi_drm_plane *sunxi_plane = to_sunxi_plane(plane);
+	struct sunxi_drm_crtc  *sunxi_crtc = NULL;
+
+	DRM_DEBUG_KMS("[%d]\n", __LINE__);
+
+	sunxi_crtc = get_sunxi_crt(plane->dev, sunxi_plane->crtc_id);
+	if(!sunxi_crtc) {
+		DRM_ERROR("failed to get the sunxi_crtc.\n");
+		goto err;
+	}
+
+	if (property == sunxi_crtc->plane_zpos_property) {
+		sunxi_plane->plane_cfg->config.info.zorder = val;
+		return 0;
+	}
+err:
+	return -EINVAL;
+}
+
+static struct drm_plane_funcs sunxi_plane_funcs = {
+	.update_plane	= sunxi_update_plane,
+	.disable_plane	= sunxi_disable_plane,
+	.destroy	= sunxi_plane_destroy,
+	.set_property	= sunxi_plane_set_property,
+};
+
+/* 
+ * if the DE BSP modify the set de_al_lyr_apply()func 1 layer
+ * or 1 channel set mode, will modify the plane_ops
+ * updata_reg and disable functions.  
+ */
+void sunxi_plane_delayed(void *data)
+{
+	struct sunxi_drm_plane *plane = to_sunxi_plane(data);
+	/* protect the current layer to vsync period
+	* can only run one times when n vsync occure.
+	*/
+	mutex_lock(&plane->delayed_work_lock);
+	if (plane->old_fb) {
+		drm_framebuffer_unreference(plane->old_fb);
+		plane->old_fb = NULL;
+	}
+	mutex_unlock(&plane->delayed_work_lock);
+}
+
+bool sunxi_plane_reset(void *data)
+{
+	struct drm_plane *plane = (struct drm_plane *)data;
+	sunxi_plane_dpms(plane, DRM_MODE_DPMS_OFF);
+	return true;
+}
+
+bool sunxi_plane_updata_reg(void *data)
+{
+	struct sunxi_drm_plane *sunxi_plane = to_sunxi_plane(data);
+	struct sunxi_drm_crtc *sunxi_crtc;
+	bool    changed = 0;
+
+	sunxi_crtc = get_sunxi_crt(sunxi_plane->drm_plane.dev,
+			sunxi_plane->crtc_id);
+	if (!sunxi_crtc) {
+		DRM_ERROR("failed get sunxi crt.\n");
+		return false;
+	}
+
+	if (!sunxi_crtc->user_update_frame) {
+		spin_lock(&sunxi_crtc->update_reg_lock);
+		sunxi_crtc->user_update_frame = 1;
+		spin_lock(&sunxi_crtc->update_reg_lock);
+		changed = 1;
+	}
+
+	if (changed) {
+		/* waite for the update reg ready of double buffer */
+		if (sunxi_crtc->ker_update_frame) {
+			sunxi_plane->delayed_updata = 1;
+			sunxi_crtc->has_delayed_updata = 1;
+			return true;
+		}
+	}
+	/* do update the reg */
+
+	return true;
+}
+
+struct sunxi_hardware_ops plane_ops = {
+	.reset          = NULL,
+	.enable         = NULL,
+	.disable        = NULL,
+	.updata_reg     = NULL,
+	.vsync_proc   = NULL,
+	.vsync_delayed_do = sunxi_plane_delayed,
+};
+
+static const struct drm_prop_enum_list layer_mode_names[] = {
+	{ CRTC_MODE_3D,     "normal_mode" },
+	{ CRTC_MODE_ENHANCE, "enhance" },
+	{ CRTC_MODE_ENHANCE_HF, "enhance_half" },
+	{ CRTC_MODE_SMART_LIGHT, "smart_light" },//ToDo
+};
+
+void sunxi_reset_plane(struct drm_crtc *crtc)
+{
+	int i;
+	struct sunxi_drm_crtc  *sunxi_crtc = to_sunxi_crtc(crtc);
+
+	for (i = 0; i < sunxi_crtc->plane_of_de; i++) {
+		sunxi_plane_reset(sunxi_crtc->plane_array[i]);
+	}
+}
+
+struct drm_plane *sunxi_plane_init(struct drm_device *dev,struct drm_crtc *crtc,
+            struct disp_layer_config_data *cfg, int chn, int plane_id, bool priv)
+{
+	struct sunxi_drm_plane  *sunxi_plane;
+	struct drm_plane	    *plane;
+	struct sunxi_drm_crtc   *sunxi_crtc = to_sunxi_crtc(crtc);
+	bool video = 0;
+	int vi_chn;
+
+	int err;
+	DRM_DEBUG_KMS("[%d]\n", __LINE__);
+
+	sunxi_plane = kzalloc(sizeof(struct sunxi_drm_plane), GFP_KERNEL);
+	if (!sunxi_plane) {
+		DRM_ERROR("failed to allocate plane\n");
+		return NULL;
+	}
+
+	vi_chn = sunxi_drm_get_vi_pipe_by_crtc(sunxi_crtc->crtc_id);
+	if (vi_chn > chn)
+		video = 1;
+
+	err = drm_plane_init(dev, &sunxi_plane->drm_plane, 1 << sunxi_crtc->crtc_id,
+				&sunxi_plane_funcs, video ? vi_formats : ui_formats,
+				video ? ARRAY_SIZE(vi_formats) : ARRAY_SIZE(ui_formats),
+				priv);
+	if (err) {
+		DRM_ERROR("failed to initialize plane\n");
+		kfree(sunxi_plane);
+		return NULL;
+	}
+
+	sunxi_plane->hw_res = kzalloc(sizeof(struct sunxi_hardware_res), GFP_KERNEL);
+	if (!sunxi_plane->hw_res) {
+		DRM_ERROR("failed to allocate sunxi_hardware_res\n");
+		kfree(sunxi_plane);
+		return NULL;
+	}
+
+	sunxi_plane->hw_res->ops = &plane_ops;
+	sunxi_plane->chn_id = chn;
+	sunxi_plane->isvideo = video;
+	sunxi_plane->crtc_id = sunxi_crtc->crtc_id;
+	sunxi_plane->plane_cfg = cfg;
+	cfg->config.channel = chn;
+	cfg->config.layer_id = plane_id;
+	mutex_init(&sunxi_plane->delayed_work_lock);
+	plane = &sunxi_plane->drm_plane;
+	if (priv) {
+	/* for the Hardware Cursor if have */
+		sunxi_crtc->harware_cursor = &sunxi_plane->drm_plane;
+	}else{
+		drm_object_attach_property(&plane->base, sunxi_crtc->channel_id_property, chn);
+		drm_object_attach_property(&plane->base, sunxi_crtc->plane_zpos_property, 0);
+		drm_object_attach_property(&plane->base, sunxi_crtc->plane_id_chn_property, plane_id);
+	}
+
+	return &sunxi_plane->drm_plane;
+}
+
+int sunxi_set_fb_plane(struct drm_crtc *crtc, unsigned int plane_id, unsigned int zoder)
+{
+	struct sunxi_drm_plane *sunxi_plane;
+	struct drm_mode_object *obj;
+	struct drm_plane *plane = NULL;
+	struct sunxi_drm_crtc *sunxi_crtc = to_sunxi_crtc(crtc);
+
+	obj = drm_mode_object_find(crtc->dev, plane_id, DRM_MODE_OBJECT_PLANE);
+	if (!obj) {
+		plane = sunxi_find_fb_plane(crtc);
+	}else{
+		plane = obj_to_plane(obj);
+	}
+
+	DRM_DEBUG_KMS("setfb: crtc_id[%d] plane[%d]\n", crtc->base.id, plane->base.id);
+
+	if (plane != NULL) {
+		sunxi_plane = to_sunxi_plane(plane);
+		if (sunxi_plane->crtc_id == sunxi_crtc->crtc_id) {
+			sunxi_crtc->fb_plane = plane;
+			if (sunxi_crtc->plane_of_de > zoder)
+				sunxi_plane->plane_cfg->config.info.zorder = zoder;
+			else
+				/* default FB zorder or 0~sunxi_crtc->plane_of_de-1 */
+				sunxi_plane->plane_cfg->config.info.zorder = 0;
+			return 0;
+		}
+	} else {
+		if (sunxi_plane->crtc_id == sunxi_crtc->crtc_id)
+			sunxi_crtc->fb_plane = NULL;
+		return 0;
+	}
+	return -EINVAL;
+}
diff --git a/drivers/gpu/drm/sunxi/sunxi_drm_plane.h b/drivers/gpu/drm/sunxi/sunxi_drm_plane.h
new file mode 100755
index 0000000..3293b24
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/sunxi_drm_plane.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui 
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+/*plane --> Layer*/
+
+#ifndef _SUNXI_DRM_PLANE_H_
+#define _SUNXI_DRM_PLANE_H_
+
+#include "de/include.h"
+#include "sunxi_drm_gem.h"
+
+struct sunxi_drm_plane {
+	struct drm_plane	drm_plane;
+	struct drm_framebuffer *old_fb;
+	struct mutex delayed_work_lock;
+	int crtc_id;
+	int chn_id;
+	int plane_id;
+	bool isvideo;
+	bool updata_frame;
+	bool delayed_updata;
+	struct disp_layer_config_data *plane_cfg;
+	struct sunxi_hardware_res *hw_res;
+};
+
+#define to_sunxi_plane(x)	container_of(x, struct sunxi_drm_plane, drm_plane)
+
+int sunxi_set_fb_plane(struct drm_crtc *crtc, unsigned int plane_id, unsigned int zoder);
+
+struct drm_plane *sunxi_plane_init(struct drm_device *dev,struct drm_crtc *crtc,
+	struct disp_layer_config_data *cfg, int chn, int plane_id, bool priv);
+
+int sunxi_update_plane(struct drm_plane *plane, struct drm_crtc *crtc,
+		struct drm_framebuffer *fb, int crtc_x, int crtc_y,
+		unsigned int crtc_w, unsigned int crtc_h,
+		uint32_t src_x, uint32_t src_y,
+		uint32_t src_w, uint32_t src_h);
+
+void sunxi_plane_dpms(struct drm_plane *plane, int status);
+
+void sunxi_reset_plane(struct drm_crtc *crtc);
+
+#endif
diff --git a/drivers/video/sunxi/disp2/disp/dev_fb.c b/drivers/video/sunxi/disp2/disp/dev_fb.c
index b0a2921..dd55c86 100644
--- a/drivers/video/sunxi/disp2/disp/dev_fb.c
+++ b/drivers/video/sunxi/disp2/disp/dev_fb.c
@@ -56,7 +56,11 @@ s32 sunxi_get_fb_addr_para(struct __fb_addr_para *fb_addr_para)
 
 	return -1;
 }
-EXPORT_SYMBOL(sunxi_get_fb_addr_para);
+/*
+ * BUG: /kernel/dirvers/gpu/drm/sunxi/ has exprot symbol!
+ * Buddy
+ */
+//EXPORT_SYMBOL(sunxi_get_fb_addr_para);
 
 
 #define sys_put_wvalue(addr, data) writel(data, (void __iomem *)addr)
diff --git a/include/drm/sunxi_drm.h b/include/drm/sunxi_drm.h
new file mode 100644
index 0000000..a52fab7
--- /dev/null
+++ b/include/drm/sunxi_drm.h
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2016 Allwinnertech Co.Ltd
+ * Authors: Jet Cui
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+ /* this is the user layer ioctl and struct */
+#ifndef _SUNXI_DRM_UAPI_H_
+#define _SUNXI_DRM_UAPI_H_
+#include <linux/sunxi_tr.h>
+/*
+enum tr_mode {
+	TR_ROT_0        = 0x0,//rotate clockwise 0 ROTgree
+	TR_ROT_90       = 0x1,//rotate clockwise 90 ROTgree
+	TR_ROT_180      = 0x2,//rotate clockwise 180 ROTgree
+	TR_ROT_270      = 0x3,//rotate clockwise 270 ROTgree
+	TR_HFLIP        = 0x4,//horizontal flip
+	TR_HFLIP_ROT_90 = 0x5,//first rotate clockwise 90 ROTgree then horizontal flip
+	TR_VFLIP        = 0x6,//vertical flip
+	TR_VFLIP_ROT_90 = 0x7,//first rotate clockwise 90 ROTgree then vertical flip
+};
+*/
+enum tr_cmd {
+    TR_CMD_AQUIRE = 1,
+	TR_CMD_COMMIT,
+	TR_CMD_QUERY,
+	TR_CMD_RELEASE,
+};
+
+enum sunxi_drm_gem_buf_type {
+	/* Physically Continuous memory and used as default. */
+	SUNXI_BO_CONTIG	= 1 << 0,
+	/* Physically Non-Continuous memory. */
+	SUNXI_BO_NONCONTIG	= 0 << 0,
+	/* non-cachable mapping. */
+	SUNXI_BO_NONCACHABLE	= 0 << 1,
+	/* cachable mapping. */
+	SUNXI_BO_CACHABLE	= 1 << 1,
+	/* write-combine mapping. */
+	SUNXI_BO_WC		= 1 << 2,
+	SUNXI_BO_MASK		= SUNXI_BO_CONTIG | SUNXI_BO_CACHABLE |
+					SUNXI_BO_WC
+};
+
+struct sunxi_flip_user_date {
+    __u32   plane_id;
+    int     zpos;//cancel
+    unsigned int sync_id;
+    unsigned int crtc_id;
+};
+
+struct sunxi_rotate_info {
+    /* user must promise the gem handle hold for rotate */
+    union{
+        uint32_t src_gem_handle;
+        int     status;  
+    };
+    uint32_t dst_gem_handle;
+    int width;
+    int pitch;
+    int height;
+    int depth;
+    int bpp;
+    unsigned int set_time;
+    tr_mode mode;
+    bool sleep_mode;
+};
+
+struct sunxi_rotate_cmd {
+    int handle;
+    enum tr_cmd cmd;
+    void  *private;
+};
+
+struct sunxi_sync_gem_cmd {
+    uint32_t gem_handle;
+};
+
+struct sunxi_fb_info_cmd {
+    unsigned int crtc_id;
+    unsigned int plane_id;
+    unsigned int zorder;
+    bool set_get;
+};
+
+#define DRM_SUNXI_FLIP_SYNC		0x00
+#define DRM_SUNXI_FENCE_SYNC	0x01
+#define DRM_SUNXI_ROTATE	0x02
+#define DRM_SUNXI_SYNC_GEM	0x03
+#define DRM_SUNXI_INFO_FB_PLANE	0x04
+
+#define DRM_IOCTL_SUNXI_FLIP_SYNC		DRM_IOW(DRM_COMMAND_BASE + \
+		DRM_SUNXI_FLIP_SYNC, struct sunxi_flip_user_date)
+
+#define DRM_IOCTL_SUNXI_FENCE_SYNC		DRM_IO(DRM_COMMAND_BASE + \
+		DRM_SUNXI_FENCE_SYNC)
+
+#define DRM_IOCTL_SUNXI_ROTATE		DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_SUNXI_ROTATE, struct sunxi_rotate_cmd)
+
+#define DRM_IOCTL_SUNXI_SYNC_GEM		DRM_IOW(DRM_COMMAND_BASE + \
+		DRM_SUNXI_SYNC_GEM, struct sunxi_sync_gem_cmd)	
+
+#define DRM_IOCTL_SUNXI_INFO_FB_PLANE		DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_SUNXI_INFO_FB_PLANE, struct sunxi_fb_info_cmd)	
+#endif
+
diff --git a/modules/gpu/Makefile b/modules/gpu/Makefile
index ad1d6fe..6455fc1 100644
--- a/modules/gpu/Makefile
+++ b/modules/gpu/Makefile
@@ -62,6 +62,8 @@ GPU_BUILD_DIR = mali450/kernel_mode/driver/src/devicedrv/mali
 UMP_BUILD_DIR = mali450/kernel_mode/driver/src/devicedrv/ump
 UMPLOCK_BUILD_DIR = mali450/kernel_mode/driver/src/devicedrv/umplock
 GPU_KO_NAME   = $(GPU_BUILD_DIR)/mali.ko
+UMP_KO_NAME   = $(UMP_BUILD_DIR)/ump.ko
+UMPLOCK_KO_NAME   = $(UMPLOCK_BUILD_DIR)/umplock.ko
 else ifeq ($(GPU_TYPE), "sgx544")
 GPU_BUILD_DIR = sgx544/$(WINDOW_SYSTEM_TYPE)/kernel_mode/eurasia_km/eurasiacon/build/linux2/sunxi_android
 GPU_KO_NAME   = sgx544/$(WINDOW_SYSTEM_TYPE)/kernel_mode/eurasia_km/eurasiacon/binary2_sunxi_$(WINDOW_SYSTEM_TYPE)_$(GPU_BUILD_TYPE)/target/pvrsrvkm.ko
@@ -85,6 +87,8 @@ build:
 
 install:
 	@cp -uv $(GPU_KO_NAME) $(LICHEE_MOD_DIR);
+	@cp -uv $(UMP_KO_NAME) $(LICHEE_MOD_DIR);
+	@cp -uv $(UMPLOCK_KO_NAME) $(LICHEE_MOD_DIR);
 
 clean:
 	$(MAKE) -C $(GPU_BUILD_DIR) clean
-- 
1.9.1

